
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type userPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "user"
  objects: {
    purchaseOrder: purchaseOrderPayload<ExtArgs>[]
    salesOrder: salesOrderPayload<ExtArgs>[]
    userTokens: userTokensPayload<ExtArgs>[]
    userRolePermission: userRolePermissionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    email: string
    firstName: string | null
    lastName: string | null
    address: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model user
 * 
 */
export type user = runtime.Types.DefaultSelection<userPayload>
export type productPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "product"
  objects: {
    purchaseItems: purchaseItemsPayload<ExtArgs>[]
    salesItems: salesItemsPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    productName: string
    description: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["product"]>
  composites: {}
}

/**
 * Model product
 * 
 */
export type product = runtime.Types.DefaultSelection<productPayload>
export type purchaseOrderPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "purchaseOrder"
  objects: {
    orders: purchaseItemsPayload<ExtArgs>[]
    vendorName: VendorPayload<ExtArgs>
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    purchaseOrderNo: string | null
    vendorId: number
    remarks: string | null
    total: number
    userId: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["purchaseOrder"]>
  composites: {}
}

/**
 * Model purchaseOrder
 * 
 */
export type purchaseOrder = runtime.Types.DefaultSelection<purchaseOrderPayload>
export type purchaseItemsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "purchaseItems"
  objects: {
    purchaseOrder: purchaseOrderPayload<ExtArgs>
    product: productPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    purchaseOrderId: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["purchaseItems"]>
  composites: {}
}

/**
 * Model purchaseItems
 * 
 */
export type purchaseItems = runtime.Types.DefaultSelection<purchaseItemsPayload>
export type salesOrderPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "salesOrder"
  objects: {
    orders: salesItemsPayload<ExtArgs>[]
    customerName: customerPayload<ExtArgs>
    user: userPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    salesOrderNo: string | null
    customerId: number
    userId: number | null
    remarks: string | null
    total: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["salesOrder"]>
  composites: {}
}

/**
 * Model salesOrder
 * 
 */
export type salesOrder = runtime.Types.DefaultSelection<salesOrderPayload>
export type salesItemsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "salesItems"
  objects: {
    salesOrder: salesOrderPayload<ExtArgs>
    product: productPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    salesOrderId: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["salesItems"]>
  composites: {}
}

/**
 * Model salesItems
 * 
 */
export type salesItems = runtime.Types.DefaultSelection<salesItemsPayload>
export type VendorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Vendor"
  objects: {
    purchaseOrder: purchaseOrderPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    address: string | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["vendor"]>
  composites: {}
}

/**
 * Model Vendor
 * 
 */
export type Vendor = runtime.Types.DefaultSelection<VendorPayload>
export type customerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "customer"
  objects: {
    salesOrder: salesOrderPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    address: string | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["customer"]>
  composites: {}
}

/**
 * Model customer
 * 
 */
export type customer = runtime.Types.DefaultSelection<customerPayload>
export type userTokensPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "userTokens"
  objects: {
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    userId: number
    expiry: Date
    token: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["userTokens"]>
  composites: {}
}

/**
 * Model userTokens
 * 
 */
export type userTokens = runtime.Types.DefaultSelection<userTokensPayload>
export type rolesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "roles"
  objects: {
    rolePermission: rolesPermissionPayload<ExtArgs>[]
    user: userRolePermissionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["roles"]>
  composites: {}
}

/**
 * Model roles
 * 
 */
export type roles = runtime.Types.DefaultSelection<rolesPayload>
export type permissionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "permission"
  objects: {
    rolePermission: rolesPermissionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    slug: string
  }, ExtArgs["result"]["permission"]>
  composites: {}
}

/**
 * Model permission
 * 
 */
export type permission = runtime.Types.DefaultSelection<permissionPayload>
export type rolesPermissionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "rolesPermission"
  objects: {
    role: rolesPayload<ExtArgs>
    permission: permissionPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    roleid: number
    permissionid: number
  }, ExtArgs["result"]["rolesPermission"]>
  composites: {}
}

/**
 * Model rolesPermission
 * 
 */
export type rolesPermission = runtime.Types.DefaultSelection<rolesPermissionPayload>
export type userRolePermissionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "userRolePermission"
  objects: {
    user: userPayload<ExtArgs>
    role: rolesPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number
    roleid: number
  }, ExtArgs["result"]["userRolePermission"]>
  composites: {}
}

/**
 * Model userRolePermission
 * 
 */
export type userRolePermission = runtime.Types.DefaultSelection<userRolePermissionPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **purchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.purchaseOrderDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.purchaseItems`: Exposes CRUD operations for the **purchaseItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseItems
    * const purchaseItems = await prisma.purchaseItems.findMany()
    * ```
    */
  get purchaseItems(): Prisma.purchaseItemsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.salesOrder`: Exposes CRUD operations for the **salesOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesOrders
    * const salesOrders = await prisma.salesOrder.findMany()
    * ```
    */
  get salesOrder(): Prisma.salesOrderDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.salesItems`: Exposes CRUD operations for the **salesItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesItems
    * const salesItems = await prisma.salesItems.findMany()
    * ```
    */
  get salesItems(): Prisma.salesItemsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.customerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userTokens`: Exposes CRUD operations for the **userTokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTokens
    * const userTokens = await prisma.userTokens.findMany()
    * ```
    */
  get userTokens(): Prisma.userTokensDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.permissionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.rolesPermission`: Exposes CRUD operations for the **rolesPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolesPermissions
    * const rolesPermissions = await prisma.rolesPermission.findMany()
    * ```
    */
  get rolesPermission(): Prisma.rolesPermissionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userRolePermission`: Exposes CRUD operations for the **userRolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRolePermissions
    * const userRolePermissions = await prisma.userRolePermission.findMany()
    * ```
    */
  get userRolePermission(): Prisma.userRolePermissionDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    product: 'product',
    purchaseOrder: 'purchaseOrder',
    purchaseItems: 'purchaseItems',
    salesOrder: 'salesOrder',
    salesItems: 'salesItems',
    Vendor: 'Vendor',
    customer: 'customer',
    userTokens: 'userTokens',
    roles: 'roles',
    permission: 'permission',
    rolesPermission: 'rolesPermission',
    userRolePermission: 'userRolePermission'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'product' | 'purchaseOrder' | 'purchaseItems' | 'salesOrder' | 'salesItems' | 'vendor' | 'customer' | 'userTokens' | 'roles' | 'permission' | 'rolesPermission' | 'userRolePermission'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      user: {
        payload: userPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      product: {
        payload: productPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.productFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>
          }
          findFirst: {
            args: Prisma.productFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>
          }
          findMany: {
            args: Prisma.productFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>[]
          }
          create: {
            args: Prisma.productCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>
          }
          createMany: {
            args: Prisma.productCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.productDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>
          }
          update: {
            args: Prisma.productUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>
          }
          deleteMany: {
            args: Prisma.productDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.productUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.productUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<productPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.productCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      purchaseOrder: {
        payload: purchaseOrderPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.purchaseOrderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.purchaseOrderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.purchaseOrderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.purchaseOrderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseOrderPayload>
          }
          findMany: {
            args: Prisma.purchaseOrderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseOrderPayload>[]
          }
          create: {
            args: Prisma.purchaseOrderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseOrderPayload>
          }
          createMany: {
            args: Prisma.purchaseOrderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.purchaseOrderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseOrderPayload>
          }
          update: {
            args: Prisma.purchaseOrderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.purchaseOrderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.purchaseOrderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.purchaseOrderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.purchaseOrderCountArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      purchaseItems: {
        payload: purchaseItemsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.purchaseItemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.purchaseItemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseItemsPayload>
          }
          findFirst: {
            args: Prisma.purchaseItemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.purchaseItemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseItemsPayload>
          }
          findMany: {
            args: Prisma.purchaseItemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseItemsPayload>[]
          }
          create: {
            args: Prisma.purchaseItemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseItemsPayload>
          }
          createMany: {
            args: Prisma.purchaseItemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.purchaseItemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseItemsPayload>
          }
          update: {
            args: Prisma.purchaseItemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseItemsPayload>
          }
          deleteMany: {
            args: Prisma.purchaseItemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.purchaseItemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.purchaseItemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<purchaseItemsPayload>
          }
          aggregate: {
            args: Prisma.PurchaseItemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePurchaseItems>
          }
          groupBy: {
            args: Prisma.PurchaseItemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.purchaseItemsCountArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseItemsCountAggregateOutputType> | number
          }
        }
      }
      salesOrder: {
        payload: salesOrderPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.salesOrderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.salesOrderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesOrderPayload>
          }
          findFirst: {
            args: Prisma.salesOrderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.salesOrderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesOrderPayload>
          }
          findMany: {
            args: Prisma.salesOrderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesOrderPayload>[]
          }
          create: {
            args: Prisma.salesOrderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesOrderPayload>
          }
          createMany: {
            args: Prisma.salesOrderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.salesOrderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesOrderPayload>
          }
          update: {
            args: Prisma.salesOrderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesOrderPayload>
          }
          deleteMany: {
            args: Prisma.salesOrderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.salesOrderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.salesOrderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesOrderPayload>
          }
          aggregate: {
            args: Prisma.SalesOrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSalesOrder>
          }
          groupBy: {
            args: Prisma.SalesOrderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SalesOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.salesOrderCountArgs<ExtArgs>,
            result: $Utils.Optional<SalesOrderCountAggregateOutputType> | number
          }
        }
      }
      salesItems: {
        payload: salesItemsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.salesItemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.salesItemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesItemsPayload>
          }
          findFirst: {
            args: Prisma.salesItemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.salesItemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesItemsPayload>
          }
          findMany: {
            args: Prisma.salesItemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesItemsPayload>[]
          }
          create: {
            args: Prisma.salesItemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesItemsPayload>
          }
          createMany: {
            args: Prisma.salesItemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.salesItemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesItemsPayload>
          }
          update: {
            args: Prisma.salesItemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesItemsPayload>
          }
          deleteMany: {
            args: Prisma.salesItemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.salesItemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.salesItemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<salesItemsPayload>
          }
          aggregate: {
            args: Prisma.SalesItemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSalesItems>
          }
          groupBy: {
            args: Prisma.SalesItemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SalesItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.salesItemsCountArgs<ExtArgs>,
            result: $Utils.Optional<SalesItemsCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: VendorPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>,
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      customer: {
        payload: customerPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.customerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<customerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<customerPayload>
          }
          findFirst: {
            args: Prisma.customerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<customerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<customerPayload>
          }
          findMany: {
            args: Prisma.customerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<customerPayload>[]
          }
          create: {
            args: Prisma.customerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<customerPayload>
          }
          createMany: {
            args: Prisma.customerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.customerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<customerPayload>
          }
          update: {
            args: Prisma.customerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<customerPayload>
          }
          deleteMany: {
            args: Prisma.customerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.customerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.customerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<customerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      userTokens: {
        payload: userTokensPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.userTokensFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userTokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userTokensFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userTokensPayload>
          }
          findFirst: {
            args: Prisma.userTokensFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userTokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userTokensFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userTokensPayload>
          }
          findMany: {
            args: Prisma.userTokensFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userTokensPayload>[]
          }
          create: {
            args: Prisma.userTokensCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userTokensPayload>
          }
          createMany: {
            args: Prisma.userTokensCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userTokensDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userTokensPayload>
          }
          update: {
            args: Prisma.userTokensUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userTokensPayload>
          }
          deleteMany: {
            args: Prisma.userTokensDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userTokensUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userTokensUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userTokensPayload>
          }
          aggregate: {
            args: Prisma.UserTokensAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserTokens>
          }
          groupBy: {
            args: Prisma.UserTokensGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserTokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.userTokensCountArgs<ExtArgs>,
            result: $Utils.Optional<UserTokensCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: rolesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.RolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>,
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      permission: {
        payload: permissionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.permissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>
          }
          findFirst: {
            args: Prisma.permissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>
          }
          findMany: {
            args: Prisma.permissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>[]
          }
          create: {
            args: Prisma.permissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>
          }
          createMany: {
            args: Prisma.permissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.permissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>
          }
          update: {
            args: Prisma.permissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>
          }
          deleteMany: {
            args: Prisma.permissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.permissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.permissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<permissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionCountArgs<ExtArgs>,
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      rolesPermission: {
        payload: rolesPermissionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.rolesPermissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesPermissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPermissionPayload>
          }
          findFirst: {
            args: Prisma.rolesPermissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesPermissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPermissionPayload>
          }
          findMany: {
            args: Prisma.rolesPermissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPermissionPayload>[]
          }
          create: {
            args: Prisma.rolesPermissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPermissionPayload>
          }
          createMany: {
            args: Prisma.rolesPermissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rolesPermissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPermissionPayload>
          }
          update: {
            args: Prisma.rolesPermissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPermissionPayload>
          }
          deleteMany: {
            args: Prisma.rolesPermissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rolesPermissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rolesPermissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rolesPermissionPayload>
          }
          aggregate: {
            args: Prisma.RolesPermissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRolesPermission>
          }
          groupBy: {
            args: Prisma.RolesPermissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RolesPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesPermissionCountArgs<ExtArgs>,
            result: $Utils.Optional<RolesPermissionCountAggregateOutputType> | number
          }
        }
      }
      userRolePermission: {
        payload: userRolePermissionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.userRolePermissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userRolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userRolePermissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userRolePermissionPayload>
          }
          findFirst: {
            args: Prisma.userRolePermissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userRolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userRolePermissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userRolePermissionPayload>
          }
          findMany: {
            args: Prisma.userRolePermissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userRolePermissionPayload>[]
          }
          create: {
            args: Prisma.userRolePermissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userRolePermissionPayload>
          }
          createMany: {
            args: Prisma.userRolePermissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userRolePermissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userRolePermissionPayload>
          }
          update: {
            args: Prisma.userRolePermissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userRolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.userRolePermissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userRolePermissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userRolePermissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userRolePermissionPayload>
          }
          aggregate: {
            args: Prisma.UserRolePermissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserRolePermission>
          }
          groupBy: {
            args: Prisma.UserRolePermissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserRolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.userRolePermissionCountArgs<ExtArgs>,
            result: $Utils.Optional<UserRolePermissionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    purchaseOrder: number
    salesOrder: number
    userTokens: number
    userRolePermission: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | UserCountOutputTypeCountPurchaseOrderArgs
    salesOrder?: boolean | UserCountOutputTypeCountSalesOrderArgs
    userTokens?: boolean | UserCountOutputTypeCountUserTokensArgs
    userRolePermission?: boolean | UserCountOutputTypeCountUserRolePermissionArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchaseOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: purchaseOrderWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalesOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: salesOrderWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserTokensArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userTokensWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolePermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userRolePermissionWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    purchaseItems: number
    salesItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    purchaseItems?: boolean | ProductCountOutputTypeCountPurchaseItemsArgs
    salesItems?: boolean | ProductCountOutputTypeCountSalesItemsArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: purchaseItemsWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSalesItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: salesItemsWhereInput
  }



  /**
   * Count Type PurchaseOrderCountOutputType
   */


  export type PurchaseOrderCountOutputType = {
    orders: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    orders?: boolean | PurchaseOrderCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: purchaseItemsWhereInput
  }



  /**
   * Count Type SalesOrderCountOutputType
   */


  export type SalesOrderCountOutputType = {
    orders: number
  }

  export type SalesOrderCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    orders?: boolean | SalesOrderCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes

  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderCountOutputType
     */
    select?: SalesOrderCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: salesItemsWhereInput
  }



  /**
   * Count Type VendorCountOutputType
   */


  export type VendorCountOutputType = {
    purchaseOrder: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | VendorCountOutputTypeCountPurchaseOrderArgs
  }

  // Custom InputTypes

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPurchaseOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: purchaseOrderWhereInput
  }



  /**
   * Count Type CustomerCountOutputType
   */


  export type CustomerCountOutputType = {
    salesOrder: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    salesOrder?: boolean | CustomerCountOutputTypeCountSalesOrderArgs
  }

  // Custom InputTypes

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: salesOrderWhereInput
  }



  /**
   * Count Type RolesCountOutputType
   */


  export type RolesCountOutputType = {
    rolePermission: number
    user: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    rolePermission?: boolean | RolesCountOutputTypeCountRolePermissionArgs
    user?: boolean | RolesCountOutputTypeCountUserArgs
  }

  // Custom InputTypes

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountRolePermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: rolesPermissionWhereInput
  }


  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userRolePermissionWhereInput
  }



  /**
   * Count Type PermissionCountOutputType
   */


  export type PermissionCountOutputType = {
    rolePermission: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    rolePermission?: boolean | PermissionCountOutputTypeCountRolePermissionArgs
  }

  // Custom InputTypes

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: rolesPermissionWhereInput
  }



  /**
   * Models
   */

  /**
   * Model user
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    firstName: string | null
    lastName: string | null
    address: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    firstName: string | null
    lastName: string | null
    address: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    address: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    address?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    address?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    address?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: Enumerable<userOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    email: string
    firstName: string | null
    lastName: string | null
    address: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    address?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | user$purchaseOrderArgs<ExtArgs>
    salesOrder?: boolean | user$salesOrderArgs<ExtArgs>
    userTokens?: boolean | user$userTokensArgs<ExtArgs>
    userRolePermission?: boolean | user$userRolePermissionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    address?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | user$purchaseOrderArgs<ExtArgs>
    salesOrder?: boolean | user$salesOrderArgs<ExtArgs>
    userTokens?: boolean | user$userTokensArgs<ExtArgs>
    userRolePermission?: boolean | user$userRolePermissionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type userGetPayload<S extends boolean | null | undefined | userArgs> = $Types.GetResult<userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user'> extends True ? Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user'> extends True ? Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<userPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    purchaseOrder<T extends user$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, user$purchaseOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'findMany', never>| Null>;

    salesOrder<T extends user$salesOrderArgs<ExtArgs> = {}>(args?: Subset<T, user$salesOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'findMany', never>| Null>;

    userTokens<T extends user$userTokensArgs<ExtArgs> = {}>(args?: Subset<T, user$userTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<userTokensPayload<ExtArgs>, T, 'findMany', never>| Null>;

    userRolePermission<T extends user$userRolePermissionArgs<ExtArgs> = {}>(args?: Subset<T, user$userRolePermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user base type for findUnique actions
   */
  export type userFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUnique
   */
  export interface userFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends userFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user base type for findFirst actions
   */
  export type userFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * user findFirst
   */
  export interface userFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends userFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: Enumerable<userCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.purchaseOrder
   */
  export type user$purchaseOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseOrder
     */
    select?: purchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseOrderInclude<ExtArgs> | null
    where?: purchaseOrderWhereInput
    orderBy?: Enumerable<purchaseOrderOrderByWithRelationInput>
    cursor?: purchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PurchaseOrderScalarFieldEnum>
  }


  /**
   * user.salesOrder
   */
  export type user$salesOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesOrder
     */
    select?: salesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesOrderInclude<ExtArgs> | null
    where?: salesOrderWhereInput
    orderBy?: Enumerable<salesOrderOrderByWithRelationInput>
    cursor?: salesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesOrderScalarFieldEnum>
  }


  /**
   * user.userTokens
   */
  export type user$userTokensArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userTokens
     */
    select?: userTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTokensInclude<ExtArgs> | null
    where?: userTokensWhereInput
    orderBy?: Enumerable<userTokensOrderByWithRelationInput>
    cursor?: userTokensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserTokensScalarFieldEnum>
  }


  /**
   * user.userRolePermission
   */
  export type user$userRolePermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userRolePermission
     */
    select?: userRolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userRolePermissionInclude<ExtArgs> | null
    where?: userRolePermissionWhereInput
    orderBy?: Enumerable<userRolePermissionOrderByWithRelationInput>
    cursor?: userRolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserRolePermissionScalarFieldEnum>
  }


  /**
   * user without action
   */
  export type userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
  }



  /**
   * Model product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    purchasePrice: number | null
    sellingPrice: number | null
    quantity: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    purchasePrice: number | null
    sellingPrice: number | null
    quantity: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    productName: string | null
    description: string | null
    purchasePrice: number | null
    sellingPrice: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    productName: string | null
    description: string | null
    purchasePrice: number | null
    sellingPrice: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    productName: number
    description: number
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    purchasePrice?: true
    sellingPrice?: true
    quantity?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    purchasePrice?: true
    sellingPrice?: true
    quantity?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    productName?: true
    description?: true
    purchasePrice?: true
    sellingPrice?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    productName?: true
    description?: true
    purchasePrice?: true
    sellingPrice?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    productName?: true
    description?: true
    purchasePrice?: true
    sellingPrice?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which product to aggregate.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: Enumerable<productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: productWhereInput
    orderBy?: Enumerable<productOrderByWithAggregationInput>
    by: ProductScalarFieldEnum[]
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: number
    productName: string
    description: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productName?: boolean
    description?: boolean
    purchasePrice?: boolean
    sellingPrice?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseItems?: boolean | product$purchaseItemsArgs<ExtArgs>
    salesItems?: boolean | product$salesItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectScalar = {
    id?: boolean
    productName?: boolean
    description?: boolean
    purchasePrice?: boolean
    sellingPrice?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type productInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    purchaseItems?: boolean | product$purchaseItemsArgs<ExtArgs>
    salesItems?: boolean | product$salesItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeArgs<ExtArgs>
  }


  type productGetPayload<S extends boolean | null | undefined | productArgs> = $Types.GetResult<productPayload, S>

  type productCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<productFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface productDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product'], meta: { name: 'product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends productFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, productFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'product'> extends True ? Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {productFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends productFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends productFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, productFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'product'> extends True ? Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends productFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends productFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<productPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends productCreateArgs<ExtArgs>>(
      args: SelectSubset<T, productCreateArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {productCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends productCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends productDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, productDeleteArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends productUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, productUpdateArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends productDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends productUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, productUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends productUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, productUpsertArgs<ExtArgs>>
    ): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__productClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    purchaseItems<T extends product$purchaseItemsArgs<ExtArgs> = {}>(args?: Subset<T, product$purchaseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    salesItems<T extends product$salesItemsArgs<ExtArgs> = {}>(args?: Subset<T, product$salesItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * product base type for findUnique actions
   */
  export type productFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }

  /**
   * product findUnique
   */
  export interface productFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends productFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * product findUniqueOrThrow
   */
  export type productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }


  /**
   * product base type for findFirst actions
   */
  export type productFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: Enumerable<productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * product findFirst
   */
  export interface productFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends productFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * product findFirstOrThrow
   */
  export type productFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: Enumerable<productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * product findMany
   */
  export type productFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: Enumerable<productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * product create
   */
  export type productCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to create a product.
     */
    data: XOR<productCreateInput, productUncheckedCreateInput>
  }


  /**
   * product createMany
   */
  export type productCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: Enumerable<productCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * product update
   */
  export type productUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to update a product.
     */
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     */
    where: productWhereUniqueInput
  }


  /**
   * product updateMany
   */
  export type productUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
  }


  /**
   * product upsert
   */
  export type productUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The filter to search for the product to update in case it exists.
     */
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     */
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }


  /**
   * product delete
   */
  export type productDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter which product to delete.
     */
    where: productWhereUniqueInput
  }


  /**
   * product deleteMany
   */
  export type productDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productWhereInput
  }


  /**
   * product.purchaseItems
   */
  export type product$purchaseItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseItems
     */
    select?: purchaseItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseItemsInclude<ExtArgs> | null
    where?: purchaseItemsWhereInput
    orderBy?: Enumerable<purchaseItemsOrderByWithRelationInput>
    cursor?: purchaseItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PurchaseItemsScalarFieldEnum>
  }


  /**
   * product.salesItems
   */
  export type product$salesItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesItems
     */
    select?: salesItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesItemsInclude<ExtArgs> | null
    where?: salesItemsWhereInput
    orderBy?: Enumerable<salesItemsOrderByWithRelationInput>
    cursor?: salesItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesItemsScalarFieldEnum>
  }


  /**
   * product without action
   */
  export type productArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
  }



  /**
   * Model purchaseOrder
   */


  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
    total: number | null
    userId: number | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
    total: number | null
    userId: number | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: number | null
    purchaseOrderNo: string | null
    vendorId: number | null
    remarks: string | null
    total: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: number | null
    purchaseOrderNo: string | null
    vendorId: number | null
    remarks: string | null
    total: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    purchaseOrderNo: number
    vendorId: number
    remarks: number
    total: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    id?: true
    vendorId?: true
    total?: true
    userId?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    id?: true
    vendorId?: true
    total?: true
    userId?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    purchaseOrderNo?: true
    vendorId?: true
    remarks?: true
    total?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    purchaseOrderNo?: true
    vendorId?: true
    remarks?: true
    total?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    purchaseOrderNo?: true
    vendorId?: true
    remarks?: true
    total?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchaseOrder to aggregate.
     */
    where?: purchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchaseOrders to fetch.
     */
    orderBy?: Enumerable<purchaseOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: purchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned purchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: purchaseOrderWhereInput
    orderBy?: Enumerable<purchaseOrderOrderByWithAggregationInput>
    by: PurchaseOrderScalarFieldEnum[]
    having?: purchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }


  export type PurchaseOrderGroupByOutputType = {
    id: number
    purchaseOrderNo: string | null
    vendorId: number
    remarks: string | null
    total: number
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type purchaseOrderSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderNo?: boolean
    vendorId?: boolean
    remarks?: boolean
    total?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | purchaseOrder$ordersArgs<ExtArgs>
    vendorName?: boolean | VendorArgs<ExtArgs>
    user?: boolean | userArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type purchaseOrderSelectScalar = {
    id?: boolean
    purchaseOrderNo?: boolean
    vendorId?: boolean
    remarks?: boolean
    total?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type purchaseOrderInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    orders?: boolean | purchaseOrder$ordersArgs<ExtArgs>
    vendorName?: boolean | VendorArgs<ExtArgs>
    user?: boolean | userArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeArgs<ExtArgs>
  }


  type purchaseOrderGetPayload<S extends boolean | null | undefined | purchaseOrderArgs> = $Types.GetResult<purchaseOrderPayload, S>

  type purchaseOrderCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<purchaseOrderFindManyArgs, 'select' | 'include'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface purchaseOrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['purchaseOrder'], meta: { name: 'purchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {purchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends purchaseOrderFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, purchaseOrderFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'purchaseOrder'> extends True ? Prisma__purchaseOrderClient<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__purchaseOrderClient<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {purchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends purchaseOrderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseOrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__purchaseOrderClient<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends purchaseOrderFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, purchaseOrderFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'purchaseOrder'> extends True ? Prisma__purchaseOrderClient<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__purchaseOrderClient<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends purchaseOrderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseOrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__purchaseOrderClient<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends purchaseOrderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseOrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PurchaseOrder.
     * @param {purchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
    **/
    create<T extends purchaseOrderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseOrderCreateArgs<ExtArgs>>
    ): Prisma__purchaseOrderClient<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PurchaseOrders.
     *     @param {purchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     *     @example
     *     // Create many PurchaseOrders
     *     const purchaseOrder = await prisma.purchaseOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends purchaseOrderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseOrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseOrder.
     * @param {purchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
    **/
    delete<T extends purchaseOrderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseOrderDeleteArgs<ExtArgs>>
    ): Prisma__purchaseOrderClient<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PurchaseOrder.
     * @param {purchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends purchaseOrderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseOrderUpdateArgs<ExtArgs>>
    ): Prisma__purchaseOrderClient<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {purchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends purchaseOrderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseOrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends purchaseOrderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseOrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseOrder.
     * @param {purchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
    **/
    upsert<T extends purchaseOrderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseOrderUpsertArgs<ExtArgs>>
    ): Prisma__purchaseOrderClient<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends purchaseOrderCountArgs>(
      args?: Subset<T, purchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for purchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__purchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    orders<T extends purchaseOrder$ordersArgs<ExtArgs> = {}>(args?: Subset<T, purchaseOrder$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    vendorName<T extends VendorArgs<ExtArgs> = {}>(args?: Subset<T, VendorArgs<ExtArgs>>): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * purchaseOrder base type for findUnique actions
   */
  export type purchaseOrderFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseOrder
     */
    select?: purchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which purchaseOrder to fetch.
     */
    where: purchaseOrderWhereUniqueInput
  }

  /**
   * purchaseOrder findUnique
   */
  export interface purchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends purchaseOrderFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * purchaseOrder findUniqueOrThrow
   */
  export type purchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseOrder
     */
    select?: purchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which purchaseOrder to fetch.
     */
    where: purchaseOrderWhereUniqueInput
  }


  /**
   * purchaseOrder base type for findFirst actions
   */
  export type purchaseOrderFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseOrder
     */
    select?: purchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which purchaseOrder to fetch.
     */
    where?: purchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchaseOrders to fetch.
     */
    orderBy?: Enumerable<purchaseOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchaseOrders.
     */
    cursor?: purchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchaseOrders.
     */
    distinct?: Enumerable<PurchaseOrderScalarFieldEnum>
  }

  /**
   * purchaseOrder findFirst
   */
  export interface purchaseOrderFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends purchaseOrderFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * purchaseOrder findFirstOrThrow
   */
  export type purchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseOrder
     */
    select?: purchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which purchaseOrder to fetch.
     */
    where?: purchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchaseOrders to fetch.
     */
    orderBy?: Enumerable<purchaseOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchaseOrders.
     */
    cursor?: purchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchaseOrders.
     */
    distinct?: Enumerable<PurchaseOrderScalarFieldEnum>
  }


  /**
   * purchaseOrder findMany
   */
  export type purchaseOrderFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseOrder
     */
    select?: purchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which purchaseOrders to fetch.
     */
    where?: purchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchaseOrders to fetch.
     */
    orderBy?: Enumerable<purchaseOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing purchaseOrders.
     */
    cursor?: purchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchaseOrders.
     */
    skip?: number
    distinct?: Enumerable<PurchaseOrderScalarFieldEnum>
  }


  /**
   * purchaseOrder create
   */
  export type purchaseOrderCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseOrder
     */
    select?: purchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a purchaseOrder.
     */
    data: XOR<purchaseOrderCreateInput, purchaseOrderUncheckedCreateInput>
  }


  /**
   * purchaseOrder createMany
   */
  export type purchaseOrderCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many purchaseOrders.
     */
    data: Enumerable<purchaseOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * purchaseOrder update
   */
  export type purchaseOrderUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseOrder
     */
    select?: purchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a purchaseOrder.
     */
    data: XOR<purchaseOrderUpdateInput, purchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which purchaseOrder to update.
     */
    where: purchaseOrderWhereUniqueInput
  }


  /**
   * purchaseOrder updateMany
   */
  export type purchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update purchaseOrders.
     */
    data: XOR<purchaseOrderUpdateManyMutationInput, purchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which purchaseOrders to update
     */
    where?: purchaseOrderWhereInput
  }


  /**
   * purchaseOrder upsert
   */
  export type purchaseOrderUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseOrder
     */
    select?: purchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the purchaseOrder to update in case it exists.
     */
    where: purchaseOrderWhereUniqueInput
    /**
     * In case the purchaseOrder found by the `where` argument doesn't exist, create a new purchaseOrder with this data.
     */
    create: XOR<purchaseOrderCreateInput, purchaseOrderUncheckedCreateInput>
    /**
     * In case the purchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<purchaseOrderUpdateInput, purchaseOrderUncheckedUpdateInput>
  }


  /**
   * purchaseOrder delete
   */
  export type purchaseOrderDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseOrder
     */
    select?: purchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which purchaseOrder to delete.
     */
    where: purchaseOrderWhereUniqueInput
  }


  /**
   * purchaseOrder deleteMany
   */
  export type purchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchaseOrders to delete
     */
    where?: purchaseOrderWhereInput
  }


  /**
   * purchaseOrder.orders
   */
  export type purchaseOrder$ordersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseItems
     */
    select?: purchaseItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseItemsInclude<ExtArgs> | null
    where?: purchaseItemsWhereInput
    orderBy?: Enumerable<purchaseItemsOrderByWithRelationInput>
    cursor?: purchaseItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PurchaseItemsScalarFieldEnum>
  }


  /**
   * purchaseOrder without action
   */
  export type purchaseOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseOrder
     */
    select?: purchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseOrderInclude<ExtArgs> | null
  }



  /**
   * Model purchaseItems
   */


  export type AggregatePurchaseItems = {
    _count: PurchaseItemsCountAggregateOutputType | null
    _avg: PurchaseItemsAvgAggregateOutputType | null
    _sum: PurchaseItemsSumAggregateOutputType | null
    _min: PurchaseItemsMinAggregateOutputType | null
    _max: PurchaseItemsMaxAggregateOutputType | null
  }

  export type PurchaseItemsAvgAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    productId: number | null
    quantity: number | null
    purchasePrice: number | null
    total: number | null
  }

  export type PurchaseItemsSumAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    productId: number | null
    quantity: number | null
    purchasePrice: number | null
    total: number | null
  }

  export type PurchaseItemsMinAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    productId: number | null
    quantity: number | null
    purchasePrice: number | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseItemsMaxAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    productId: number | null
    quantity: number | null
    purchasePrice: number | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseItemsCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseItemsAvgAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    purchasePrice?: true
    total?: true
  }

  export type PurchaseItemsSumAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    purchasePrice?: true
    total?: true
  }

  export type PurchaseItemsMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    purchasePrice?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseItemsMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    purchasePrice?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseItemsCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    purchasePrice?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseItemsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchaseItems to aggregate.
     */
    where?: purchaseItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchaseItems to fetch.
     */
    orderBy?: Enumerable<purchaseItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: purchaseItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned purchaseItems
    **/
    _count?: true | PurchaseItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseItemsMaxAggregateInputType
  }

  export type GetPurchaseItemsAggregateType<T extends PurchaseItemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseItems[P]>
      : GetScalarType<T[P], AggregatePurchaseItems[P]>
  }




  export type PurchaseItemsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: purchaseItemsWhereInput
    orderBy?: Enumerable<purchaseItemsOrderByWithAggregationInput>
    by: PurchaseItemsScalarFieldEnum[]
    having?: purchaseItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseItemsCountAggregateInputType | true
    _avg?: PurchaseItemsAvgAggregateInputType
    _sum?: PurchaseItemsSumAggregateInputType
    _min?: PurchaseItemsMinAggregateInputType
    _max?: PurchaseItemsMaxAggregateInputType
  }


  export type PurchaseItemsGroupByOutputType = {
    id: number
    purchaseOrderId: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseItemsCountAggregateOutputType | null
    _avg: PurchaseItemsAvgAggregateOutputType | null
    _sum: PurchaseItemsSumAggregateOutputType | null
    _min: PurchaseItemsMinAggregateOutputType | null
    _max: PurchaseItemsMaxAggregateOutputType | null
  }

  type GetPurchaseItemsGroupByPayload<T extends PurchaseItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PurchaseItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseItemsGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseItemsGroupByOutputType[P]>
        }
      >
    >


  export type purchaseItemsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    purchasePrice?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | purchaseOrderArgs<ExtArgs>
    product?: boolean | productArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItems"]>

  export type purchaseItemsSelectScalar = {
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    purchasePrice?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type purchaseItemsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | purchaseOrderArgs<ExtArgs>
    product?: boolean | productArgs<ExtArgs>
  }


  type purchaseItemsGetPayload<S extends boolean | null | undefined | purchaseItemsArgs> = $Types.GetResult<purchaseItemsPayload, S>

  type purchaseItemsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<purchaseItemsFindManyArgs, 'select' | 'include'> & {
      select?: PurchaseItemsCountAggregateInputType | true
    }

  export interface purchaseItemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['purchaseItems'], meta: { name: 'purchaseItems' } }
    /**
     * Find zero or one PurchaseItems that matches the filter.
     * @param {purchaseItemsFindUniqueArgs} args - Arguments to find a PurchaseItems
     * @example
     * // Get one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends purchaseItemsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, purchaseItemsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'purchaseItems'> extends True ? Prisma__purchaseItemsClient<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__purchaseItemsClient<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PurchaseItems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {purchaseItemsFindUniqueOrThrowArgs} args - Arguments to find a PurchaseItems
     * @example
     * // Get one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends purchaseItemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseItemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__purchaseItemsClient<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseItemsFindFirstArgs} args - Arguments to find a PurchaseItems
     * @example
     * // Get one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends purchaseItemsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, purchaseItemsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'purchaseItems'> extends True ? Prisma__purchaseItemsClient<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__purchaseItemsClient<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PurchaseItems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseItemsFindFirstOrThrowArgs} args - Arguments to find a PurchaseItems
     * @example
     * // Get one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends purchaseItemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseItemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__purchaseItemsClient<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findMany()
     * 
     * // Get first 10 PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseItemsWithIdOnly = await prisma.purchaseItems.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends purchaseItemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseItemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PurchaseItems.
     * @param {purchaseItemsCreateArgs} args - Arguments to create a PurchaseItems.
     * @example
     * // Create one PurchaseItems
     * const PurchaseItems = await prisma.purchaseItems.create({
     *   data: {
     *     // ... data to create a PurchaseItems
     *   }
     * })
     * 
    **/
    create<T extends purchaseItemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseItemsCreateArgs<ExtArgs>>
    ): Prisma__purchaseItemsClient<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PurchaseItems.
     *     @param {purchaseItemsCreateManyArgs} args - Arguments to create many PurchaseItems.
     *     @example
     *     // Create many PurchaseItems
     *     const purchaseItems = await prisma.purchaseItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends purchaseItemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseItemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseItems.
     * @param {purchaseItemsDeleteArgs} args - Arguments to delete one PurchaseItems.
     * @example
     * // Delete one PurchaseItems
     * const PurchaseItems = await prisma.purchaseItems.delete({
     *   where: {
     *     // ... filter to delete one PurchaseItems
     *   }
     * })
     * 
    **/
    delete<T extends purchaseItemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseItemsDeleteArgs<ExtArgs>>
    ): Prisma__purchaseItemsClient<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PurchaseItems.
     * @param {purchaseItemsUpdateArgs} args - Arguments to update one PurchaseItems.
     * @example
     * // Update one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends purchaseItemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseItemsUpdateArgs<ExtArgs>>
    ): Prisma__purchaseItemsClient<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PurchaseItems.
     * @param {purchaseItemsDeleteManyArgs} args - Arguments to filter PurchaseItems to delete.
     * @example
     * // Delete a few PurchaseItems
     * const { count } = await prisma.purchaseItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends purchaseItemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseItemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends purchaseItemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseItemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseItems.
     * @param {purchaseItemsUpsertArgs} args - Arguments to update or create a PurchaseItems.
     * @example
     * // Update or create a PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.upsert({
     *   create: {
     *     // ... data to create a PurchaseItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseItems we want to update
     *   }
     * })
    **/
    upsert<T extends purchaseItemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseItemsUpsertArgs<ExtArgs>>
    ): Prisma__purchaseItemsClient<$Types.GetResult<purchaseItemsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseItemsCountArgs} args - Arguments to filter PurchaseItems to count.
     * @example
     * // Count the number of PurchaseItems
     * const count = await prisma.purchaseItems.count({
     *   where: {
     *     // ... the filter for the PurchaseItems we want to count
     *   }
     * })
    **/
    count<T extends purchaseItemsCountArgs>(
      args?: Subset<T, purchaseItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseItemsAggregateArgs>(args: Subset<T, PurchaseItemsAggregateArgs>): Prisma.PrismaPromise<GetPurchaseItemsAggregateType<T>>

    /**
     * Group by PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseItemsGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for purchaseItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__purchaseItemsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    purchaseOrder<T extends purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, purchaseOrderArgs<ExtArgs>>): Prisma__purchaseOrderClient<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    product<T extends productArgs<ExtArgs> = {}>(args?: Subset<T, productArgs<ExtArgs>>): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * purchaseItems base type for findUnique actions
   */
  export type purchaseItemsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseItems
     */
    select?: purchaseItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseItemsInclude<ExtArgs> | null
    /**
     * Filter, which purchaseItems to fetch.
     */
    where: purchaseItemsWhereUniqueInput
  }

  /**
   * purchaseItems findUnique
   */
  export interface purchaseItemsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends purchaseItemsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * purchaseItems findUniqueOrThrow
   */
  export type purchaseItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseItems
     */
    select?: purchaseItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseItemsInclude<ExtArgs> | null
    /**
     * Filter, which purchaseItems to fetch.
     */
    where: purchaseItemsWhereUniqueInput
  }


  /**
   * purchaseItems base type for findFirst actions
   */
  export type purchaseItemsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseItems
     */
    select?: purchaseItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseItemsInclude<ExtArgs> | null
    /**
     * Filter, which purchaseItems to fetch.
     */
    where?: purchaseItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchaseItems to fetch.
     */
    orderBy?: Enumerable<purchaseItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchaseItems.
     */
    cursor?: purchaseItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchaseItems.
     */
    distinct?: Enumerable<PurchaseItemsScalarFieldEnum>
  }

  /**
   * purchaseItems findFirst
   */
  export interface purchaseItemsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends purchaseItemsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * purchaseItems findFirstOrThrow
   */
  export type purchaseItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseItems
     */
    select?: purchaseItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseItemsInclude<ExtArgs> | null
    /**
     * Filter, which purchaseItems to fetch.
     */
    where?: purchaseItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchaseItems to fetch.
     */
    orderBy?: Enumerable<purchaseItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchaseItems.
     */
    cursor?: purchaseItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchaseItems.
     */
    distinct?: Enumerable<PurchaseItemsScalarFieldEnum>
  }


  /**
   * purchaseItems findMany
   */
  export type purchaseItemsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseItems
     */
    select?: purchaseItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseItemsInclude<ExtArgs> | null
    /**
     * Filter, which purchaseItems to fetch.
     */
    where?: purchaseItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchaseItems to fetch.
     */
    orderBy?: Enumerable<purchaseItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing purchaseItems.
     */
    cursor?: purchaseItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchaseItems.
     */
    skip?: number
    distinct?: Enumerable<PurchaseItemsScalarFieldEnum>
  }


  /**
   * purchaseItems create
   */
  export type purchaseItemsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseItems
     */
    select?: purchaseItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a purchaseItems.
     */
    data: XOR<purchaseItemsCreateInput, purchaseItemsUncheckedCreateInput>
  }


  /**
   * purchaseItems createMany
   */
  export type purchaseItemsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many purchaseItems.
     */
    data: Enumerable<purchaseItemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * purchaseItems update
   */
  export type purchaseItemsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseItems
     */
    select?: purchaseItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a purchaseItems.
     */
    data: XOR<purchaseItemsUpdateInput, purchaseItemsUncheckedUpdateInput>
    /**
     * Choose, which purchaseItems to update.
     */
    where: purchaseItemsWhereUniqueInput
  }


  /**
   * purchaseItems updateMany
   */
  export type purchaseItemsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update purchaseItems.
     */
    data: XOR<purchaseItemsUpdateManyMutationInput, purchaseItemsUncheckedUpdateManyInput>
    /**
     * Filter which purchaseItems to update
     */
    where?: purchaseItemsWhereInput
  }


  /**
   * purchaseItems upsert
   */
  export type purchaseItemsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseItems
     */
    select?: purchaseItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the purchaseItems to update in case it exists.
     */
    where: purchaseItemsWhereUniqueInput
    /**
     * In case the purchaseItems found by the `where` argument doesn't exist, create a new purchaseItems with this data.
     */
    create: XOR<purchaseItemsCreateInput, purchaseItemsUncheckedCreateInput>
    /**
     * In case the purchaseItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<purchaseItemsUpdateInput, purchaseItemsUncheckedUpdateInput>
  }


  /**
   * purchaseItems delete
   */
  export type purchaseItemsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseItems
     */
    select?: purchaseItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseItemsInclude<ExtArgs> | null
    /**
     * Filter which purchaseItems to delete.
     */
    where: purchaseItemsWhereUniqueInput
  }


  /**
   * purchaseItems deleteMany
   */
  export type purchaseItemsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchaseItems to delete
     */
    where?: purchaseItemsWhereInput
  }


  /**
   * purchaseItems without action
   */
  export type purchaseItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseItems
     */
    select?: purchaseItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseItemsInclude<ExtArgs> | null
  }



  /**
   * Model salesOrder
   */


  export type AggregateSalesOrder = {
    _count: SalesOrderCountAggregateOutputType | null
    _avg: SalesOrderAvgAggregateOutputType | null
    _sum: SalesOrderSumAggregateOutputType | null
    _min: SalesOrderMinAggregateOutputType | null
    _max: SalesOrderMaxAggregateOutputType | null
  }

  export type SalesOrderAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    userId: number | null
    total: number | null
  }

  export type SalesOrderSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    userId: number | null
    total: number | null
  }

  export type SalesOrderMinAggregateOutputType = {
    id: number | null
    salesOrderNo: string | null
    customerId: number | null
    userId: number | null
    remarks: string | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesOrderMaxAggregateOutputType = {
    id: number | null
    salesOrderNo: string | null
    customerId: number | null
    userId: number | null
    remarks: string | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesOrderCountAggregateOutputType = {
    id: number
    salesOrderNo: number
    customerId: number
    userId: number
    remarks: number
    total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesOrderAvgAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
    total?: true
  }

  export type SalesOrderSumAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
    total?: true
  }

  export type SalesOrderMinAggregateInputType = {
    id?: true
    salesOrderNo?: true
    customerId?: true
    userId?: true
    remarks?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesOrderMaxAggregateInputType = {
    id?: true
    salesOrderNo?: true
    customerId?: true
    userId?: true
    remarks?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesOrderCountAggregateInputType = {
    id?: true
    salesOrderNo?: true
    customerId?: true
    userId?: true
    remarks?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesOrderAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which salesOrder to aggregate.
     */
    where?: salesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salesOrders to fetch.
     */
    orderBy?: Enumerable<salesOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: salesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned salesOrders
    **/
    _count?: true | SalesOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesOrderMaxAggregateInputType
  }

  export type GetSalesOrderAggregateType<T extends SalesOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesOrder[P]>
      : GetScalarType<T[P], AggregateSalesOrder[P]>
  }




  export type SalesOrderGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: salesOrderWhereInput
    orderBy?: Enumerable<salesOrderOrderByWithAggregationInput>
    by: SalesOrderScalarFieldEnum[]
    having?: salesOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesOrderCountAggregateInputType | true
    _avg?: SalesOrderAvgAggregateInputType
    _sum?: SalesOrderSumAggregateInputType
    _min?: SalesOrderMinAggregateInputType
    _max?: SalesOrderMaxAggregateInputType
  }


  export type SalesOrderGroupByOutputType = {
    id: number
    salesOrderNo: string | null
    customerId: number
    userId: number | null
    remarks: string | null
    total: number
    createdAt: Date
    updatedAt: Date
    _count: SalesOrderCountAggregateOutputType | null
    _avg: SalesOrderAvgAggregateOutputType | null
    _sum: SalesOrderSumAggregateOutputType | null
    _min: SalesOrderMinAggregateOutputType | null
    _max: SalesOrderMaxAggregateOutputType | null
  }

  type GetSalesOrderGroupByPayload<T extends SalesOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SalesOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesOrderGroupByOutputType[P]>
            : GetScalarType<T[P], SalesOrderGroupByOutputType[P]>
        }
      >
    >


  export type salesOrderSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesOrderNo?: boolean
    customerId?: boolean
    userId?: boolean
    remarks?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | salesOrder$ordersArgs<ExtArgs>
    customerName?: boolean | customerArgs<ExtArgs>
    user?: boolean | userArgs<ExtArgs>
    _count?: boolean | SalesOrderCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrder"]>

  export type salesOrderSelectScalar = {
    id?: boolean
    salesOrderNo?: boolean
    customerId?: boolean
    userId?: boolean
    remarks?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type salesOrderInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    orders?: boolean | salesOrder$ordersArgs<ExtArgs>
    customerName?: boolean | customerArgs<ExtArgs>
    user?: boolean | userArgs<ExtArgs>
    _count?: boolean | SalesOrderCountOutputTypeArgs<ExtArgs>
  }


  type salesOrderGetPayload<S extends boolean | null | undefined | salesOrderArgs> = $Types.GetResult<salesOrderPayload, S>

  type salesOrderCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<salesOrderFindManyArgs, 'select' | 'include'> & {
      select?: SalesOrderCountAggregateInputType | true
    }

  export interface salesOrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['salesOrder'], meta: { name: 'salesOrder' } }
    /**
     * Find zero or one SalesOrder that matches the filter.
     * @param {salesOrderFindUniqueArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends salesOrderFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, salesOrderFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'salesOrder'> extends True ? Prisma__salesOrderClient<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__salesOrderClient<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one SalesOrder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {salesOrderFindUniqueOrThrowArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends salesOrderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, salesOrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__salesOrderClient<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first SalesOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesOrderFindFirstArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends salesOrderFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, salesOrderFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'salesOrder'> extends True ? Prisma__salesOrderClient<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__salesOrderClient<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first SalesOrder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesOrderFindFirstOrThrowArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends salesOrderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, salesOrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__salesOrderClient<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more SalesOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesOrders
     * const salesOrders = await prisma.salesOrder.findMany()
     * 
     * // Get first 10 SalesOrders
     * const salesOrders = await prisma.salesOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesOrderWithIdOnly = await prisma.salesOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends salesOrderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salesOrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a SalesOrder.
     * @param {salesOrderCreateArgs} args - Arguments to create a SalesOrder.
     * @example
     * // Create one SalesOrder
     * const SalesOrder = await prisma.salesOrder.create({
     *   data: {
     *     // ... data to create a SalesOrder
     *   }
     * })
     * 
    **/
    create<T extends salesOrderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, salesOrderCreateArgs<ExtArgs>>
    ): Prisma__salesOrderClient<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many SalesOrders.
     *     @param {salesOrderCreateManyArgs} args - Arguments to create many SalesOrders.
     *     @example
     *     // Create many SalesOrders
     *     const salesOrder = await prisma.salesOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends salesOrderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salesOrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SalesOrder.
     * @param {salesOrderDeleteArgs} args - Arguments to delete one SalesOrder.
     * @example
     * // Delete one SalesOrder
     * const SalesOrder = await prisma.salesOrder.delete({
     *   where: {
     *     // ... filter to delete one SalesOrder
     *   }
     * })
     * 
    **/
    delete<T extends salesOrderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, salesOrderDeleteArgs<ExtArgs>>
    ): Prisma__salesOrderClient<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one SalesOrder.
     * @param {salesOrderUpdateArgs} args - Arguments to update one SalesOrder.
     * @example
     * // Update one SalesOrder
     * const salesOrder = await prisma.salesOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends salesOrderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, salesOrderUpdateArgs<ExtArgs>>
    ): Prisma__salesOrderClient<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more SalesOrders.
     * @param {salesOrderDeleteManyArgs} args - Arguments to filter SalesOrders to delete.
     * @example
     * // Delete a few SalesOrders
     * const { count } = await prisma.salesOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends salesOrderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salesOrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesOrders
     * const salesOrder = await prisma.salesOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends salesOrderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, salesOrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesOrder.
     * @param {salesOrderUpsertArgs} args - Arguments to update or create a SalesOrder.
     * @example
     * // Update or create a SalesOrder
     * const salesOrder = await prisma.salesOrder.upsert({
     *   create: {
     *     // ... data to create a SalesOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesOrder we want to update
     *   }
     * })
    **/
    upsert<T extends salesOrderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, salesOrderUpsertArgs<ExtArgs>>
    ): Prisma__salesOrderClient<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of SalesOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesOrderCountArgs} args - Arguments to filter SalesOrders to count.
     * @example
     * // Count the number of SalesOrders
     * const count = await prisma.salesOrder.count({
     *   where: {
     *     // ... the filter for the SalesOrders we want to count
     *   }
     * })
    **/
    count<T extends salesOrderCountArgs>(
      args?: Subset<T, salesOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesOrderAggregateArgs>(args: Subset<T, SalesOrderAggregateArgs>): Prisma.PrismaPromise<GetSalesOrderAggregateType<T>>

    /**
     * Group by SalesOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesOrderGroupByArgs['orderBy'] }
        : { orderBy?: SalesOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for salesOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__salesOrderClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    orders<T extends salesOrder$ordersArgs<ExtArgs> = {}>(args?: Subset<T, salesOrder$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    customerName<T extends customerArgs<ExtArgs> = {}>(args?: Subset<T, customerArgs<ExtArgs>>): Prisma__customerClient<$Types.GetResult<customerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * salesOrder base type for findUnique actions
   */
  export type salesOrderFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesOrder
     */
    select?: salesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesOrderInclude<ExtArgs> | null
    /**
     * Filter, which salesOrder to fetch.
     */
    where: salesOrderWhereUniqueInput
  }

  /**
   * salesOrder findUnique
   */
  export interface salesOrderFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends salesOrderFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * salesOrder findUniqueOrThrow
   */
  export type salesOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesOrder
     */
    select?: salesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesOrderInclude<ExtArgs> | null
    /**
     * Filter, which salesOrder to fetch.
     */
    where: salesOrderWhereUniqueInput
  }


  /**
   * salesOrder base type for findFirst actions
   */
  export type salesOrderFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesOrder
     */
    select?: salesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesOrderInclude<ExtArgs> | null
    /**
     * Filter, which salesOrder to fetch.
     */
    where?: salesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salesOrders to fetch.
     */
    orderBy?: Enumerable<salesOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for salesOrders.
     */
    cursor?: salesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of salesOrders.
     */
    distinct?: Enumerable<SalesOrderScalarFieldEnum>
  }

  /**
   * salesOrder findFirst
   */
  export interface salesOrderFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends salesOrderFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * salesOrder findFirstOrThrow
   */
  export type salesOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesOrder
     */
    select?: salesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesOrderInclude<ExtArgs> | null
    /**
     * Filter, which salesOrder to fetch.
     */
    where?: salesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salesOrders to fetch.
     */
    orderBy?: Enumerable<salesOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for salesOrders.
     */
    cursor?: salesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of salesOrders.
     */
    distinct?: Enumerable<SalesOrderScalarFieldEnum>
  }


  /**
   * salesOrder findMany
   */
  export type salesOrderFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesOrder
     */
    select?: salesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesOrderInclude<ExtArgs> | null
    /**
     * Filter, which salesOrders to fetch.
     */
    where?: salesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salesOrders to fetch.
     */
    orderBy?: Enumerable<salesOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing salesOrders.
     */
    cursor?: salesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salesOrders.
     */
    skip?: number
    distinct?: Enumerable<SalesOrderScalarFieldEnum>
  }


  /**
   * salesOrder create
   */
  export type salesOrderCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesOrder
     */
    select?: salesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a salesOrder.
     */
    data: XOR<salesOrderCreateInput, salesOrderUncheckedCreateInput>
  }


  /**
   * salesOrder createMany
   */
  export type salesOrderCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many salesOrders.
     */
    data: Enumerable<salesOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * salesOrder update
   */
  export type salesOrderUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesOrder
     */
    select?: salesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a salesOrder.
     */
    data: XOR<salesOrderUpdateInput, salesOrderUncheckedUpdateInput>
    /**
     * Choose, which salesOrder to update.
     */
    where: salesOrderWhereUniqueInput
  }


  /**
   * salesOrder updateMany
   */
  export type salesOrderUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update salesOrders.
     */
    data: XOR<salesOrderUpdateManyMutationInput, salesOrderUncheckedUpdateManyInput>
    /**
     * Filter which salesOrders to update
     */
    where?: salesOrderWhereInput
  }


  /**
   * salesOrder upsert
   */
  export type salesOrderUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesOrder
     */
    select?: salesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the salesOrder to update in case it exists.
     */
    where: salesOrderWhereUniqueInput
    /**
     * In case the salesOrder found by the `where` argument doesn't exist, create a new salesOrder with this data.
     */
    create: XOR<salesOrderCreateInput, salesOrderUncheckedCreateInput>
    /**
     * In case the salesOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<salesOrderUpdateInput, salesOrderUncheckedUpdateInput>
  }


  /**
   * salesOrder delete
   */
  export type salesOrderDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesOrder
     */
    select?: salesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesOrderInclude<ExtArgs> | null
    /**
     * Filter which salesOrder to delete.
     */
    where: salesOrderWhereUniqueInput
  }


  /**
   * salesOrder deleteMany
   */
  export type salesOrderDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which salesOrders to delete
     */
    where?: salesOrderWhereInput
  }


  /**
   * salesOrder.orders
   */
  export type salesOrder$ordersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesItems
     */
    select?: salesItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesItemsInclude<ExtArgs> | null
    where?: salesItemsWhereInput
    orderBy?: Enumerable<salesItemsOrderByWithRelationInput>
    cursor?: salesItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesItemsScalarFieldEnum>
  }


  /**
   * salesOrder without action
   */
  export type salesOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesOrder
     */
    select?: salesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesOrderInclude<ExtArgs> | null
  }



  /**
   * Model salesItems
   */


  export type AggregateSalesItems = {
    _count: SalesItemsCountAggregateOutputType | null
    _avg: SalesItemsAvgAggregateOutputType | null
    _sum: SalesItemsSumAggregateOutputType | null
    _min: SalesItemsMinAggregateOutputType | null
    _max: SalesItemsMaxAggregateOutputType | null
  }

  export type SalesItemsAvgAggregateOutputType = {
    id: number | null
    salesOrderId: number | null
    productId: number | null
    quantity: number | null
    sellingPrice: number | null
    total: number | null
  }

  export type SalesItemsSumAggregateOutputType = {
    id: number | null
    salesOrderId: number | null
    productId: number | null
    quantity: number | null
    sellingPrice: number | null
    total: number | null
  }

  export type SalesItemsMinAggregateOutputType = {
    id: number | null
    salesOrderId: number | null
    productId: number | null
    quantity: number | null
    sellingPrice: number | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesItemsMaxAggregateOutputType = {
    id: number | null
    salesOrderId: number | null
    productId: number | null
    quantity: number | null
    sellingPrice: number | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesItemsCountAggregateOutputType = {
    id: number
    salesOrderId: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesItemsAvgAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    quantity?: true
    sellingPrice?: true
    total?: true
  }

  export type SalesItemsSumAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    quantity?: true
    sellingPrice?: true
    total?: true
  }

  export type SalesItemsMinAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    quantity?: true
    sellingPrice?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesItemsMaxAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    quantity?: true
    sellingPrice?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesItemsCountAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    quantity?: true
    sellingPrice?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesItemsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which salesItems to aggregate.
     */
    where?: salesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salesItems to fetch.
     */
    orderBy?: Enumerable<salesItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: salesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned salesItems
    **/
    _count?: true | SalesItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesItemsMaxAggregateInputType
  }

  export type GetSalesItemsAggregateType<T extends SalesItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesItems[P]>
      : GetScalarType<T[P], AggregateSalesItems[P]>
  }




  export type SalesItemsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: salesItemsWhereInput
    orderBy?: Enumerable<salesItemsOrderByWithAggregationInput>
    by: SalesItemsScalarFieldEnum[]
    having?: salesItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesItemsCountAggregateInputType | true
    _avg?: SalesItemsAvgAggregateInputType
    _sum?: SalesItemsSumAggregateInputType
    _min?: SalesItemsMinAggregateInputType
    _max?: SalesItemsMaxAggregateInputType
  }


  export type SalesItemsGroupByOutputType = {
    id: number
    salesOrderId: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt: Date
    updatedAt: Date
    _count: SalesItemsCountAggregateOutputType | null
    _avg: SalesItemsAvgAggregateOutputType | null
    _sum: SalesItemsSumAggregateOutputType | null
    _min: SalesItemsMinAggregateOutputType | null
    _max: SalesItemsMaxAggregateOutputType | null
  }

  type GetSalesItemsGroupByPayload<T extends SalesItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SalesItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesItemsGroupByOutputType[P]>
            : GetScalarType<T[P], SalesItemsGroupByOutputType[P]>
        }
      >
    >


  export type salesItemsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    sellingPrice?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salesOrder?: boolean | salesOrderArgs<ExtArgs>
    product?: boolean | productArgs<ExtArgs>
  }, ExtArgs["result"]["salesItems"]>

  export type salesItemsSelectScalar = {
    id?: boolean
    salesOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    sellingPrice?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type salesItemsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    salesOrder?: boolean | salesOrderArgs<ExtArgs>
    product?: boolean | productArgs<ExtArgs>
  }


  type salesItemsGetPayload<S extends boolean | null | undefined | salesItemsArgs> = $Types.GetResult<salesItemsPayload, S>

  type salesItemsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<salesItemsFindManyArgs, 'select' | 'include'> & {
      select?: SalesItemsCountAggregateInputType | true
    }

  export interface salesItemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['salesItems'], meta: { name: 'salesItems' } }
    /**
     * Find zero or one SalesItems that matches the filter.
     * @param {salesItemsFindUniqueArgs} args - Arguments to find a SalesItems
     * @example
     * // Get one SalesItems
     * const salesItems = await prisma.salesItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends salesItemsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, salesItemsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'salesItems'> extends True ? Prisma__salesItemsClient<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__salesItemsClient<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one SalesItems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {salesItemsFindUniqueOrThrowArgs} args - Arguments to find a SalesItems
     * @example
     * // Get one SalesItems
     * const salesItems = await prisma.salesItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends salesItemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, salesItemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__salesItemsClient<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first SalesItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesItemsFindFirstArgs} args - Arguments to find a SalesItems
     * @example
     * // Get one SalesItems
     * const salesItems = await prisma.salesItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends salesItemsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, salesItemsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'salesItems'> extends True ? Prisma__salesItemsClient<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__salesItemsClient<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first SalesItems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesItemsFindFirstOrThrowArgs} args - Arguments to find a SalesItems
     * @example
     * // Get one SalesItems
     * const salesItems = await prisma.salesItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends salesItemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, salesItemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__salesItemsClient<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more SalesItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesItems
     * const salesItems = await prisma.salesItems.findMany()
     * 
     * // Get first 10 SalesItems
     * const salesItems = await prisma.salesItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesItemsWithIdOnly = await prisma.salesItems.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends salesItemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salesItemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a SalesItems.
     * @param {salesItemsCreateArgs} args - Arguments to create a SalesItems.
     * @example
     * // Create one SalesItems
     * const SalesItems = await prisma.salesItems.create({
     *   data: {
     *     // ... data to create a SalesItems
     *   }
     * })
     * 
    **/
    create<T extends salesItemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, salesItemsCreateArgs<ExtArgs>>
    ): Prisma__salesItemsClient<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many SalesItems.
     *     @param {salesItemsCreateManyArgs} args - Arguments to create many SalesItems.
     *     @example
     *     // Create many SalesItems
     *     const salesItems = await prisma.salesItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends salesItemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salesItemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SalesItems.
     * @param {salesItemsDeleteArgs} args - Arguments to delete one SalesItems.
     * @example
     * // Delete one SalesItems
     * const SalesItems = await prisma.salesItems.delete({
     *   where: {
     *     // ... filter to delete one SalesItems
     *   }
     * })
     * 
    **/
    delete<T extends salesItemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, salesItemsDeleteArgs<ExtArgs>>
    ): Prisma__salesItemsClient<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one SalesItems.
     * @param {salesItemsUpdateArgs} args - Arguments to update one SalesItems.
     * @example
     * // Update one SalesItems
     * const salesItems = await prisma.salesItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends salesItemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, salesItemsUpdateArgs<ExtArgs>>
    ): Prisma__salesItemsClient<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more SalesItems.
     * @param {salesItemsDeleteManyArgs} args - Arguments to filter SalesItems to delete.
     * @example
     * // Delete a few SalesItems
     * const { count } = await prisma.salesItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends salesItemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, salesItemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesItems
     * const salesItems = await prisma.salesItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends salesItemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, salesItemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesItems.
     * @param {salesItemsUpsertArgs} args - Arguments to update or create a SalesItems.
     * @example
     * // Update or create a SalesItems
     * const salesItems = await prisma.salesItems.upsert({
     *   create: {
     *     // ... data to create a SalesItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesItems we want to update
     *   }
     * })
    **/
    upsert<T extends salesItemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, salesItemsUpsertArgs<ExtArgs>>
    ): Prisma__salesItemsClient<$Types.GetResult<salesItemsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of SalesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salesItemsCountArgs} args - Arguments to filter SalesItems to count.
     * @example
     * // Count the number of SalesItems
     * const count = await prisma.salesItems.count({
     *   where: {
     *     // ... the filter for the SalesItems we want to count
     *   }
     * })
    **/
    count<T extends salesItemsCountArgs>(
      args?: Subset<T, salesItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesItemsAggregateArgs>(args: Subset<T, SalesItemsAggregateArgs>): Prisma.PrismaPromise<GetSalesItemsAggregateType<T>>

    /**
     * Group by SalesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesItemsGroupByArgs['orderBy'] }
        : { orderBy?: SalesItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for salesItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__salesItemsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    salesOrder<T extends salesOrderArgs<ExtArgs> = {}>(args?: Subset<T, salesOrderArgs<ExtArgs>>): Prisma__salesOrderClient<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    product<T extends productArgs<ExtArgs> = {}>(args?: Subset<T, productArgs<ExtArgs>>): Prisma__productClient<$Types.GetResult<productPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * salesItems base type for findUnique actions
   */
  export type salesItemsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesItems
     */
    select?: salesItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesItemsInclude<ExtArgs> | null
    /**
     * Filter, which salesItems to fetch.
     */
    where: salesItemsWhereUniqueInput
  }

  /**
   * salesItems findUnique
   */
  export interface salesItemsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends salesItemsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * salesItems findUniqueOrThrow
   */
  export type salesItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesItems
     */
    select?: salesItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesItemsInclude<ExtArgs> | null
    /**
     * Filter, which salesItems to fetch.
     */
    where: salesItemsWhereUniqueInput
  }


  /**
   * salesItems base type for findFirst actions
   */
  export type salesItemsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesItems
     */
    select?: salesItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesItemsInclude<ExtArgs> | null
    /**
     * Filter, which salesItems to fetch.
     */
    where?: salesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salesItems to fetch.
     */
    orderBy?: Enumerable<salesItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for salesItems.
     */
    cursor?: salesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of salesItems.
     */
    distinct?: Enumerable<SalesItemsScalarFieldEnum>
  }

  /**
   * salesItems findFirst
   */
  export interface salesItemsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends salesItemsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * salesItems findFirstOrThrow
   */
  export type salesItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesItems
     */
    select?: salesItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesItemsInclude<ExtArgs> | null
    /**
     * Filter, which salesItems to fetch.
     */
    where?: salesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salesItems to fetch.
     */
    orderBy?: Enumerable<salesItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for salesItems.
     */
    cursor?: salesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of salesItems.
     */
    distinct?: Enumerable<SalesItemsScalarFieldEnum>
  }


  /**
   * salesItems findMany
   */
  export type salesItemsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesItems
     */
    select?: salesItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesItemsInclude<ExtArgs> | null
    /**
     * Filter, which salesItems to fetch.
     */
    where?: salesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salesItems to fetch.
     */
    orderBy?: Enumerable<salesItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing salesItems.
     */
    cursor?: salesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salesItems.
     */
    skip?: number
    distinct?: Enumerable<SalesItemsScalarFieldEnum>
  }


  /**
   * salesItems create
   */
  export type salesItemsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesItems
     */
    select?: salesItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a salesItems.
     */
    data: XOR<salesItemsCreateInput, salesItemsUncheckedCreateInput>
  }


  /**
   * salesItems createMany
   */
  export type salesItemsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many salesItems.
     */
    data: Enumerable<salesItemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * salesItems update
   */
  export type salesItemsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesItems
     */
    select?: salesItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a salesItems.
     */
    data: XOR<salesItemsUpdateInput, salesItemsUncheckedUpdateInput>
    /**
     * Choose, which salesItems to update.
     */
    where: salesItemsWhereUniqueInput
  }


  /**
   * salesItems updateMany
   */
  export type salesItemsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update salesItems.
     */
    data: XOR<salesItemsUpdateManyMutationInput, salesItemsUncheckedUpdateManyInput>
    /**
     * Filter which salesItems to update
     */
    where?: salesItemsWhereInput
  }


  /**
   * salesItems upsert
   */
  export type salesItemsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesItems
     */
    select?: salesItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the salesItems to update in case it exists.
     */
    where: salesItemsWhereUniqueInput
    /**
     * In case the salesItems found by the `where` argument doesn't exist, create a new salesItems with this data.
     */
    create: XOR<salesItemsCreateInput, salesItemsUncheckedCreateInput>
    /**
     * In case the salesItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<salesItemsUpdateInput, salesItemsUncheckedUpdateInput>
  }


  /**
   * salesItems delete
   */
  export type salesItemsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesItems
     */
    select?: salesItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesItemsInclude<ExtArgs> | null
    /**
     * Filter which salesItems to delete.
     */
    where: salesItemsWhereUniqueInput
  }


  /**
   * salesItems deleteMany
   */
  export type salesItemsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which salesItems to delete
     */
    where?: salesItemsWhereInput
  }


  /**
   * salesItems without action
   */
  export type salesItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesItems
     */
    select?: salesItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesItemsInclude<ExtArgs> | null
  }



  /**
   * Model Vendor
   */


  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    id: number | null
  }

  export type VendorSumAggregateOutputType = {
    id: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    id?: true
  }

  export type VendorSumAggregateInputType = {
    id?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: Enumerable<VendorOrderByWithAggregationInput>
    by: VendorScalarFieldEnum[]
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }


  export type VendorGroupByOutputType = {
    id: number
    name: string
    address: string | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | Vendor$purchaseOrderArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | Vendor$purchaseOrderArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeArgs<ExtArgs>
  }


  type VendorGetPayload<S extends boolean | null | undefined | VendorArgs> = $Types.GetResult<VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<VendorFindManyArgs, 'select' | 'include'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VendorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vendor'> extends True ? Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Vendor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VendorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vendor'> extends True ? Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Vendor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VendorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<VendorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
    **/
    create<T extends VendorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VendorCreateArgs<ExtArgs>>
    ): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Vendors.
     *     @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     *     @example
     *     // Create many Vendors
     *     const vendor = await prisma.vendor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VendorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
    **/
    delete<T extends VendorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>
    ): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VendorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>
    ): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VendorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VendorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
    **/
    upsert<T extends VendorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>
    ): Prisma__VendorClient<$Types.GetResult<VendorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    purchaseOrder<T extends Vendor$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$purchaseOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<purchaseOrderPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Vendor base type for findUnique actions
   */
  export type VendorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUnique
   */
  export interface VendorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends VendorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor base type for findFirst actions
   */
  export type VendorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: Enumerable<VendorScalarFieldEnum>
  }

  /**
   * Vendor findFirst
   */
  export interface VendorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends VendorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: Enumerable<VendorScalarFieldEnum>
  }


  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: Enumerable<VendorScalarFieldEnum>
  }


  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }


  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: Enumerable<VendorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
  }


  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }


  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
  }


  /**
   * Vendor.purchaseOrder
   */
  export type Vendor$purchaseOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchaseOrder
     */
    select?: purchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: purchaseOrderInclude<ExtArgs> | null
    where?: purchaseOrderWhereInput
    orderBy?: Enumerable<purchaseOrderOrderByWithRelationInput>
    cursor?: purchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PurchaseOrderScalarFieldEnum>
  }


  /**
   * Vendor without action
   */
  export type VendorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude<ExtArgs> | null
  }



  /**
   * Model customer
   */


  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer to aggregate.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: Enumerable<customerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
    orderBy?: Enumerable<customerOrderByWithAggregationInput>
    by: CustomerScalarFieldEnum[]
    having?: customerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }


  export type CustomerGroupByOutputType = {
    id: number
    name: string
    address: string | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type customerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salesOrder?: boolean | customer$salesOrderArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type customerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    salesOrder?: boolean | customer$salesOrderArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeArgs<ExtArgs>
  }


  type customerGetPayload<S extends boolean | null | undefined | customerArgs> = $Types.GetResult<customerPayload, S>

  type customerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<customerFindManyArgs, 'select' | 'include'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface customerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer'], meta: { name: 'customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {customerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends customerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, customerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'customer'> extends True ? Prisma__customerClient<$Types.GetResult<customerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__customerClient<$Types.GetResult<customerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {customerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends customerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__customerClient<$Types.GetResult<customerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends customerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, customerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'customer'> extends True ? Prisma__customerClient<$Types.GetResult<customerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__customerClient<$Types.GetResult<customerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends customerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, customerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__customerClient<$Types.GetResult<customerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends customerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<customerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Customer.
     * @param {customerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends customerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, customerCreateArgs<ExtArgs>>
    ): Prisma__customerClient<$Types.GetResult<customerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Customers.
     *     @param {customerCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customer = await prisma.customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends customerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {customerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends customerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, customerDeleteArgs<ExtArgs>>
    ): Prisma__customerClient<$Types.GetResult<customerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {customerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends customerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, customerUpdateArgs<ExtArgs>>
    ): Prisma__customerClient<$Types.GetResult<customerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {customerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends customerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, customerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends customerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, customerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {customerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends customerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, customerUpsertArgs<ExtArgs>>
    ): Prisma__customerClient<$Types.GetResult<customerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customerCountArgs>(
      args?: Subset<T, customerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__customerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    salesOrder<T extends customer$salesOrderArgs<ExtArgs> = {}>(args?: Subset<T, customer$salesOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<salesOrderPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * customer base type for findUnique actions
   */
  export type customerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findUnique
   */
  export interface customerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends customerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * customer findUniqueOrThrow
   */
  export type customerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }


  /**
   * customer base type for findFirst actions
   */
  export type customerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: Enumerable<customerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }

  /**
   * customer findFirst
   */
  export interface customerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends customerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * customer findFirstOrThrow
   */
  export type customerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: Enumerable<customerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * customer findMany
   */
  export type customerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: Enumerable<customerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * customer create
   */
  export type customerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to create a customer.
     */
    data: XOR<customerCreateInput, customerUncheckedCreateInput>
  }


  /**
   * customer createMany
   */
  export type customerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: Enumerable<customerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * customer update
   */
  export type customerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to update a customer.
     */
    data: XOR<customerUpdateInput, customerUncheckedUpdateInput>
    /**
     * Choose, which customer to update.
     */
    where: customerWhereUniqueInput
  }


  /**
   * customer updateMany
   */
  export type customerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
  }


  /**
   * customer upsert
   */
  export type customerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The filter to search for the customer to update in case it exists.
     */
    where: customerWhereUniqueInput
    /**
     * In case the customer found by the `where` argument doesn't exist, create a new customer with this data.
     */
    create: XOR<customerCreateInput, customerUncheckedCreateInput>
    /**
     * In case the customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerUpdateInput, customerUncheckedUpdateInput>
  }


  /**
   * customer delete
   */
  export type customerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter which customer to delete.
     */
    where: customerWhereUniqueInput
  }


  /**
   * customer deleteMany
   */
  export type customerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customerWhereInput
  }


  /**
   * customer.salesOrder
   */
  export type customer$salesOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salesOrder
     */
    select?: salesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: salesOrderInclude<ExtArgs> | null
    where?: salesOrderWhereInput
    orderBy?: Enumerable<salesOrderOrderByWithRelationInput>
    cursor?: salesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesOrderScalarFieldEnum>
  }


  /**
   * customer without action
   */
  export type customerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: customerInclude<ExtArgs> | null
  }



  /**
   * Model userTokens
   */


  export type AggregateUserTokens = {
    _count: UserTokensCountAggregateOutputType | null
    _avg: UserTokensAvgAggregateOutputType | null
    _sum: UserTokensSumAggregateOutputType | null
    _min: UserTokensMinAggregateOutputType | null
    _max: UserTokensMaxAggregateOutputType | null
  }

  export type UserTokensAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserTokensSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserTokensMinAggregateOutputType = {
    id: number | null
    userId: number | null
    expiry: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTokensMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    expiry: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTokensCountAggregateOutputType = {
    id: number
    userId: number
    expiry: number
    token: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserTokensAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserTokensSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserTokensMinAggregateInputType = {
    id?: true
    userId?: true
    expiry?: true
    token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTokensMaxAggregateInputType = {
    id?: true
    userId?: true
    expiry?: true
    token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTokensCountAggregateInputType = {
    id?: true
    userId?: true
    expiry?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserTokensAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userTokens to aggregate.
     */
    where?: userTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userTokens to fetch.
     */
    orderBy?: Enumerable<userTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userTokens
    **/
    _count?: true | UserTokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTokensMaxAggregateInputType
  }

  export type GetUserTokensAggregateType<T extends UserTokensAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTokens[P]>
      : GetScalarType<T[P], AggregateUserTokens[P]>
  }




  export type UserTokensGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userTokensWhereInput
    orderBy?: Enumerable<userTokensOrderByWithAggregationInput>
    by: UserTokensScalarFieldEnum[]
    having?: userTokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTokensCountAggregateInputType | true
    _avg?: UserTokensAvgAggregateInputType
    _sum?: UserTokensSumAggregateInputType
    _min?: UserTokensMinAggregateInputType
    _max?: UserTokensMaxAggregateInputType
  }


  export type UserTokensGroupByOutputType = {
    id: number
    userId: number
    expiry: Date
    token: string
    createdAt: Date
    updatedAt: Date
    _count: UserTokensCountAggregateOutputType | null
    _avg: UserTokensAvgAggregateOutputType | null
    _sum: UserTokensSumAggregateOutputType | null
    _min: UserTokensMinAggregateOutputType | null
    _max: UserTokensMaxAggregateOutputType | null
  }

  type GetUserTokensGroupByPayload<T extends UserTokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserTokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTokensGroupByOutputType[P]>
            : GetScalarType<T[P], UserTokensGroupByOutputType[P]>
        }
      >
    >


  export type userTokensSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiry?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["userTokens"]>

  export type userTokensSelectScalar = {
    id?: boolean
    userId?: boolean
    expiry?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userTokensInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
  }


  type userTokensGetPayload<S extends boolean | null | undefined | userTokensArgs> = $Types.GetResult<userTokensPayload, S>

  type userTokensCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userTokensFindManyArgs, 'select' | 'include'> & {
      select?: UserTokensCountAggregateInputType | true
    }

  export interface userTokensDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userTokens'], meta: { name: 'userTokens' } }
    /**
     * Find zero or one UserTokens that matches the filter.
     * @param {userTokensFindUniqueArgs} args - Arguments to find a UserTokens
     * @example
     * // Get one UserTokens
     * const userTokens = await prisma.userTokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userTokensFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userTokensFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'userTokens'> extends True ? Prisma__userTokensClient<$Types.GetResult<userTokensPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__userTokensClient<$Types.GetResult<userTokensPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserTokens that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userTokensFindUniqueOrThrowArgs} args - Arguments to find a UserTokens
     * @example
     * // Get one UserTokens
     * const userTokens = await prisma.userTokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userTokensFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userTokensFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userTokensClient<$Types.GetResult<userTokensPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTokensFindFirstArgs} args - Arguments to find a UserTokens
     * @example
     * // Get one UserTokens
     * const userTokens = await prisma.userTokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userTokensFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userTokensFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'userTokens'> extends True ? Prisma__userTokensClient<$Types.GetResult<userTokensPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__userTokensClient<$Types.GetResult<userTokensPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserTokens that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTokensFindFirstOrThrowArgs} args - Arguments to find a UserTokens
     * @example
     * // Get one UserTokens
     * const userTokens = await prisma.userTokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userTokensFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userTokensFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userTokensClient<$Types.GetResult<userTokensPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTokensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTokens
     * const userTokens = await prisma.userTokens.findMany()
     * 
     * // Get first 10 UserTokens
     * const userTokens = await prisma.userTokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTokensWithIdOnly = await prisma.userTokens.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userTokensFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userTokensFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<userTokensPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserTokens.
     * @param {userTokensCreateArgs} args - Arguments to create a UserTokens.
     * @example
     * // Create one UserTokens
     * const UserTokens = await prisma.userTokens.create({
     *   data: {
     *     // ... data to create a UserTokens
     *   }
     * })
     * 
    **/
    create<T extends userTokensCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userTokensCreateArgs<ExtArgs>>
    ): Prisma__userTokensClient<$Types.GetResult<userTokensPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserTokens.
     *     @param {userTokensCreateManyArgs} args - Arguments to create many UserTokens.
     *     @example
     *     // Create many UserTokens
     *     const userTokens = await prisma.userTokens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userTokensCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userTokensCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserTokens.
     * @param {userTokensDeleteArgs} args - Arguments to delete one UserTokens.
     * @example
     * // Delete one UserTokens
     * const UserTokens = await prisma.userTokens.delete({
     *   where: {
     *     // ... filter to delete one UserTokens
     *   }
     * })
     * 
    **/
    delete<T extends userTokensDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userTokensDeleteArgs<ExtArgs>>
    ): Prisma__userTokensClient<$Types.GetResult<userTokensPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserTokens.
     * @param {userTokensUpdateArgs} args - Arguments to update one UserTokens.
     * @example
     * // Update one UserTokens
     * const userTokens = await prisma.userTokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userTokensUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userTokensUpdateArgs<ExtArgs>>
    ): Prisma__userTokensClient<$Types.GetResult<userTokensPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserTokens.
     * @param {userTokensDeleteManyArgs} args - Arguments to filter UserTokens to delete.
     * @example
     * // Delete a few UserTokens
     * const { count } = await prisma.userTokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userTokensDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userTokensDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTokens
     * const userTokens = await prisma.userTokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userTokensUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userTokensUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTokens.
     * @param {userTokensUpsertArgs} args - Arguments to update or create a UserTokens.
     * @example
     * // Update or create a UserTokens
     * const userTokens = await prisma.userTokens.upsert({
     *   create: {
     *     // ... data to create a UserTokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTokens we want to update
     *   }
     * })
    **/
    upsert<T extends userTokensUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userTokensUpsertArgs<ExtArgs>>
    ): Prisma__userTokensClient<$Types.GetResult<userTokensPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTokensCountArgs} args - Arguments to filter UserTokens to count.
     * @example
     * // Count the number of UserTokens
     * const count = await prisma.userTokens.count({
     *   where: {
     *     // ... the filter for the UserTokens we want to count
     *   }
     * })
    **/
    count<T extends userTokensCountArgs>(
      args?: Subset<T, userTokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTokensAggregateArgs>(args: Subset<T, UserTokensAggregateArgs>): Prisma.PrismaPromise<GetUserTokensAggregateType<T>>

    /**
     * Group by UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTokensGroupByArgs['orderBy'] }
        : { orderBy?: UserTokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for userTokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userTokensClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * userTokens base type for findUnique actions
   */
  export type userTokensFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userTokens
     */
    select?: userTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTokensInclude<ExtArgs> | null
    /**
     * Filter, which userTokens to fetch.
     */
    where: userTokensWhereUniqueInput
  }

  /**
   * userTokens findUnique
   */
  export interface userTokensFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends userTokensFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * userTokens findUniqueOrThrow
   */
  export type userTokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userTokens
     */
    select?: userTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTokensInclude<ExtArgs> | null
    /**
     * Filter, which userTokens to fetch.
     */
    where: userTokensWhereUniqueInput
  }


  /**
   * userTokens base type for findFirst actions
   */
  export type userTokensFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userTokens
     */
    select?: userTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTokensInclude<ExtArgs> | null
    /**
     * Filter, which userTokens to fetch.
     */
    where?: userTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userTokens to fetch.
     */
    orderBy?: Enumerable<userTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userTokens.
     */
    cursor?: userTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userTokens.
     */
    distinct?: Enumerable<UserTokensScalarFieldEnum>
  }

  /**
   * userTokens findFirst
   */
  export interface userTokensFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends userTokensFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * userTokens findFirstOrThrow
   */
  export type userTokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userTokens
     */
    select?: userTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTokensInclude<ExtArgs> | null
    /**
     * Filter, which userTokens to fetch.
     */
    where?: userTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userTokens to fetch.
     */
    orderBy?: Enumerable<userTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userTokens.
     */
    cursor?: userTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userTokens.
     */
    distinct?: Enumerable<UserTokensScalarFieldEnum>
  }


  /**
   * userTokens findMany
   */
  export type userTokensFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userTokens
     */
    select?: userTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTokensInclude<ExtArgs> | null
    /**
     * Filter, which userTokens to fetch.
     */
    where?: userTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userTokens to fetch.
     */
    orderBy?: Enumerable<userTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userTokens.
     */
    cursor?: userTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userTokens.
     */
    skip?: number
    distinct?: Enumerable<UserTokensScalarFieldEnum>
  }


  /**
   * userTokens create
   */
  export type userTokensCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userTokens
     */
    select?: userTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTokensInclude<ExtArgs> | null
    /**
     * The data needed to create a userTokens.
     */
    data: XOR<userTokensCreateInput, userTokensUncheckedCreateInput>
  }


  /**
   * userTokens createMany
   */
  export type userTokensCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userTokens.
     */
    data: Enumerable<userTokensCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * userTokens update
   */
  export type userTokensUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userTokens
     */
    select?: userTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTokensInclude<ExtArgs> | null
    /**
     * The data needed to update a userTokens.
     */
    data: XOR<userTokensUpdateInput, userTokensUncheckedUpdateInput>
    /**
     * Choose, which userTokens to update.
     */
    where: userTokensWhereUniqueInput
  }


  /**
   * userTokens updateMany
   */
  export type userTokensUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userTokens.
     */
    data: XOR<userTokensUpdateManyMutationInput, userTokensUncheckedUpdateManyInput>
    /**
     * Filter which userTokens to update
     */
    where?: userTokensWhereInput
  }


  /**
   * userTokens upsert
   */
  export type userTokensUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userTokens
     */
    select?: userTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTokensInclude<ExtArgs> | null
    /**
     * The filter to search for the userTokens to update in case it exists.
     */
    where: userTokensWhereUniqueInput
    /**
     * In case the userTokens found by the `where` argument doesn't exist, create a new userTokens with this data.
     */
    create: XOR<userTokensCreateInput, userTokensUncheckedCreateInput>
    /**
     * In case the userTokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userTokensUpdateInput, userTokensUncheckedUpdateInput>
  }


  /**
   * userTokens delete
   */
  export type userTokensDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userTokens
     */
    select?: userTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTokensInclude<ExtArgs> | null
    /**
     * Filter which userTokens to delete.
     */
    where: userTokensWhereUniqueInput
  }


  /**
   * userTokens deleteMany
   */
  export type userTokensDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userTokens to delete
     */
    where?: userTokensWhereInput
  }


  /**
   * userTokens without action
   */
  export type userTokensArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userTokens
     */
    select?: userTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTokensInclude<ExtArgs> | null
  }



  /**
   * Model roles
   */


  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: Enumerable<rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: Enumerable<rolesOrderByWithAggregationInput>
    by: RolesScalarFieldEnum[]
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }


  export type RolesGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rolePermission?: boolean | roles$rolePermissionArgs<ExtArgs>
    user?: boolean | roles$userArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type rolesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    rolePermission?: boolean | roles$rolePermissionArgs<ExtArgs>
    user?: boolean | roles$userArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeArgs<ExtArgs>
  }


  type rolesGetPayload<S extends boolean | null | undefined | rolesArgs> = $Types.GetResult<rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<rolesFindManyArgs, 'select' | 'include'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rolesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'roles'> extends True ? Prisma__rolesClient<$Types.GetResult<rolesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__rolesClient<$Types.GetResult<rolesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rolesClient<$Types.GetResult<rolesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rolesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'roles'> extends True ? Prisma__rolesClient<$Types.GetResult<rolesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__rolesClient<$Types.GetResult<rolesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rolesClient<$Types.GetResult<rolesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends rolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<rolesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
    **/
    create<T extends rolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rolesCreateArgs<ExtArgs>>
    ): Prisma__rolesClient<$Types.GetResult<rolesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Roles.
     *     @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const roles = await prisma.roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
    **/
    delete<T extends rolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>
    ): Prisma__rolesClient<$Types.GetResult<rolesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>
    ): Prisma__rolesClient<$Types.GetResult<rolesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
    **/
    upsert<T extends rolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>
    ): Prisma__rolesClient<$Types.GetResult<rolesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    rolePermission<T extends roles$rolePermissionArgs<ExtArgs> = {}>(args?: Subset<T, roles$rolePermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user<T extends roles$userArgs<ExtArgs> = {}>(args?: Subset<T, roles$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * roles base type for findUnique actions
   */
  export type rolesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUnique
   */
  export interface rolesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends rolesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }


  /**
   * roles base type for findFirst actions
   */
  export type rolesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: Enumerable<rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: Enumerable<RolesScalarFieldEnum>
  }

  /**
   * roles findFirst
   */
  export interface rolesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends rolesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: Enumerable<rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: Enumerable<RolesScalarFieldEnum>
  }


  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: Enumerable<rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: Enumerable<RolesScalarFieldEnum>
  }


  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }


  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: Enumerable<rolesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }


  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
  }


  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }


  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }


  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
  }


  /**
   * roles.rolePermission
   */
  export type roles$rolePermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesPermission
     */
    select?: rolesPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesPermissionInclude<ExtArgs> | null
    where?: rolesPermissionWhereInput
    orderBy?: Enumerable<rolesPermissionOrderByWithRelationInput>
    cursor?: rolesPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RolesPermissionScalarFieldEnum>
  }


  /**
   * roles.user
   */
  export type roles$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userRolePermission
     */
    select?: userRolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userRolePermissionInclude<ExtArgs> | null
    where?: userRolePermissionWhereInput
    orderBy?: Enumerable<userRolePermissionOrderByWithRelationInput>
    cursor?: userRolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserRolePermissionScalarFieldEnum>
  }


  /**
   * roles without action
   */
  export type rolesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesInclude<ExtArgs> | null
  }



  /**
   * Model permission
   */


  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which permission to aggregate.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: Enumerable<permissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: permissionWhereInput
    orderBy?: Enumerable<permissionOrderByWithAggregationInput>
    by: PermissionScalarFieldEnum[]
    having?: permissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }


  export type PermissionGroupByOutputType = {
    id: number
    name: string
    slug: string
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type permissionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    rolePermission?: boolean | permission$rolePermissionArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
  }

  export type permissionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    rolePermission?: boolean | permission$rolePermissionArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeArgs<ExtArgs>
  }


  type permissionGetPayload<S extends boolean | null | undefined | permissionArgs> = $Types.GetResult<permissionPayload, S>

  type permissionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<permissionFindManyArgs, 'select' | 'include'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface permissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permission'], meta: { name: 'permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {permissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends permissionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, permissionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'permission'> extends True ? Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {permissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends permissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends permissionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, permissionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'permission'> extends True ? Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends permissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends permissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Permission.
     * @param {permissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
    **/
    create<T extends permissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, permissionCreateArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Permissions.
     *     @param {permissionCreateManyArgs} args - Arguments to create many Permissions.
     *     @example
     *     // Create many Permissions
     *     const permission = await prisma.permission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends permissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {permissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
    **/
    delete<T extends permissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, permissionDeleteArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {permissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends permissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, permissionUpdateArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {permissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends permissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, permissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends permissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, permissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {permissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
    **/
    upsert<T extends permissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, permissionUpsertArgs<ExtArgs>>
    ): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionCountArgs>(
      args?: Subset<T, permissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__permissionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    rolePermission<T extends permission$rolePermissionArgs<ExtArgs> = {}>(args?: Subset<T, permission$rolePermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * permission base type for findUnique actions
   */
  export type permissionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission findUnique
   */
  export interface permissionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends permissionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * permission findUniqueOrThrow
   */
  export type permissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }


  /**
   * permission base type for findFirst actions
   */
  export type permissionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: Enumerable<permissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }

  /**
   * permission findFirst
   */
  export interface permissionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends permissionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * permission findFirstOrThrow
   */
  export type permissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: Enumerable<permissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * permission findMany
   */
  export type permissionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: Enumerable<permissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * permission create
   */
  export type permissionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The data needed to create a permission.
     */
    data: XOR<permissionCreateInput, permissionUncheckedCreateInput>
  }


  /**
   * permission createMany
   */
  export type permissionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: Enumerable<permissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * permission update
   */
  export type permissionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The data needed to update a permission.
     */
    data: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
    /**
     * Choose, which permission to update.
     */
    where: permissionWhereUniqueInput
  }


  /**
   * permission updateMany
   */
  export type permissionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionWhereInput
  }


  /**
   * permission upsert
   */
  export type permissionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The filter to search for the permission to update in case it exists.
     */
    where: permissionWhereUniqueInput
    /**
     * In case the permission found by the `where` argument doesn't exist, create a new permission with this data.
     */
    create: XOR<permissionCreateInput, permissionUncheckedCreateInput>
    /**
     * In case the permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
  }


  /**
   * permission delete
   */
  export type permissionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter which permission to delete.
     */
    where: permissionWhereUniqueInput
  }


  /**
   * permission deleteMany
   */
  export type permissionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionWhereInput
  }


  /**
   * permission.rolePermission
   */
  export type permission$rolePermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesPermission
     */
    select?: rolesPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesPermissionInclude<ExtArgs> | null
    where?: rolesPermissionWhereInput
    orderBy?: Enumerable<rolesPermissionOrderByWithRelationInput>
    cursor?: rolesPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RolesPermissionScalarFieldEnum>
  }


  /**
   * permission without action
   */
  export type permissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude<ExtArgs> | null
  }



  /**
   * Model rolesPermission
   */


  export type AggregateRolesPermission = {
    _count: RolesPermissionCountAggregateOutputType | null
    _avg: RolesPermissionAvgAggregateOutputType | null
    _sum: RolesPermissionSumAggregateOutputType | null
    _min: RolesPermissionMinAggregateOutputType | null
    _max: RolesPermissionMaxAggregateOutputType | null
  }

  export type RolesPermissionAvgAggregateOutputType = {
    id: number | null
    roleid: number | null
    permissionid: number | null
  }

  export type RolesPermissionSumAggregateOutputType = {
    id: number | null
    roleid: number | null
    permissionid: number | null
  }

  export type RolesPermissionMinAggregateOutputType = {
    id: number | null
    roleid: number | null
    permissionid: number | null
  }

  export type RolesPermissionMaxAggregateOutputType = {
    id: number | null
    roleid: number | null
    permissionid: number | null
  }

  export type RolesPermissionCountAggregateOutputType = {
    id: number
    roleid: number
    permissionid: number
    _all: number
  }


  export type RolesPermissionAvgAggregateInputType = {
    id?: true
    roleid?: true
    permissionid?: true
  }

  export type RolesPermissionSumAggregateInputType = {
    id?: true
    roleid?: true
    permissionid?: true
  }

  export type RolesPermissionMinAggregateInputType = {
    id?: true
    roleid?: true
    permissionid?: true
  }

  export type RolesPermissionMaxAggregateInputType = {
    id?: true
    roleid?: true
    permissionid?: true
  }

  export type RolesPermissionCountAggregateInputType = {
    id?: true
    roleid?: true
    permissionid?: true
    _all?: true
  }

  export type RolesPermissionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which rolesPermission to aggregate.
     */
    where?: rolesPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolesPermissions to fetch.
     */
    orderBy?: Enumerable<rolesPermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolesPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolesPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rolesPermissions
    **/
    _count?: true | RolesPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesPermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesPermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesPermissionMaxAggregateInputType
  }

  export type GetRolesPermissionAggregateType<T extends RolesPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolesPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolesPermission[P]>
      : GetScalarType<T[P], AggregateRolesPermission[P]>
  }




  export type RolesPermissionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: rolesPermissionWhereInput
    orderBy?: Enumerable<rolesPermissionOrderByWithAggregationInput>
    by: RolesPermissionScalarFieldEnum[]
    having?: rolesPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesPermissionCountAggregateInputType | true
    _avg?: RolesPermissionAvgAggregateInputType
    _sum?: RolesPermissionSumAggregateInputType
    _min?: RolesPermissionMinAggregateInputType
    _max?: RolesPermissionMaxAggregateInputType
  }


  export type RolesPermissionGroupByOutputType = {
    id: number
    roleid: number
    permissionid: number
    _count: RolesPermissionCountAggregateOutputType | null
    _avg: RolesPermissionAvgAggregateOutputType | null
    _sum: RolesPermissionSumAggregateOutputType | null
    _min: RolesPermissionMinAggregateOutputType | null
    _max: RolesPermissionMaxAggregateOutputType | null
  }

  type GetRolesPermissionGroupByPayload<T extends RolesPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RolesPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolesPermissionGroupByOutputType[P]>
        }
      >
    >


  export type rolesPermissionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleid?: boolean
    permissionid?: boolean
    role?: boolean | rolesArgs<ExtArgs>
    permission?: boolean | permissionArgs<ExtArgs>
  }, ExtArgs["result"]["rolesPermission"]>

  export type rolesPermissionSelectScalar = {
    id?: boolean
    roleid?: boolean
    permissionid?: boolean
  }

  export type rolesPermissionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    role?: boolean | rolesArgs<ExtArgs>
    permission?: boolean | permissionArgs<ExtArgs>
  }


  type rolesPermissionGetPayload<S extends boolean | null | undefined | rolesPermissionArgs> = $Types.GetResult<rolesPermissionPayload, S>

  type rolesPermissionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<rolesPermissionFindManyArgs, 'select' | 'include'> & {
      select?: RolesPermissionCountAggregateInputType | true
    }

  export interface rolesPermissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rolesPermission'], meta: { name: 'rolesPermission' } }
    /**
     * Find zero or one RolesPermission that matches the filter.
     * @param {rolesPermissionFindUniqueArgs} args - Arguments to find a RolesPermission
     * @example
     * // Get one RolesPermission
     * const rolesPermission = await prisma.rolesPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rolesPermissionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, rolesPermissionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'rolesPermission'> extends True ? Prisma__rolesPermissionClient<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__rolesPermissionClient<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one RolesPermission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rolesPermissionFindUniqueOrThrowArgs} args - Arguments to find a RolesPermission
     * @example
     * // Get one RolesPermission
     * const rolesPermission = await prisma.rolesPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rolesPermissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesPermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rolesPermissionClient<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first RolesPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesPermissionFindFirstArgs} args - Arguments to find a RolesPermission
     * @example
     * // Get one RolesPermission
     * const rolesPermission = await prisma.rolesPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rolesPermissionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, rolesPermissionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'rolesPermission'> extends True ? Prisma__rolesPermissionClient<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__rolesPermissionClient<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first RolesPermission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesPermissionFindFirstOrThrowArgs} args - Arguments to find a RolesPermission
     * @example
     * // Get one RolesPermission
     * const rolesPermission = await prisma.rolesPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rolesPermissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesPermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rolesPermissionClient<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more RolesPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesPermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolesPermissions
     * const rolesPermissions = await prisma.rolesPermission.findMany()
     * 
     * // Get first 10 RolesPermissions
     * const rolesPermissions = await prisma.rolesPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesPermissionWithIdOnly = await prisma.rolesPermission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends rolesPermissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesPermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a RolesPermission.
     * @param {rolesPermissionCreateArgs} args - Arguments to create a RolesPermission.
     * @example
     * // Create one RolesPermission
     * const RolesPermission = await prisma.rolesPermission.create({
     *   data: {
     *     // ... data to create a RolesPermission
     *   }
     * })
     * 
    **/
    create<T extends rolesPermissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rolesPermissionCreateArgs<ExtArgs>>
    ): Prisma__rolesPermissionClient<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many RolesPermissions.
     *     @param {rolesPermissionCreateManyArgs} args - Arguments to create many RolesPermissions.
     *     @example
     *     // Create many RolesPermissions
     *     const rolesPermission = await prisma.rolesPermission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rolesPermissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesPermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolesPermission.
     * @param {rolesPermissionDeleteArgs} args - Arguments to delete one RolesPermission.
     * @example
     * // Delete one RolesPermission
     * const RolesPermission = await prisma.rolesPermission.delete({
     *   where: {
     *     // ... filter to delete one RolesPermission
     *   }
     * })
     * 
    **/
    delete<T extends rolesPermissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rolesPermissionDeleteArgs<ExtArgs>>
    ): Prisma__rolesPermissionClient<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one RolesPermission.
     * @param {rolesPermissionUpdateArgs} args - Arguments to update one RolesPermission.
     * @example
     * // Update one RolesPermission
     * const rolesPermission = await prisma.rolesPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rolesPermissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rolesPermissionUpdateArgs<ExtArgs>>
    ): Prisma__rolesPermissionClient<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more RolesPermissions.
     * @param {rolesPermissionDeleteManyArgs} args - Arguments to filter RolesPermissions to delete.
     * @example
     * // Delete a few RolesPermissions
     * const { count } = await prisma.rolesPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rolesPermissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolesPermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolesPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolesPermissions
     * const rolesPermission = await prisma.rolesPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rolesPermissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rolesPermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolesPermission.
     * @param {rolesPermissionUpsertArgs} args - Arguments to update or create a RolesPermission.
     * @example
     * // Update or create a RolesPermission
     * const rolesPermission = await prisma.rolesPermission.upsert({
     *   create: {
     *     // ... data to create a RolesPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolesPermission we want to update
     *   }
     * })
    **/
    upsert<T extends rolesPermissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rolesPermissionUpsertArgs<ExtArgs>>
    ): Prisma__rolesPermissionClient<$Types.GetResult<rolesPermissionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of RolesPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesPermissionCountArgs} args - Arguments to filter RolesPermissions to count.
     * @example
     * // Count the number of RolesPermissions
     * const count = await prisma.rolesPermission.count({
     *   where: {
     *     // ... the filter for the RolesPermissions we want to count
     *   }
     * })
    **/
    count<T extends rolesPermissionCountArgs>(
      args?: Subset<T, rolesPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolesPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesPermissionAggregateArgs>(args: Subset<T, RolesPermissionAggregateArgs>): Prisma.PrismaPromise<GetRolesPermissionAggregateType<T>>

    /**
     * Group by RolesPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesPermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolesPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for rolesPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__rolesPermissionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    role<T extends rolesArgs<ExtArgs> = {}>(args?: Subset<T, rolesArgs<ExtArgs>>): Prisma__rolesClient<$Types.GetResult<rolesPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    permission<T extends permissionArgs<ExtArgs> = {}>(args?: Subset<T, permissionArgs<ExtArgs>>): Prisma__permissionClient<$Types.GetResult<permissionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * rolesPermission base type for findUnique actions
   */
  export type rolesPermissionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesPermission
     */
    select?: rolesPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesPermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolesPermission to fetch.
     */
    where: rolesPermissionWhereUniqueInput
  }

  /**
   * rolesPermission findUnique
   */
  export interface rolesPermissionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends rolesPermissionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * rolesPermission findUniqueOrThrow
   */
  export type rolesPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesPermission
     */
    select?: rolesPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesPermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolesPermission to fetch.
     */
    where: rolesPermissionWhereUniqueInput
  }


  /**
   * rolesPermission base type for findFirst actions
   */
  export type rolesPermissionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesPermission
     */
    select?: rolesPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesPermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolesPermission to fetch.
     */
    where?: rolesPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolesPermissions to fetch.
     */
    orderBy?: Enumerable<rolesPermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rolesPermissions.
     */
    cursor?: rolesPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolesPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolesPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rolesPermissions.
     */
    distinct?: Enumerable<RolesPermissionScalarFieldEnum>
  }

  /**
   * rolesPermission findFirst
   */
  export interface rolesPermissionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends rolesPermissionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * rolesPermission findFirstOrThrow
   */
  export type rolesPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesPermission
     */
    select?: rolesPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesPermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolesPermission to fetch.
     */
    where?: rolesPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolesPermissions to fetch.
     */
    orderBy?: Enumerable<rolesPermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rolesPermissions.
     */
    cursor?: rolesPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolesPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolesPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rolesPermissions.
     */
    distinct?: Enumerable<RolesPermissionScalarFieldEnum>
  }


  /**
   * rolesPermission findMany
   */
  export type rolesPermissionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesPermission
     */
    select?: rolesPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesPermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolesPermissions to fetch.
     */
    where?: rolesPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolesPermissions to fetch.
     */
    orderBy?: Enumerable<rolesPermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rolesPermissions.
     */
    cursor?: rolesPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolesPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolesPermissions.
     */
    skip?: number
    distinct?: Enumerable<RolesPermissionScalarFieldEnum>
  }


  /**
   * rolesPermission create
   */
  export type rolesPermissionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesPermission
     */
    select?: rolesPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a rolesPermission.
     */
    data: XOR<rolesPermissionCreateInput, rolesPermissionUncheckedCreateInput>
  }


  /**
   * rolesPermission createMany
   */
  export type rolesPermissionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rolesPermissions.
     */
    data: Enumerable<rolesPermissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * rolesPermission update
   */
  export type rolesPermissionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesPermission
     */
    select?: rolesPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a rolesPermission.
     */
    data: XOR<rolesPermissionUpdateInput, rolesPermissionUncheckedUpdateInput>
    /**
     * Choose, which rolesPermission to update.
     */
    where: rolesPermissionWhereUniqueInput
  }


  /**
   * rolesPermission updateMany
   */
  export type rolesPermissionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rolesPermissions.
     */
    data: XOR<rolesPermissionUpdateManyMutationInput, rolesPermissionUncheckedUpdateManyInput>
    /**
     * Filter which rolesPermissions to update
     */
    where?: rolesPermissionWhereInput
  }


  /**
   * rolesPermission upsert
   */
  export type rolesPermissionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesPermission
     */
    select?: rolesPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the rolesPermission to update in case it exists.
     */
    where: rolesPermissionWhereUniqueInput
    /**
     * In case the rolesPermission found by the `where` argument doesn't exist, create a new rolesPermission with this data.
     */
    create: XOR<rolesPermissionCreateInput, rolesPermissionUncheckedCreateInput>
    /**
     * In case the rolesPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesPermissionUpdateInput, rolesPermissionUncheckedUpdateInput>
  }


  /**
   * rolesPermission delete
   */
  export type rolesPermissionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesPermission
     */
    select?: rolesPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesPermissionInclude<ExtArgs> | null
    /**
     * Filter which rolesPermission to delete.
     */
    where: rolesPermissionWhereUniqueInput
  }


  /**
   * rolesPermission deleteMany
   */
  export type rolesPermissionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which rolesPermissions to delete
     */
    where?: rolesPermissionWhereInput
  }


  /**
   * rolesPermission without action
   */
  export type rolesPermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolesPermission
     */
    select?: rolesPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolesPermissionInclude<ExtArgs> | null
  }



  /**
   * Model userRolePermission
   */


  export type AggregateUserRolePermission = {
    _count: UserRolePermissionCountAggregateOutputType | null
    _avg: UserRolePermissionAvgAggregateOutputType | null
    _sum: UserRolePermissionSumAggregateOutputType | null
    _min: UserRolePermissionMinAggregateOutputType | null
    _max: UserRolePermissionMaxAggregateOutputType | null
  }

  export type UserRolePermissionAvgAggregateOutputType = {
    id: number | null
    userid: number | null
    roleid: number | null
  }

  export type UserRolePermissionSumAggregateOutputType = {
    id: number | null
    userid: number | null
    roleid: number | null
  }

  export type UserRolePermissionMinAggregateOutputType = {
    id: number | null
    userid: number | null
    roleid: number | null
  }

  export type UserRolePermissionMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    roleid: number | null
  }

  export type UserRolePermissionCountAggregateOutputType = {
    id: number
    userid: number
    roleid: number
    _all: number
  }


  export type UserRolePermissionAvgAggregateInputType = {
    id?: true
    userid?: true
    roleid?: true
  }

  export type UserRolePermissionSumAggregateInputType = {
    id?: true
    userid?: true
    roleid?: true
  }

  export type UserRolePermissionMinAggregateInputType = {
    id?: true
    userid?: true
    roleid?: true
  }

  export type UserRolePermissionMaxAggregateInputType = {
    id?: true
    userid?: true
    roleid?: true
  }

  export type UserRolePermissionCountAggregateInputType = {
    id?: true
    userid?: true
    roleid?: true
    _all?: true
  }

  export type UserRolePermissionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userRolePermission to aggregate.
     */
    where?: userRolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userRolePermissions to fetch.
     */
    orderBy?: Enumerable<userRolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userRolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userRolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userRolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userRolePermissions
    **/
    _count?: true | UserRolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRolePermissionMaxAggregateInputType
  }

  export type GetUserRolePermissionAggregateType<T extends UserRolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRolePermission[P]>
      : GetScalarType<T[P], AggregateUserRolePermission[P]>
  }




  export type UserRolePermissionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userRolePermissionWhereInput
    orderBy?: Enumerable<userRolePermissionOrderByWithAggregationInput>
    by: UserRolePermissionScalarFieldEnum[]
    having?: userRolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRolePermissionCountAggregateInputType | true
    _avg?: UserRolePermissionAvgAggregateInputType
    _sum?: UserRolePermissionSumAggregateInputType
    _min?: UserRolePermissionMinAggregateInputType
    _max?: UserRolePermissionMaxAggregateInputType
  }


  export type UserRolePermissionGroupByOutputType = {
    id: number
    userid: number
    roleid: number
    _count: UserRolePermissionCountAggregateOutputType | null
    _avg: UserRolePermissionAvgAggregateOutputType | null
    _sum: UserRolePermissionSumAggregateOutputType | null
    _min: UserRolePermissionMinAggregateOutputType | null
    _max: UserRolePermissionMaxAggregateOutputType | null
  }

  type GetUserRolePermissionGroupByPayload<T extends UserRolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserRolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], UserRolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type userRolePermissionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    roleid?: boolean
    user?: boolean | userArgs<ExtArgs>
    role?: boolean | rolesArgs<ExtArgs>
  }, ExtArgs["result"]["userRolePermission"]>

  export type userRolePermissionSelectScalar = {
    id?: boolean
    userid?: boolean
    roleid?: boolean
  }

  export type userRolePermissionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
    role?: boolean | rolesArgs<ExtArgs>
  }


  type userRolePermissionGetPayload<S extends boolean | null | undefined | userRolePermissionArgs> = $Types.GetResult<userRolePermissionPayload, S>

  type userRolePermissionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userRolePermissionFindManyArgs, 'select' | 'include'> & {
      select?: UserRolePermissionCountAggregateInputType | true
    }

  export interface userRolePermissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userRolePermission'], meta: { name: 'userRolePermission' } }
    /**
     * Find zero or one UserRolePermission that matches the filter.
     * @param {userRolePermissionFindUniqueArgs} args - Arguments to find a UserRolePermission
     * @example
     * // Get one UserRolePermission
     * const userRolePermission = await prisma.userRolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userRolePermissionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userRolePermissionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'userRolePermission'> extends True ? Prisma__userRolePermissionClient<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__userRolePermissionClient<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserRolePermission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userRolePermissionFindUniqueOrThrowArgs} args - Arguments to find a UserRolePermission
     * @example
     * // Get one UserRolePermission
     * const userRolePermission = await prisma.userRolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userRolePermissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userRolePermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userRolePermissionClient<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserRolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userRolePermissionFindFirstArgs} args - Arguments to find a UserRolePermission
     * @example
     * // Get one UserRolePermission
     * const userRolePermission = await prisma.userRolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userRolePermissionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userRolePermissionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'userRolePermission'> extends True ? Prisma__userRolePermissionClient<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__userRolePermissionClient<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserRolePermission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userRolePermissionFindFirstOrThrowArgs} args - Arguments to find a UserRolePermission
     * @example
     * // Get one UserRolePermission
     * const userRolePermission = await prisma.userRolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userRolePermissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userRolePermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userRolePermissionClient<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserRolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userRolePermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRolePermissions
     * const userRolePermissions = await prisma.userRolePermission.findMany()
     * 
     * // Get first 10 UserRolePermissions
     * const userRolePermissions = await prisma.userRolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRolePermissionWithIdOnly = await prisma.userRolePermission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userRolePermissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userRolePermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserRolePermission.
     * @param {userRolePermissionCreateArgs} args - Arguments to create a UserRolePermission.
     * @example
     * // Create one UserRolePermission
     * const UserRolePermission = await prisma.userRolePermission.create({
     *   data: {
     *     // ... data to create a UserRolePermission
     *   }
     * })
     * 
    **/
    create<T extends userRolePermissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userRolePermissionCreateArgs<ExtArgs>>
    ): Prisma__userRolePermissionClient<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserRolePermissions.
     *     @param {userRolePermissionCreateManyArgs} args - Arguments to create many UserRolePermissions.
     *     @example
     *     // Create many UserRolePermissions
     *     const userRolePermission = await prisma.userRolePermission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userRolePermissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userRolePermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRolePermission.
     * @param {userRolePermissionDeleteArgs} args - Arguments to delete one UserRolePermission.
     * @example
     * // Delete one UserRolePermission
     * const UserRolePermission = await prisma.userRolePermission.delete({
     *   where: {
     *     // ... filter to delete one UserRolePermission
     *   }
     * })
     * 
    **/
    delete<T extends userRolePermissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userRolePermissionDeleteArgs<ExtArgs>>
    ): Prisma__userRolePermissionClient<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserRolePermission.
     * @param {userRolePermissionUpdateArgs} args - Arguments to update one UserRolePermission.
     * @example
     * // Update one UserRolePermission
     * const userRolePermission = await prisma.userRolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userRolePermissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userRolePermissionUpdateArgs<ExtArgs>>
    ): Prisma__userRolePermissionClient<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserRolePermissions.
     * @param {userRolePermissionDeleteManyArgs} args - Arguments to filter UserRolePermissions to delete.
     * @example
     * // Delete a few UserRolePermissions
     * const { count } = await prisma.userRolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userRolePermissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userRolePermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userRolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRolePermissions
     * const userRolePermission = await prisma.userRolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userRolePermissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userRolePermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRolePermission.
     * @param {userRolePermissionUpsertArgs} args - Arguments to update or create a UserRolePermission.
     * @example
     * // Update or create a UserRolePermission
     * const userRolePermission = await prisma.userRolePermission.upsert({
     *   create: {
     *     // ... data to create a UserRolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRolePermission we want to update
     *   }
     * })
    **/
    upsert<T extends userRolePermissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userRolePermissionUpsertArgs<ExtArgs>>
    ): Prisma__userRolePermissionClient<$Types.GetResult<userRolePermissionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserRolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userRolePermissionCountArgs} args - Arguments to filter UserRolePermissions to count.
     * @example
     * // Count the number of UserRolePermissions
     * const count = await prisma.userRolePermission.count({
     *   where: {
     *     // ... the filter for the UserRolePermissions we want to count
     *   }
     * })
    **/
    count<T extends userRolePermissionCountArgs>(
      args?: Subset<T, userRolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRolePermissionAggregateArgs>(args: Subset<T, UserRolePermissionAggregateArgs>): Prisma.PrismaPromise<GetUserRolePermissionAggregateType<T>>

    /**
     * Group by UserRolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: UserRolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for userRolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userRolePermissionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    role<T extends rolesArgs<ExtArgs> = {}>(args?: Subset<T, rolesArgs<ExtArgs>>): Prisma__rolesClient<$Types.GetResult<rolesPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * userRolePermission base type for findUnique actions
   */
  export type userRolePermissionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userRolePermission
     */
    select?: userRolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userRolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which userRolePermission to fetch.
     */
    where: userRolePermissionWhereUniqueInput
  }

  /**
   * userRolePermission findUnique
   */
  export interface userRolePermissionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends userRolePermissionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * userRolePermission findUniqueOrThrow
   */
  export type userRolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userRolePermission
     */
    select?: userRolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userRolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which userRolePermission to fetch.
     */
    where: userRolePermissionWhereUniqueInput
  }


  /**
   * userRolePermission base type for findFirst actions
   */
  export type userRolePermissionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userRolePermission
     */
    select?: userRolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userRolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which userRolePermission to fetch.
     */
    where?: userRolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userRolePermissions to fetch.
     */
    orderBy?: Enumerable<userRolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userRolePermissions.
     */
    cursor?: userRolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userRolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userRolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userRolePermissions.
     */
    distinct?: Enumerable<UserRolePermissionScalarFieldEnum>
  }

  /**
   * userRolePermission findFirst
   */
  export interface userRolePermissionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends userRolePermissionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * userRolePermission findFirstOrThrow
   */
  export type userRolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userRolePermission
     */
    select?: userRolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userRolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which userRolePermission to fetch.
     */
    where?: userRolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userRolePermissions to fetch.
     */
    orderBy?: Enumerable<userRolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userRolePermissions.
     */
    cursor?: userRolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userRolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userRolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userRolePermissions.
     */
    distinct?: Enumerable<UserRolePermissionScalarFieldEnum>
  }


  /**
   * userRolePermission findMany
   */
  export type userRolePermissionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userRolePermission
     */
    select?: userRolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userRolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which userRolePermissions to fetch.
     */
    where?: userRolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userRolePermissions to fetch.
     */
    orderBy?: Enumerable<userRolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userRolePermissions.
     */
    cursor?: userRolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userRolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userRolePermissions.
     */
    skip?: number
    distinct?: Enumerable<UserRolePermissionScalarFieldEnum>
  }


  /**
   * userRolePermission create
   */
  export type userRolePermissionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userRolePermission
     */
    select?: userRolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userRolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a userRolePermission.
     */
    data: XOR<userRolePermissionCreateInput, userRolePermissionUncheckedCreateInput>
  }


  /**
   * userRolePermission createMany
   */
  export type userRolePermissionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userRolePermissions.
     */
    data: Enumerable<userRolePermissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * userRolePermission update
   */
  export type userRolePermissionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userRolePermission
     */
    select?: userRolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userRolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a userRolePermission.
     */
    data: XOR<userRolePermissionUpdateInput, userRolePermissionUncheckedUpdateInput>
    /**
     * Choose, which userRolePermission to update.
     */
    where: userRolePermissionWhereUniqueInput
  }


  /**
   * userRolePermission updateMany
   */
  export type userRolePermissionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userRolePermissions.
     */
    data: XOR<userRolePermissionUpdateManyMutationInput, userRolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which userRolePermissions to update
     */
    where?: userRolePermissionWhereInput
  }


  /**
   * userRolePermission upsert
   */
  export type userRolePermissionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userRolePermission
     */
    select?: userRolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userRolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the userRolePermission to update in case it exists.
     */
    where: userRolePermissionWhereUniqueInput
    /**
     * In case the userRolePermission found by the `where` argument doesn't exist, create a new userRolePermission with this data.
     */
    create: XOR<userRolePermissionCreateInput, userRolePermissionUncheckedCreateInput>
    /**
     * In case the userRolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userRolePermissionUpdateInput, userRolePermissionUncheckedUpdateInput>
  }


  /**
   * userRolePermission delete
   */
  export type userRolePermissionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userRolePermission
     */
    select?: userRolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userRolePermissionInclude<ExtArgs> | null
    /**
     * Filter which userRolePermission to delete.
     */
    where: userRolePermissionWhereUniqueInput
  }


  /**
   * userRolePermission deleteMany
   */
  export type userRolePermissionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userRolePermissions to delete
     */
    where?: userRolePermissionWhereInput
  }


  /**
   * userRolePermission without action
   */
  export type userRolePermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userRolePermission
     */
    select?: userRolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userRolePermissionInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    address: 'address',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    productName: 'productName',
    description: 'description',
    purchasePrice: 'purchasePrice',
    sellingPrice: 'sellingPrice',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    purchaseOrderNo: 'purchaseOrderNo',
    vendorId: 'vendorId',
    remarks: 'remarks',
    total: 'total',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseItemsScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    productId: 'productId',
    quantity: 'quantity',
    purchasePrice: 'purchasePrice',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseItemsScalarFieldEnum = (typeof PurchaseItemsScalarFieldEnum)[keyof typeof PurchaseItemsScalarFieldEnum]


  export const SalesOrderScalarFieldEnum: {
    id: 'id',
    salesOrderNo: 'salesOrderNo',
    customerId: 'customerId',
    userId: 'userId',
    remarks: 'remarks',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesOrderScalarFieldEnum = (typeof SalesOrderScalarFieldEnum)[keyof typeof SalesOrderScalarFieldEnum]


  export const SalesItemsScalarFieldEnum: {
    id: 'id',
    salesOrderId: 'salesOrderId',
    productId: 'productId',
    quantity: 'quantity',
    sellingPrice: 'sellingPrice',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesItemsScalarFieldEnum = (typeof SalesItemsScalarFieldEnum)[keyof typeof SalesItemsScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const UserTokensScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    expiry: 'expiry',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserTokensScalarFieldEnum = (typeof UserTokensScalarFieldEnum)[keyof typeof UserTokensScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolesPermissionScalarFieldEnum: {
    id: 'id',
    roleid: 'roleid',
    permissionid: 'permissionid'
  };

  export type RolesPermissionScalarFieldEnum = (typeof RolesPermissionScalarFieldEnum)[keyof typeof RolesPermissionScalarFieldEnum]


  export const UserRolePermissionScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    roleid: 'roleid'
  };

  export type UserRolePermissionScalarFieldEnum = (typeof UserRolePermissionScalarFieldEnum)[keyof typeof UserRolePermissionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: Enumerable<userWhereInput>
    OR?: Enumerable<userWhereInput>
    NOT?: Enumerable<userWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    purchaseOrder?: PurchaseOrderListRelationFilter
    salesOrder?: SalesOrderListRelationFilter
    userTokens?: UserTokensListRelationFilter
    userRolePermission?: UserRolePermissionListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseOrder?: purchaseOrderOrderByRelationAggregateInput
    salesOrder?: salesOrderOrderByRelationAggregateInput
    userTokens?: userTokensOrderByRelationAggregateInput
    userRolePermission?: userRolePermissionOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userScalarWhereWithAggregatesInput>
    OR?: Enumerable<userScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    firstName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type productWhereInput = {
    AND?: Enumerable<productWhereInput>
    OR?: Enumerable<productWhereInput>
    NOT?: Enumerable<productWhereInput>
    id?: IntFilter | number
    productName?: StringFilter | string
    description?: StringNullableFilter | string | null
    purchasePrice?: FloatFilter | number
    sellingPrice?: FloatFilter | number
    quantity?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    purchaseItems?: PurchaseItemsListRelationFilter
    salesItems?: SalesItemsListRelationFilter
  }

  export type productOrderByWithRelationInput = {
    id?: SortOrder
    productName?: SortOrder
    description?: SortOrderInput | SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseItems?: purchaseItemsOrderByRelationAggregateInput
    salesItems?: salesItemsOrderByRelationAggregateInput
  }

  export type productWhereUniqueInput = {
    id?: number
    productName?: string
  }

  export type productOrderByWithAggregationInput = {
    id?: SortOrder
    productName?: SortOrder
    description?: SortOrderInput | SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: Enumerable<productScalarWhereWithAggregatesInput>
    OR?: Enumerable<productScalarWhereWithAggregatesInput>
    NOT?: Enumerable<productScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productName?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    purchasePrice?: FloatWithAggregatesFilter | number
    sellingPrice?: FloatWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type purchaseOrderWhereInput = {
    AND?: Enumerable<purchaseOrderWhereInput>
    OR?: Enumerable<purchaseOrderWhereInput>
    NOT?: Enumerable<purchaseOrderWhereInput>
    id?: IntFilter | number
    purchaseOrderNo?: StringNullableFilter | string | null
    vendorId?: IntFilter | number
    remarks?: StringNullableFilter | string | null
    total?: FloatFilter | number
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    orders?: PurchaseItemsListRelationFilter
    vendorName?: XOR<VendorRelationFilter, VendorWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type purchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderNo?: SortOrderInput | SortOrder
    vendorId?: SortOrder
    remarks?: SortOrderInput | SortOrder
    total?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: purchaseItemsOrderByRelationAggregateInput
    vendorName?: VendorOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type purchaseOrderWhereUniqueInput = {
    id?: number
  }

  export type purchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderNo?: SortOrderInput | SortOrder
    vendorId?: SortOrder
    remarks?: SortOrderInput | SortOrder
    total?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: purchaseOrderCountOrderByAggregateInput
    _avg?: purchaseOrderAvgOrderByAggregateInput
    _max?: purchaseOrderMaxOrderByAggregateInput
    _min?: purchaseOrderMinOrderByAggregateInput
    _sum?: purchaseOrderSumOrderByAggregateInput
  }

  export type purchaseOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<purchaseOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<purchaseOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<purchaseOrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    purchaseOrderNo?: StringNullableWithAggregatesFilter | string | null
    vendorId?: IntWithAggregatesFilter | number
    remarks?: StringNullableWithAggregatesFilter | string | null
    total?: FloatWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type purchaseItemsWhereInput = {
    AND?: Enumerable<purchaseItemsWhereInput>
    OR?: Enumerable<purchaseItemsWhereInput>
    NOT?: Enumerable<purchaseItemsWhereInput>
    id?: IntFilter | number
    purchaseOrderId?: IntFilter | number
    productId?: IntFilter | number
    quantity?: IntFilter | number
    purchasePrice?: FloatFilter | number
    total?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    purchaseOrder?: XOR<PurchaseOrderRelationFilter, purchaseOrderWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type purchaseItemsOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseOrder?: purchaseOrderOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type purchaseItemsWhereUniqueInput = {
    id?: number
  }

  export type purchaseItemsOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: purchaseItemsCountOrderByAggregateInput
    _avg?: purchaseItemsAvgOrderByAggregateInput
    _max?: purchaseItemsMaxOrderByAggregateInput
    _min?: purchaseItemsMinOrderByAggregateInput
    _sum?: purchaseItemsSumOrderByAggregateInput
  }

  export type purchaseItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<purchaseItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<purchaseItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<purchaseItemsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    purchaseOrderId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
    purchasePrice?: FloatWithAggregatesFilter | number
    total?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type salesOrderWhereInput = {
    AND?: Enumerable<salesOrderWhereInput>
    OR?: Enumerable<salesOrderWhereInput>
    NOT?: Enumerable<salesOrderWhereInput>
    id?: IntFilter | number
    salesOrderNo?: StringNullableFilter | string | null
    customerId?: IntFilter | number
    userId?: IntNullableFilter | number | null
    remarks?: StringNullableFilter | string | null
    total?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    orders?: SalesItemsListRelationFilter
    customerName?: XOR<CustomerRelationFilter, customerWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput> | null
  }

  export type salesOrderOrderByWithRelationInput = {
    id?: SortOrder
    salesOrderNo?: SortOrderInput | SortOrder
    customerId?: SortOrder
    userId?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: salesItemsOrderByRelationAggregateInput
    customerName?: customerOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type salesOrderWhereUniqueInput = {
    id?: number
  }

  export type salesOrderOrderByWithAggregationInput = {
    id?: SortOrder
    salesOrderNo?: SortOrderInput | SortOrder
    customerId?: SortOrder
    userId?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: salesOrderCountOrderByAggregateInput
    _avg?: salesOrderAvgOrderByAggregateInput
    _max?: salesOrderMaxOrderByAggregateInput
    _min?: salesOrderMinOrderByAggregateInput
    _sum?: salesOrderSumOrderByAggregateInput
  }

  export type salesOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<salesOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<salesOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<salesOrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    salesOrderNo?: StringNullableWithAggregatesFilter | string | null
    customerId?: IntWithAggregatesFilter | number
    userId?: IntNullableWithAggregatesFilter | number | null
    remarks?: StringNullableWithAggregatesFilter | string | null
    total?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type salesItemsWhereInput = {
    AND?: Enumerable<salesItemsWhereInput>
    OR?: Enumerable<salesItemsWhereInput>
    NOT?: Enumerable<salesItemsWhereInput>
    id?: IntFilter | number
    salesOrderId?: IntFilter | number
    productId?: IntFilter | number
    quantity?: IntFilter | number
    sellingPrice?: FloatFilter | number
    total?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    salesOrder?: XOR<SalesOrderRelationFilter, salesOrderWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type salesItemsOrderByWithRelationInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salesOrder?: salesOrderOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type salesItemsWhereUniqueInput = {
    id?: number
  }

  export type salesItemsOrderByWithAggregationInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: salesItemsCountOrderByAggregateInput
    _avg?: salesItemsAvgOrderByAggregateInput
    _max?: salesItemsMaxOrderByAggregateInput
    _min?: salesItemsMinOrderByAggregateInput
    _sum?: salesItemsSumOrderByAggregateInput
  }

  export type salesItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<salesItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<salesItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<salesItemsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    salesOrderId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
    sellingPrice?: FloatWithAggregatesFilter | number
    total?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VendorWhereInput = {
    AND?: Enumerable<VendorWhereInput>
    OR?: Enumerable<VendorWhereInput>
    NOT?: Enumerable<VendorWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    purchaseOrder?: PurchaseOrderListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseOrder?: purchaseOrderOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VendorScalarWhereWithAggregatesInput>
    OR?: Enumerable<VendorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VendorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    address?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type customerWhereInput = {
    AND?: Enumerable<customerWhereInput>
    OR?: Enumerable<customerWhereInput>
    NOT?: Enumerable<customerWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    salesOrder?: SalesOrderListRelationFilter
  }

  export type customerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salesOrder?: salesOrderOrderByRelationAggregateInput
  }

  export type customerWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type customerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: customerCountOrderByAggregateInput
    _avg?: customerAvgOrderByAggregateInput
    _max?: customerMaxOrderByAggregateInput
    _min?: customerMinOrderByAggregateInput
    _sum?: customerSumOrderByAggregateInput
  }

  export type customerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<customerScalarWhereWithAggregatesInput>
    OR?: Enumerable<customerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<customerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    address?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type userTokensWhereInput = {
    AND?: Enumerable<userTokensWhereInput>
    OR?: Enumerable<userTokensWhereInput>
    NOT?: Enumerable<userTokensWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    expiry?: DateTimeFilter | Date | string
    token?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type userTokensOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiry?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type userTokensWhereUniqueInput = {
    id?: number
    token?: string
  }

  export type userTokensOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiry?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: userTokensCountOrderByAggregateInput
    _avg?: userTokensAvgOrderByAggregateInput
    _max?: userTokensMaxOrderByAggregateInput
    _min?: userTokensMinOrderByAggregateInput
    _sum?: userTokensSumOrderByAggregateInput
  }

  export type userTokensScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userTokensScalarWhereWithAggregatesInput>
    OR?: Enumerable<userTokensScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userTokensScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    expiry?: DateTimeWithAggregatesFilter | Date | string
    token?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type rolesWhereInput = {
    AND?: Enumerable<rolesWhereInput>
    OR?: Enumerable<rolesWhereInput>
    NOT?: Enumerable<rolesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    rolePermission?: RolesPermissionListRelationFilter
    user?: UserRolePermissionListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rolePermission?: rolesPermissionOrderByRelationAggregateInput
    user?: userRolePermissionOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<rolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<rolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<rolesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type permissionWhereInput = {
    AND?: Enumerable<permissionWhereInput>
    OR?: Enumerable<permissionWhereInput>
    NOT?: Enumerable<permissionWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    slug?: StringFilter | string
    rolePermission?: RolesPermissionListRelationFilter
  }

  export type permissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    rolePermission?: rolesPermissionOrderByRelationAggregateInput
  }

  export type permissionWhereUniqueInput = {
    id?: number
    slug?: string
  }

  export type permissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    _count?: permissionCountOrderByAggregateInput
    _avg?: permissionAvgOrderByAggregateInput
    _max?: permissionMaxOrderByAggregateInput
    _min?: permissionMinOrderByAggregateInput
    _sum?: permissionSumOrderByAggregateInput
  }

  export type permissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<permissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<permissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<permissionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
  }

  export type rolesPermissionWhereInput = {
    AND?: Enumerable<rolesPermissionWhereInput>
    OR?: Enumerable<rolesPermissionWhereInput>
    NOT?: Enumerable<rolesPermissionWhereInput>
    id?: IntFilter | number
    roleid?: IntFilter | number
    permissionid?: IntFilter | number
    role?: XOR<RolesRelationFilter, rolesWhereInput>
    permission?: XOR<PermissionRelationFilter, permissionWhereInput>
  }

  export type rolesPermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleid?: SortOrder
    permissionid?: SortOrder
    role?: rolesOrderByWithRelationInput
    permission?: permissionOrderByWithRelationInput
  }

  export type rolesPermissionWhereUniqueInput = {
    id?: number
  }

  export type rolesPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleid?: SortOrder
    permissionid?: SortOrder
    _count?: rolesPermissionCountOrderByAggregateInput
    _avg?: rolesPermissionAvgOrderByAggregateInput
    _max?: rolesPermissionMaxOrderByAggregateInput
    _min?: rolesPermissionMinOrderByAggregateInput
    _sum?: rolesPermissionSumOrderByAggregateInput
  }

  export type rolesPermissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<rolesPermissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<rolesPermissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<rolesPermissionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    roleid?: IntWithAggregatesFilter | number
    permissionid?: IntWithAggregatesFilter | number
  }

  export type userRolePermissionWhereInput = {
    AND?: Enumerable<userRolePermissionWhereInput>
    OR?: Enumerable<userRolePermissionWhereInput>
    NOT?: Enumerable<userRolePermissionWhereInput>
    id?: IntFilter | number
    userid?: IntFilter | number
    roleid?: IntFilter | number
    user?: XOR<UserRelationFilter, userWhereInput>
    role?: XOR<RolesRelationFilter, rolesWhereInput>
  }

  export type userRolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    roleid?: SortOrder
    user?: userOrderByWithRelationInput
    role?: rolesOrderByWithRelationInput
  }

  export type userRolePermissionWhereUniqueInput = {
    id?: number
  }

  export type userRolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    roleid?: SortOrder
    _count?: userRolePermissionCountOrderByAggregateInput
    _avg?: userRolePermissionAvgOrderByAggregateInput
    _max?: userRolePermissionMaxOrderByAggregateInput
    _min?: userRolePermissionMinOrderByAggregateInput
    _sum?: userRolePermissionSumOrderByAggregateInput
  }

  export type userRolePermissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userRolePermissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<userRolePermissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userRolePermissionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntWithAggregatesFilter | number
    roleid?: IntWithAggregatesFilter | number
  }

  export type userCreateInput = {
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: purchaseOrderCreateNestedManyWithoutUserInput
    salesOrder?: salesOrderCreateNestedManyWithoutUserInput
    userTokens?: userTokensCreateNestedManyWithoutUserInput
    userRolePermission?: userRolePermissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: purchaseOrderUncheckedCreateNestedManyWithoutUserInput
    salesOrder?: salesOrderUncheckedCreateNestedManyWithoutUserInput
    userTokens?: userTokensUncheckedCreateNestedManyWithoutUserInput
    userRolePermission?: userRolePermissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: purchaseOrderUpdateManyWithoutUserNestedInput
    salesOrder?: salesOrderUpdateManyWithoutUserNestedInput
    userTokens?: userTokensUpdateManyWithoutUserNestedInput
    userRolePermission?: userRolePermissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: purchaseOrderUncheckedUpdateManyWithoutUserNestedInput
    salesOrder?: salesOrderUncheckedUpdateManyWithoutUserNestedInput
    userTokens?: userTokensUncheckedUpdateManyWithoutUserNestedInput
    userRolePermission?: userRolePermissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productCreateInput = {
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseItems?: purchaseItemsCreateNestedManyWithoutProductInput
    salesItems?: salesItemsCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateInput = {
    id?: number
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseItems?: purchaseItemsUncheckedCreateNestedManyWithoutProductInput
    salesItems?: salesItemsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productUpdateInput = {
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: purchaseItemsUpdateManyWithoutProductNestedInput
    salesItems?: salesItemsUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: purchaseItemsUncheckedUpdateManyWithoutProductNestedInput
    salesItems?: salesItemsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateManyInput = {
    id?: number
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type productUpdateManyMutationInput = {
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseOrderCreateInput = {
    purchaseOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: purchaseItemsCreateNestedManyWithoutPurchaseOrderInput
    vendorName: VendorCreateNestedOneWithoutPurchaseOrderInput
    user: userCreateNestedOneWithoutPurchaseOrderInput
  }

  export type purchaseOrderUncheckedCreateInput = {
    id?: number
    purchaseOrderNo?: string | null
    vendorId: number
    remarks?: string | null
    total: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: purchaseItemsUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type purchaseOrderUpdateInput = {
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: purchaseItemsUpdateManyWithoutPurchaseOrderNestedInput
    vendorName?: VendorUpdateOneRequiredWithoutPurchaseOrderNestedInput
    user?: userUpdateOneRequiredWithoutPurchaseOrderNestedInput
  }

  export type purchaseOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: purchaseItemsUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type purchaseOrderCreateManyInput = {
    id?: number
    purchaseOrderNo?: string | null
    vendorId: number
    remarks?: string | null
    total: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseOrderUpdateManyMutationInput = {
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseItemsCreateInput = {
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: purchaseOrderCreateNestedOneWithoutOrdersInput
    product: productCreateNestedOneWithoutPurchaseItemsInput
  }

  export type purchaseItemsUncheckedCreateInput = {
    id?: number
    purchaseOrderId: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseItemsUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: purchaseOrderUpdateOneRequiredWithoutOrdersNestedInput
    product?: productUpdateOneRequiredWithoutPurchaseItemsNestedInput
  }

  export type purchaseItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseItemsCreateManyInput = {
    id?: number
    purchaseOrderId: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseItemsUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesOrderCreateInput = {
    salesOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: salesItemsCreateNestedManyWithoutSalesOrderInput
    customerName: customerCreateNestedOneWithoutSalesOrderInput
    user?: userCreateNestedOneWithoutSalesOrderInput
  }

  export type salesOrderUncheckedCreateInput = {
    id?: number
    salesOrderNo?: string | null
    customerId: number
    userId?: number | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: salesItemsUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type salesOrderUpdateInput = {
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: salesItemsUpdateManyWithoutSalesOrderNestedInput
    customerName?: customerUpdateOneRequiredWithoutSalesOrderNestedInput
    user?: userUpdateOneWithoutSalesOrderNestedInput
  }

  export type salesOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: salesItemsUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type salesOrderCreateManyInput = {
    id?: number
    salesOrderNo?: string | null
    customerId: number
    userId?: number | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesOrderUpdateManyMutationInput = {
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesItemsCreateInput = {
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    salesOrder: salesOrderCreateNestedOneWithoutOrdersInput
    product: productCreateNestedOneWithoutSalesItemsInput
  }

  export type salesItemsUncheckedCreateInput = {
    id?: number
    salesOrderId: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesItemsUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesOrder?: salesOrderUpdateOneRequiredWithoutOrdersNestedInput
    product?: productUpdateOneRequiredWithoutSalesItemsNestedInput
  }

  export type salesItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesItemsCreateManyInput = {
    id?: number
    salesOrderId: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesItemsUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: purchaseOrderCreateNestedManyWithoutVendorNameInput
  }

  export type VendorUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: purchaseOrderUncheckedCreateNestedManyWithoutVendorNameInput
  }

  export type VendorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: purchaseOrderUpdateManyWithoutVendorNameNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: purchaseOrderUncheckedUpdateManyWithoutVendorNameNestedInput
  }

  export type VendorCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerCreateInput = {
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salesOrder?: salesOrderCreateNestedManyWithoutCustomerNameInput
  }

  export type customerUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salesOrder?: salesOrderUncheckedCreateNestedManyWithoutCustomerNameInput
  }

  export type customerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesOrder?: salesOrderUpdateManyWithoutCustomerNameNestedInput
  }

  export type customerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesOrder?: salesOrderUncheckedUpdateManyWithoutCustomerNameNestedInput
  }

  export type customerCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userTokensCreateInput = {
    expiry: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: userCreateNestedOneWithoutUserTokensInput
  }

  export type userTokensUncheckedCreateInput = {
    id?: number
    userId: number
    expiry: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userTokensUpdateInput = {
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutUserTokensNestedInput
  }

  export type userTokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userTokensCreateManyInput = {
    id?: number
    userId: number
    expiry: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userTokensUpdateManyMutationInput = {
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userTokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermission?: rolesPermissionCreateNestedManyWithoutRoleInput
    user?: userRolePermissionCreateNestedManyWithoutRoleInput
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermission?: rolesPermissionUncheckedCreateNestedManyWithoutRoleInput
    user?: userRolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type rolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermission?: rolesPermissionUpdateManyWithoutRoleNestedInput
    user?: userRolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermission?: rolesPermissionUncheckedUpdateManyWithoutRoleNestedInput
    user?: userRolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type rolesCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type rolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionCreateInput = {
    name: string
    slug: string
    rolePermission?: rolesPermissionCreateNestedManyWithoutPermissionInput
  }

  export type permissionUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    rolePermission?: rolesPermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type permissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    rolePermission?: rolesPermissionUpdateManyWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    rolePermission?: rolesPermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type permissionCreateManyInput = {
    id?: number
    name: string
    slug: string
  }

  export type permissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type permissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type rolesPermissionCreateInput = {
    role: rolesCreateNestedOneWithoutRolePermissionInput
    permission: permissionCreateNestedOneWithoutRolePermissionInput
  }

  export type rolesPermissionUncheckedCreateInput = {
    id?: number
    roleid: number
    permissionid: number
  }

  export type rolesPermissionUpdateInput = {
    role?: rolesUpdateOneRequiredWithoutRolePermissionNestedInput
    permission?: permissionUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type rolesPermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleid?: IntFieldUpdateOperationsInput | number
    permissionid?: IntFieldUpdateOperationsInput | number
  }

  export type rolesPermissionCreateManyInput = {
    id?: number
    roleid: number
    permissionid: number
  }

  export type rolesPermissionUpdateManyMutationInput = {

  }

  export type rolesPermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleid?: IntFieldUpdateOperationsInput | number
    permissionid?: IntFieldUpdateOperationsInput | number
  }

  export type userRolePermissionCreateInput = {
    user: userCreateNestedOneWithoutUserRolePermissionInput
    role: rolesCreateNestedOneWithoutUserInput
  }

  export type userRolePermissionUncheckedCreateInput = {
    id?: number
    userid: number
    roleid: number
  }

  export type userRolePermissionUpdateInput = {
    user?: userUpdateOneRequiredWithoutUserRolePermissionNestedInput
    role?: rolesUpdateOneRequiredWithoutUserNestedInput
  }

  export type userRolePermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    roleid?: IntFieldUpdateOperationsInput | number
  }

  export type userRolePermissionCreateManyInput = {
    id?: number
    userid: number
    roleid: number
  }

  export type userRolePermissionUpdateManyMutationInput = {

  }

  export type userRolePermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
    roleid?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type PurchaseOrderListRelationFilter = {
    every?: purchaseOrderWhereInput
    some?: purchaseOrderWhereInput
    none?: purchaseOrderWhereInput
  }

  export type SalesOrderListRelationFilter = {
    every?: salesOrderWhereInput
    some?: salesOrderWhereInput
    none?: salesOrderWhereInput
  }

  export type UserTokensListRelationFilter = {
    every?: userTokensWhereInput
    some?: userTokensWhereInput
    none?: userTokensWhereInput
  }

  export type UserRolePermissionListRelationFilter = {
    every?: userRolePermissionWhereInput
    some?: userRolePermissionWhereInput
    none?: userRolePermissionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type purchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type salesOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userTokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userRolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type PurchaseItemsListRelationFilter = {
    every?: purchaseItemsWhereInput
    some?: purchaseItemsWhereInput
    none?: purchaseItemsWhereInput
  }

  export type SalesItemsListRelationFilter = {
    every?: salesItemsWhereInput
    some?: salesItemsWhereInput
    none?: salesItemsWhereInput
  }

  export type purchaseItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type salesItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productCountOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    description?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    id?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    description?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    description?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    id?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type VendorRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type UserRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type purchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderNo?: SortOrder
    vendorId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchaseOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    total?: SortOrder
    userId?: SortOrder
  }

  export type purchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderNo?: SortOrder
    vendorId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderNo?: SortOrder
    vendorId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchaseOrderSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    total?: SortOrder
    userId?: SortOrder
  }

  export type PurchaseOrderRelationFilter = {
    is?: purchaseOrderWhereInput | null
    isNot?: purchaseOrderWhereInput | null
  }

  export type ProductRelationFilter = {
    is?: productWhereInput | null
    isNot?: productWhereInput | null
  }

  export type purchaseItemsCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchaseItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
  }

  export type purchaseItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchaseItemsMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type purchaseItemsSumOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type CustomerRelationFilter = {
    is?: customerWhereInput | null
    isNot?: customerWhereInput | null
  }

  export type salesOrderCountOrderByAggregateInput = {
    id?: SortOrder
    salesOrderNo?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type salesOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    total?: SortOrder
  }

  export type salesOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    salesOrderNo?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type salesOrderMinOrderByAggregateInput = {
    id?: SortOrder
    salesOrderNo?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type salesOrderSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    total?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type SalesOrderRelationFilter = {
    is?: salesOrderWhereInput | null
    isNot?: salesOrderWhereInput | null
  }

  export type salesItemsCountOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type salesItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
  }

  export type salesItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type salesItemsMinOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type salesItemsSumOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type customerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type customerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userTokensCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiry?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userTokensAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type userTokensMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiry?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userTokensMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiry?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userTokensSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RolesPermissionListRelationFilter = {
    every?: rolesPermissionWhereInput
    some?: rolesPermissionWhereInput
    none?: rolesPermissionWhereInput
  }

  export type rolesPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type permissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type permissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type permissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type permissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type permissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesRelationFilter = {
    is?: rolesWhereInput | null
    isNot?: rolesWhereInput | null
  }

  export type PermissionRelationFilter = {
    is?: permissionWhereInput | null
    isNot?: permissionWhereInput | null
  }

  export type rolesPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleid?: SortOrder
    permissionid?: SortOrder
  }

  export type rolesPermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    roleid?: SortOrder
    permissionid?: SortOrder
  }

  export type rolesPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleid?: SortOrder
    permissionid?: SortOrder
  }

  export type rolesPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleid?: SortOrder
    permissionid?: SortOrder
  }

  export type rolesPermissionSumOrderByAggregateInput = {
    id?: SortOrder
    roleid?: SortOrder
    permissionid?: SortOrder
  }

  export type userRolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    roleid?: SortOrder
  }

  export type userRolePermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    roleid?: SortOrder
  }

  export type userRolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    roleid?: SortOrder
  }

  export type userRolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    roleid?: SortOrder
  }

  export type userRolePermissionSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    roleid?: SortOrder
  }

  export type purchaseOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<purchaseOrderCreateWithoutUserInput>, Enumerable<purchaseOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<purchaseOrderCreateOrConnectWithoutUserInput>
    createMany?: purchaseOrderCreateManyUserInputEnvelope
    connect?: Enumerable<purchaseOrderWhereUniqueInput>
  }

  export type salesOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<salesOrderCreateWithoutUserInput>, Enumerable<salesOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<salesOrderCreateOrConnectWithoutUserInput>
    createMany?: salesOrderCreateManyUserInputEnvelope
    connect?: Enumerable<salesOrderWhereUniqueInput>
  }

  export type userTokensCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<userTokensCreateWithoutUserInput>, Enumerable<userTokensUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userTokensCreateOrConnectWithoutUserInput>
    createMany?: userTokensCreateManyUserInputEnvelope
    connect?: Enumerable<userTokensWhereUniqueInput>
  }

  export type userRolePermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<userRolePermissionCreateWithoutUserInput>, Enumerable<userRolePermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userRolePermissionCreateOrConnectWithoutUserInput>
    createMany?: userRolePermissionCreateManyUserInputEnvelope
    connect?: Enumerable<userRolePermissionWhereUniqueInput>
  }

  export type purchaseOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<purchaseOrderCreateWithoutUserInput>, Enumerable<purchaseOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<purchaseOrderCreateOrConnectWithoutUserInput>
    createMany?: purchaseOrderCreateManyUserInputEnvelope
    connect?: Enumerable<purchaseOrderWhereUniqueInput>
  }

  export type salesOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<salesOrderCreateWithoutUserInput>, Enumerable<salesOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<salesOrderCreateOrConnectWithoutUserInput>
    createMany?: salesOrderCreateManyUserInputEnvelope
    connect?: Enumerable<salesOrderWhereUniqueInput>
  }

  export type userTokensUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<userTokensCreateWithoutUserInput>, Enumerable<userTokensUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userTokensCreateOrConnectWithoutUserInput>
    createMany?: userTokensCreateManyUserInputEnvelope
    connect?: Enumerable<userTokensWhereUniqueInput>
  }

  export type userRolePermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<userRolePermissionCreateWithoutUserInput>, Enumerable<userRolePermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userRolePermissionCreateOrConnectWithoutUserInput>
    createMany?: userRolePermissionCreateManyUserInputEnvelope
    connect?: Enumerable<userRolePermissionWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type purchaseOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<purchaseOrderCreateWithoutUserInput>, Enumerable<purchaseOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<purchaseOrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<purchaseOrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: purchaseOrderCreateManyUserInputEnvelope
    set?: Enumerable<purchaseOrderWhereUniqueInput>
    disconnect?: Enumerable<purchaseOrderWhereUniqueInput>
    delete?: Enumerable<purchaseOrderWhereUniqueInput>
    connect?: Enumerable<purchaseOrderWhereUniqueInput>
    update?: Enumerable<purchaseOrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<purchaseOrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<purchaseOrderScalarWhereInput>
  }

  export type salesOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<salesOrderCreateWithoutUserInput>, Enumerable<salesOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<salesOrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<salesOrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: salesOrderCreateManyUserInputEnvelope
    set?: Enumerable<salesOrderWhereUniqueInput>
    disconnect?: Enumerable<salesOrderWhereUniqueInput>
    delete?: Enumerable<salesOrderWhereUniqueInput>
    connect?: Enumerable<salesOrderWhereUniqueInput>
    update?: Enumerable<salesOrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<salesOrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<salesOrderScalarWhereInput>
  }

  export type userTokensUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<userTokensCreateWithoutUserInput>, Enumerable<userTokensUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userTokensCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<userTokensUpsertWithWhereUniqueWithoutUserInput>
    createMany?: userTokensCreateManyUserInputEnvelope
    set?: Enumerable<userTokensWhereUniqueInput>
    disconnect?: Enumerable<userTokensWhereUniqueInput>
    delete?: Enumerable<userTokensWhereUniqueInput>
    connect?: Enumerable<userTokensWhereUniqueInput>
    update?: Enumerable<userTokensUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<userTokensUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<userTokensScalarWhereInput>
  }

  export type userRolePermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<userRolePermissionCreateWithoutUserInput>, Enumerable<userRolePermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userRolePermissionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<userRolePermissionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: userRolePermissionCreateManyUserInputEnvelope
    set?: Enumerable<userRolePermissionWhereUniqueInput>
    disconnect?: Enumerable<userRolePermissionWhereUniqueInput>
    delete?: Enumerable<userRolePermissionWhereUniqueInput>
    connect?: Enumerable<userRolePermissionWhereUniqueInput>
    update?: Enumerable<userRolePermissionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<userRolePermissionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<userRolePermissionScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type purchaseOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<purchaseOrderCreateWithoutUserInput>, Enumerable<purchaseOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<purchaseOrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<purchaseOrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: purchaseOrderCreateManyUserInputEnvelope
    set?: Enumerable<purchaseOrderWhereUniqueInput>
    disconnect?: Enumerable<purchaseOrderWhereUniqueInput>
    delete?: Enumerable<purchaseOrderWhereUniqueInput>
    connect?: Enumerable<purchaseOrderWhereUniqueInput>
    update?: Enumerable<purchaseOrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<purchaseOrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<purchaseOrderScalarWhereInput>
  }

  export type salesOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<salesOrderCreateWithoutUserInput>, Enumerable<salesOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<salesOrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<salesOrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: salesOrderCreateManyUserInputEnvelope
    set?: Enumerable<salesOrderWhereUniqueInput>
    disconnect?: Enumerable<salesOrderWhereUniqueInput>
    delete?: Enumerable<salesOrderWhereUniqueInput>
    connect?: Enumerable<salesOrderWhereUniqueInput>
    update?: Enumerable<salesOrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<salesOrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<salesOrderScalarWhereInput>
  }

  export type userTokensUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<userTokensCreateWithoutUserInput>, Enumerable<userTokensUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userTokensCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<userTokensUpsertWithWhereUniqueWithoutUserInput>
    createMany?: userTokensCreateManyUserInputEnvelope
    set?: Enumerable<userTokensWhereUniqueInput>
    disconnect?: Enumerable<userTokensWhereUniqueInput>
    delete?: Enumerable<userTokensWhereUniqueInput>
    connect?: Enumerable<userTokensWhereUniqueInput>
    update?: Enumerable<userTokensUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<userTokensUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<userTokensScalarWhereInput>
  }

  export type userRolePermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<userRolePermissionCreateWithoutUserInput>, Enumerable<userRolePermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<userRolePermissionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<userRolePermissionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: userRolePermissionCreateManyUserInputEnvelope
    set?: Enumerable<userRolePermissionWhereUniqueInput>
    disconnect?: Enumerable<userRolePermissionWhereUniqueInput>
    delete?: Enumerable<userRolePermissionWhereUniqueInput>
    connect?: Enumerable<userRolePermissionWhereUniqueInput>
    update?: Enumerable<userRolePermissionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<userRolePermissionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<userRolePermissionScalarWhereInput>
  }

  export type purchaseItemsCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<purchaseItemsCreateWithoutProductInput>, Enumerable<purchaseItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<purchaseItemsCreateOrConnectWithoutProductInput>
    createMany?: purchaseItemsCreateManyProductInputEnvelope
    connect?: Enumerable<purchaseItemsWhereUniqueInput>
  }

  export type salesItemsCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<salesItemsCreateWithoutProductInput>, Enumerable<salesItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<salesItemsCreateOrConnectWithoutProductInput>
    createMany?: salesItemsCreateManyProductInputEnvelope
    connect?: Enumerable<salesItemsWhereUniqueInput>
  }

  export type purchaseItemsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<purchaseItemsCreateWithoutProductInput>, Enumerable<purchaseItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<purchaseItemsCreateOrConnectWithoutProductInput>
    createMany?: purchaseItemsCreateManyProductInputEnvelope
    connect?: Enumerable<purchaseItemsWhereUniqueInput>
  }

  export type salesItemsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<salesItemsCreateWithoutProductInput>, Enumerable<salesItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<salesItemsCreateOrConnectWithoutProductInput>
    createMany?: salesItemsCreateManyProductInputEnvelope
    connect?: Enumerable<salesItemsWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type purchaseItemsUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<purchaseItemsCreateWithoutProductInput>, Enumerable<purchaseItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<purchaseItemsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<purchaseItemsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: purchaseItemsCreateManyProductInputEnvelope
    set?: Enumerable<purchaseItemsWhereUniqueInput>
    disconnect?: Enumerable<purchaseItemsWhereUniqueInput>
    delete?: Enumerable<purchaseItemsWhereUniqueInput>
    connect?: Enumerable<purchaseItemsWhereUniqueInput>
    update?: Enumerable<purchaseItemsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<purchaseItemsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<purchaseItemsScalarWhereInput>
  }

  export type salesItemsUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<salesItemsCreateWithoutProductInput>, Enumerable<salesItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<salesItemsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<salesItemsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: salesItemsCreateManyProductInputEnvelope
    set?: Enumerable<salesItemsWhereUniqueInput>
    disconnect?: Enumerable<salesItemsWhereUniqueInput>
    delete?: Enumerable<salesItemsWhereUniqueInput>
    connect?: Enumerable<salesItemsWhereUniqueInput>
    update?: Enumerable<salesItemsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<salesItemsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<salesItemsScalarWhereInput>
  }

  export type purchaseItemsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<purchaseItemsCreateWithoutProductInput>, Enumerable<purchaseItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<purchaseItemsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<purchaseItemsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: purchaseItemsCreateManyProductInputEnvelope
    set?: Enumerable<purchaseItemsWhereUniqueInput>
    disconnect?: Enumerable<purchaseItemsWhereUniqueInput>
    delete?: Enumerable<purchaseItemsWhereUniqueInput>
    connect?: Enumerable<purchaseItemsWhereUniqueInput>
    update?: Enumerable<purchaseItemsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<purchaseItemsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<purchaseItemsScalarWhereInput>
  }

  export type salesItemsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<salesItemsCreateWithoutProductInput>, Enumerable<salesItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<salesItemsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<salesItemsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: salesItemsCreateManyProductInputEnvelope
    set?: Enumerable<salesItemsWhereUniqueInput>
    disconnect?: Enumerable<salesItemsWhereUniqueInput>
    delete?: Enumerable<salesItemsWhereUniqueInput>
    connect?: Enumerable<salesItemsWhereUniqueInput>
    update?: Enumerable<salesItemsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<salesItemsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<salesItemsScalarWhereInput>
  }

  export type purchaseItemsCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<Enumerable<purchaseItemsCreateWithoutPurchaseOrderInput>, Enumerable<purchaseItemsUncheckedCreateWithoutPurchaseOrderInput>>
    connectOrCreate?: Enumerable<purchaseItemsCreateOrConnectWithoutPurchaseOrderInput>
    createMany?: purchaseItemsCreateManyPurchaseOrderInputEnvelope
    connect?: Enumerable<purchaseItemsWhereUniqueInput>
  }

  export type VendorCreateNestedOneWithoutPurchaseOrderInput = {
    create?: XOR<VendorCreateWithoutPurchaseOrderInput, VendorUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseOrderInput
    connect?: VendorWhereUniqueInput
  }

  export type userCreateNestedOneWithoutPurchaseOrderInput = {
    create?: XOR<userCreateWithoutPurchaseOrderInput, userUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: userCreateOrConnectWithoutPurchaseOrderInput
    connect?: userWhereUniqueInput
  }

  export type purchaseItemsUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<Enumerable<purchaseItemsCreateWithoutPurchaseOrderInput>, Enumerable<purchaseItemsUncheckedCreateWithoutPurchaseOrderInput>>
    connectOrCreate?: Enumerable<purchaseItemsCreateOrConnectWithoutPurchaseOrderInput>
    createMany?: purchaseItemsCreateManyPurchaseOrderInputEnvelope
    connect?: Enumerable<purchaseItemsWhereUniqueInput>
  }

  export type purchaseItemsUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<Enumerable<purchaseItemsCreateWithoutPurchaseOrderInput>, Enumerable<purchaseItemsUncheckedCreateWithoutPurchaseOrderInput>>
    connectOrCreate?: Enumerable<purchaseItemsCreateOrConnectWithoutPurchaseOrderInput>
    upsert?: Enumerable<purchaseItemsUpsertWithWhereUniqueWithoutPurchaseOrderInput>
    createMany?: purchaseItemsCreateManyPurchaseOrderInputEnvelope
    set?: Enumerable<purchaseItemsWhereUniqueInput>
    disconnect?: Enumerable<purchaseItemsWhereUniqueInput>
    delete?: Enumerable<purchaseItemsWhereUniqueInput>
    connect?: Enumerable<purchaseItemsWhereUniqueInput>
    update?: Enumerable<purchaseItemsUpdateWithWhereUniqueWithoutPurchaseOrderInput>
    updateMany?: Enumerable<purchaseItemsUpdateManyWithWhereWithoutPurchaseOrderInput>
    deleteMany?: Enumerable<purchaseItemsScalarWhereInput>
  }

  export type VendorUpdateOneRequiredWithoutPurchaseOrderNestedInput = {
    create?: XOR<VendorCreateWithoutPurchaseOrderInput, VendorUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseOrderInput
    upsert?: VendorUpsertWithoutPurchaseOrderInput
    connect?: VendorWhereUniqueInput
    update?: XOR<VendorUpdateWithoutPurchaseOrderInput, VendorUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type userUpdateOneRequiredWithoutPurchaseOrderNestedInput = {
    create?: XOR<userCreateWithoutPurchaseOrderInput, userUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: userCreateOrConnectWithoutPurchaseOrderInput
    upsert?: userUpsertWithoutPurchaseOrderInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutPurchaseOrderInput, userUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type purchaseItemsUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<Enumerable<purchaseItemsCreateWithoutPurchaseOrderInput>, Enumerable<purchaseItemsUncheckedCreateWithoutPurchaseOrderInput>>
    connectOrCreate?: Enumerable<purchaseItemsCreateOrConnectWithoutPurchaseOrderInput>
    upsert?: Enumerable<purchaseItemsUpsertWithWhereUniqueWithoutPurchaseOrderInput>
    createMany?: purchaseItemsCreateManyPurchaseOrderInputEnvelope
    set?: Enumerable<purchaseItemsWhereUniqueInput>
    disconnect?: Enumerable<purchaseItemsWhereUniqueInput>
    delete?: Enumerable<purchaseItemsWhereUniqueInput>
    connect?: Enumerable<purchaseItemsWhereUniqueInput>
    update?: Enumerable<purchaseItemsUpdateWithWhereUniqueWithoutPurchaseOrderInput>
    updateMany?: Enumerable<purchaseItemsUpdateManyWithWhereWithoutPurchaseOrderInput>
    deleteMany?: Enumerable<purchaseItemsScalarWhereInput>
  }

  export type purchaseOrderCreateNestedOneWithoutOrdersInput = {
    create?: XOR<purchaseOrderCreateWithoutOrdersInput, purchaseOrderUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: purchaseOrderCreateOrConnectWithoutOrdersInput
    connect?: purchaseOrderWhereUniqueInput
  }

  export type productCreateNestedOneWithoutPurchaseItemsInput = {
    create?: XOR<productCreateWithoutPurchaseItemsInput, productUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: productCreateOrConnectWithoutPurchaseItemsInput
    connect?: productWhereUniqueInput
  }

  export type purchaseOrderUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<purchaseOrderCreateWithoutOrdersInput, purchaseOrderUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: purchaseOrderCreateOrConnectWithoutOrdersInput
    upsert?: purchaseOrderUpsertWithoutOrdersInput
    connect?: purchaseOrderWhereUniqueInput
    update?: XOR<purchaseOrderUpdateWithoutOrdersInput, purchaseOrderUncheckedUpdateWithoutOrdersInput>
  }

  export type productUpdateOneRequiredWithoutPurchaseItemsNestedInput = {
    create?: XOR<productCreateWithoutPurchaseItemsInput, productUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: productCreateOrConnectWithoutPurchaseItemsInput
    upsert?: productUpsertWithoutPurchaseItemsInput
    connect?: productWhereUniqueInput
    update?: XOR<productUpdateWithoutPurchaseItemsInput, productUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type salesItemsCreateNestedManyWithoutSalesOrderInput = {
    create?: XOR<Enumerable<salesItemsCreateWithoutSalesOrderInput>, Enumerable<salesItemsUncheckedCreateWithoutSalesOrderInput>>
    connectOrCreate?: Enumerable<salesItemsCreateOrConnectWithoutSalesOrderInput>
    createMany?: salesItemsCreateManySalesOrderInputEnvelope
    connect?: Enumerable<salesItemsWhereUniqueInput>
  }

  export type customerCreateNestedOneWithoutSalesOrderInput = {
    create?: XOR<customerCreateWithoutSalesOrderInput, customerUncheckedCreateWithoutSalesOrderInput>
    connectOrCreate?: customerCreateOrConnectWithoutSalesOrderInput
    connect?: customerWhereUniqueInput
  }

  export type userCreateNestedOneWithoutSalesOrderInput = {
    create?: XOR<userCreateWithoutSalesOrderInput, userUncheckedCreateWithoutSalesOrderInput>
    connectOrCreate?: userCreateOrConnectWithoutSalesOrderInput
    connect?: userWhereUniqueInput
  }

  export type salesItemsUncheckedCreateNestedManyWithoutSalesOrderInput = {
    create?: XOR<Enumerable<salesItemsCreateWithoutSalesOrderInput>, Enumerable<salesItemsUncheckedCreateWithoutSalesOrderInput>>
    connectOrCreate?: Enumerable<salesItemsCreateOrConnectWithoutSalesOrderInput>
    createMany?: salesItemsCreateManySalesOrderInputEnvelope
    connect?: Enumerable<salesItemsWhereUniqueInput>
  }

  export type salesItemsUpdateManyWithoutSalesOrderNestedInput = {
    create?: XOR<Enumerable<salesItemsCreateWithoutSalesOrderInput>, Enumerable<salesItemsUncheckedCreateWithoutSalesOrderInput>>
    connectOrCreate?: Enumerable<salesItemsCreateOrConnectWithoutSalesOrderInput>
    upsert?: Enumerable<salesItemsUpsertWithWhereUniqueWithoutSalesOrderInput>
    createMany?: salesItemsCreateManySalesOrderInputEnvelope
    set?: Enumerable<salesItemsWhereUniqueInput>
    disconnect?: Enumerable<salesItemsWhereUniqueInput>
    delete?: Enumerable<salesItemsWhereUniqueInput>
    connect?: Enumerable<salesItemsWhereUniqueInput>
    update?: Enumerable<salesItemsUpdateWithWhereUniqueWithoutSalesOrderInput>
    updateMany?: Enumerable<salesItemsUpdateManyWithWhereWithoutSalesOrderInput>
    deleteMany?: Enumerable<salesItemsScalarWhereInput>
  }

  export type customerUpdateOneRequiredWithoutSalesOrderNestedInput = {
    create?: XOR<customerCreateWithoutSalesOrderInput, customerUncheckedCreateWithoutSalesOrderInput>
    connectOrCreate?: customerCreateOrConnectWithoutSalesOrderInput
    upsert?: customerUpsertWithoutSalesOrderInput
    connect?: customerWhereUniqueInput
    update?: XOR<customerUpdateWithoutSalesOrderInput, customerUncheckedUpdateWithoutSalesOrderInput>
  }

  export type userUpdateOneWithoutSalesOrderNestedInput = {
    create?: XOR<userCreateWithoutSalesOrderInput, userUncheckedCreateWithoutSalesOrderInput>
    connectOrCreate?: userCreateOrConnectWithoutSalesOrderInput
    upsert?: userUpsertWithoutSalesOrderInput
    disconnect?: boolean
    delete?: boolean
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutSalesOrderInput, userUncheckedUpdateWithoutSalesOrderInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type salesItemsUncheckedUpdateManyWithoutSalesOrderNestedInput = {
    create?: XOR<Enumerable<salesItemsCreateWithoutSalesOrderInput>, Enumerable<salesItemsUncheckedCreateWithoutSalesOrderInput>>
    connectOrCreate?: Enumerable<salesItemsCreateOrConnectWithoutSalesOrderInput>
    upsert?: Enumerable<salesItemsUpsertWithWhereUniqueWithoutSalesOrderInput>
    createMany?: salesItemsCreateManySalesOrderInputEnvelope
    set?: Enumerable<salesItemsWhereUniqueInput>
    disconnect?: Enumerable<salesItemsWhereUniqueInput>
    delete?: Enumerable<salesItemsWhereUniqueInput>
    connect?: Enumerable<salesItemsWhereUniqueInput>
    update?: Enumerable<salesItemsUpdateWithWhereUniqueWithoutSalesOrderInput>
    updateMany?: Enumerable<salesItemsUpdateManyWithWhereWithoutSalesOrderInput>
    deleteMany?: Enumerable<salesItemsScalarWhereInput>
  }

  export type salesOrderCreateNestedOneWithoutOrdersInput = {
    create?: XOR<salesOrderCreateWithoutOrdersInput, salesOrderUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: salesOrderCreateOrConnectWithoutOrdersInput
    connect?: salesOrderWhereUniqueInput
  }

  export type productCreateNestedOneWithoutSalesItemsInput = {
    create?: XOR<productCreateWithoutSalesItemsInput, productUncheckedCreateWithoutSalesItemsInput>
    connectOrCreate?: productCreateOrConnectWithoutSalesItemsInput
    connect?: productWhereUniqueInput
  }

  export type salesOrderUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<salesOrderCreateWithoutOrdersInput, salesOrderUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: salesOrderCreateOrConnectWithoutOrdersInput
    upsert?: salesOrderUpsertWithoutOrdersInput
    connect?: salesOrderWhereUniqueInput
    update?: XOR<salesOrderUpdateWithoutOrdersInput, salesOrderUncheckedUpdateWithoutOrdersInput>
  }

  export type productUpdateOneRequiredWithoutSalesItemsNestedInput = {
    create?: XOR<productCreateWithoutSalesItemsInput, productUncheckedCreateWithoutSalesItemsInput>
    connectOrCreate?: productCreateOrConnectWithoutSalesItemsInput
    upsert?: productUpsertWithoutSalesItemsInput
    connect?: productWhereUniqueInput
    update?: XOR<productUpdateWithoutSalesItemsInput, productUncheckedUpdateWithoutSalesItemsInput>
  }

  export type purchaseOrderCreateNestedManyWithoutVendorNameInput = {
    create?: XOR<Enumerable<purchaseOrderCreateWithoutVendorNameInput>, Enumerable<purchaseOrderUncheckedCreateWithoutVendorNameInput>>
    connectOrCreate?: Enumerable<purchaseOrderCreateOrConnectWithoutVendorNameInput>
    createMany?: purchaseOrderCreateManyVendorNameInputEnvelope
    connect?: Enumerable<purchaseOrderWhereUniqueInput>
  }

  export type purchaseOrderUncheckedCreateNestedManyWithoutVendorNameInput = {
    create?: XOR<Enumerable<purchaseOrderCreateWithoutVendorNameInput>, Enumerable<purchaseOrderUncheckedCreateWithoutVendorNameInput>>
    connectOrCreate?: Enumerable<purchaseOrderCreateOrConnectWithoutVendorNameInput>
    createMany?: purchaseOrderCreateManyVendorNameInputEnvelope
    connect?: Enumerable<purchaseOrderWhereUniqueInput>
  }

  export type purchaseOrderUpdateManyWithoutVendorNameNestedInput = {
    create?: XOR<Enumerable<purchaseOrderCreateWithoutVendorNameInput>, Enumerable<purchaseOrderUncheckedCreateWithoutVendorNameInput>>
    connectOrCreate?: Enumerable<purchaseOrderCreateOrConnectWithoutVendorNameInput>
    upsert?: Enumerable<purchaseOrderUpsertWithWhereUniqueWithoutVendorNameInput>
    createMany?: purchaseOrderCreateManyVendorNameInputEnvelope
    set?: Enumerable<purchaseOrderWhereUniqueInput>
    disconnect?: Enumerable<purchaseOrderWhereUniqueInput>
    delete?: Enumerable<purchaseOrderWhereUniqueInput>
    connect?: Enumerable<purchaseOrderWhereUniqueInput>
    update?: Enumerable<purchaseOrderUpdateWithWhereUniqueWithoutVendorNameInput>
    updateMany?: Enumerable<purchaseOrderUpdateManyWithWhereWithoutVendorNameInput>
    deleteMany?: Enumerable<purchaseOrderScalarWhereInput>
  }

  export type purchaseOrderUncheckedUpdateManyWithoutVendorNameNestedInput = {
    create?: XOR<Enumerable<purchaseOrderCreateWithoutVendorNameInput>, Enumerable<purchaseOrderUncheckedCreateWithoutVendorNameInput>>
    connectOrCreate?: Enumerable<purchaseOrderCreateOrConnectWithoutVendorNameInput>
    upsert?: Enumerable<purchaseOrderUpsertWithWhereUniqueWithoutVendorNameInput>
    createMany?: purchaseOrderCreateManyVendorNameInputEnvelope
    set?: Enumerable<purchaseOrderWhereUniqueInput>
    disconnect?: Enumerable<purchaseOrderWhereUniqueInput>
    delete?: Enumerable<purchaseOrderWhereUniqueInput>
    connect?: Enumerable<purchaseOrderWhereUniqueInput>
    update?: Enumerable<purchaseOrderUpdateWithWhereUniqueWithoutVendorNameInput>
    updateMany?: Enumerable<purchaseOrderUpdateManyWithWhereWithoutVendorNameInput>
    deleteMany?: Enumerable<purchaseOrderScalarWhereInput>
  }

  export type salesOrderCreateNestedManyWithoutCustomerNameInput = {
    create?: XOR<Enumerable<salesOrderCreateWithoutCustomerNameInput>, Enumerable<salesOrderUncheckedCreateWithoutCustomerNameInput>>
    connectOrCreate?: Enumerable<salesOrderCreateOrConnectWithoutCustomerNameInput>
    createMany?: salesOrderCreateManyCustomerNameInputEnvelope
    connect?: Enumerable<salesOrderWhereUniqueInput>
  }

  export type salesOrderUncheckedCreateNestedManyWithoutCustomerNameInput = {
    create?: XOR<Enumerable<salesOrderCreateWithoutCustomerNameInput>, Enumerable<salesOrderUncheckedCreateWithoutCustomerNameInput>>
    connectOrCreate?: Enumerable<salesOrderCreateOrConnectWithoutCustomerNameInput>
    createMany?: salesOrderCreateManyCustomerNameInputEnvelope
    connect?: Enumerable<salesOrderWhereUniqueInput>
  }

  export type salesOrderUpdateManyWithoutCustomerNameNestedInput = {
    create?: XOR<Enumerable<salesOrderCreateWithoutCustomerNameInput>, Enumerable<salesOrderUncheckedCreateWithoutCustomerNameInput>>
    connectOrCreate?: Enumerable<salesOrderCreateOrConnectWithoutCustomerNameInput>
    upsert?: Enumerable<salesOrderUpsertWithWhereUniqueWithoutCustomerNameInput>
    createMany?: salesOrderCreateManyCustomerNameInputEnvelope
    set?: Enumerable<salesOrderWhereUniqueInput>
    disconnect?: Enumerable<salesOrderWhereUniqueInput>
    delete?: Enumerable<salesOrderWhereUniqueInput>
    connect?: Enumerable<salesOrderWhereUniqueInput>
    update?: Enumerable<salesOrderUpdateWithWhereUniqueWithoutCustomerNameInput>
    updateMany?: Enumerable<salesOrderUpdateManyWithWhereWithoutCustomerNameInput>
    deleteMany?: Enumerable<salesOrderScalarWhereInput>
  }

  export type salesOrderUncheckedUpdateManyWithoutCustomerNameNestedInput = {
    create?: XOR<Enumerable<salesOrderCreateWithoutCustomerNameInput>, Enumerable<salesOrderUncheckedCreateWithoutCustomerNameInput>>
    connectOrCreate?: Enumerable<salesOrderCreateOrConnectWithoutCustomerNameInput>
    upsert?: Enumerable<salesOrderUpsertWithWhereUniqueWithoutCustomerNameInput>
    createMany?: salesOrderCreateManyCustomerNameInputEnvelope
    set?: Enumerable<salesOrderWhereUniqueInput>
    disconnect?: Enumerable<salesOrderWhereUniqueInput>
    delete?: Enumerable<salesOrderWhereUniqueInput>
    connect?: Enumerable<salesOrderWhereUniqueInput>
    update?: Enumerable<salesOrderUpdateWithWhereUniqueWithoutCustomerNameInput>
    updateMany?: Enumerable<salesOrderUpdateManyWithWhereWithoutCustomerNameInput>
    deleteMany?: Enumerable<salesOrderScalarWhereInput>
  }

  export type userCreateNestedOneWithoutUserTokensInput = {
    create?: XOR<userCreateWithoutUserTokensInput, userUncheckedCreateWithoutUserTokensInput>
    connectOrCreate?: userCreateOrConnectWithoutUserTokensInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUserTokensNestedInput = {
    create?: XOR<userCreateWithoutUserTokensInput, userUncheckedCreateWithoutUserTokensInput>
    connectOrCreate?: userCreateOrConnectWithoutUserTokensInput
    upsert?: userUpsertWithoutUserTokensInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutUserTokensInput, userUncheckedUpdateWithoutUserTokensInput>
  }

  export type rolesPermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<rolesPermissionCreateWithoutRoleInput>, Enumerable<rolesPermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<rolesPermissionCreateOrConnectWithoutRoleInput>
    createMany?: rolesPermissionCreateManyRoleInputEnvelope
    connect?: Enumerable<rolesPermissionWhereUniqueInput>
  }

  export type userRolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<userRolePermissionCreateWithoutRoleInput>, Enumerable<userRolePermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<userRolePermissionCreateOrConnectWithoutRoleInput>
    createMany?: userRolePermissionCreateManyRoleInputEnvelope
    connect?: Enumerable<userRolePermissionWhereUniqueInput>
  }

  export type rolesPermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<rolesPermissionCreateWithoutRoleInput>, Enumerable<rolesPermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<rolesPermissionCreateOrConnectWithoutRoleInput>
    createMany?: rolesPermissionCreateManyRoleInputEnvelope
    connect?: Enumerable<rolesPermissionWhereUniqueInput>
  }

  export type userRolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<userRolePermissionCreateWithoutRoleInput>, Enumerable<userRolePermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<userRolePermissionCreateOrConnectWithoutRoleInput>
    createMany?: userRolePermissionCreateManyRoleInputEnvelope
    connect?: Enumerable<userRolePermissionWhereUniqueInput>
  }

  export type rolesPermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<rolesPermissionCreateWithoutRoleInput>, Enumerable<rolesPermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<rolesPermissionCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<rolesPermissionUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: rolesPermissionCreateManyRoleInputEnvelope
    set?: Enumerable<rolesPermissionWhereUniqueInput>
    disconnect?: Enumerable<rolesPermissionWhereUniqueInput>
    delete?: Enumerable<rolesPermissionWhereUniqueInput>
    connect?: Enumerable<rolesPermissionWhereUniqueInput>
    update?: Enumerable<rolesPermissionUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<rolesPermissionUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<rolesPermissionScalarWhereInput>
  }

  export type userRolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<userRolePermissionCreateWithoutRoleInput>, Enumerable<userRolePermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<userRolePermissionCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<userRolePermissionUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: userRolePermissionCreateManyRoleInputEnvelope
    set?: Enumerable<userRolePermissionWhereUniqueInput>
    disconnect?: Enumerable<userRolePermissionWhereUniqueInput>
    delete?: Enumerable<userRolePermissionWhereUniqueInput>
    connect?: Enumerable<userRolePermissionWhereUniqueInput>
    update?: Enumerable<userRolePermissionUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<userRolePermissionUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<userRolePermissionScalarWhereInput>
  }

  export type rolesPermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<rolesPermissionCreateWithoutRoleInput>, Enumerable<rolesPermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<rolesPermissionCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<rolesPermissionUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: rolesPermissionCreateManyRoleInputEnvelope
    set?: Enumerable<rolesPermissionWhereUniqueInput>
    disconnect?: Enumerable<rolesPermissionWhereUniqueInput>
    delete?: Enumerable<rolesPermissionWhereUniqueInput>
    connect?: Enumerable<rolesPermissionWhereUniqueInput>
    update?: Enumerable<rolesPermissionUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<rolesPermissionUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<rolesPermissionScalarWhereInput>
  }

  export type userRolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<userRolePermissionCreateWithoutRoleInput>, Enumerable<userRolePermissionUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<userRolePermissionCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<userRolePermissionUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: userRolePermissionCreateManyRoleInputEnvelope
    set?: Enumerable<userRolePermissionWhereUniqueInput>
    disconnect?: Enumerable<userRolePermissionWhereUniqueInput>
    delete?: Enumerable<userRolePermissionWhereUniqueInput>
    connect?: Enumerable<userRolePermissionWhereUniqueInput>
    update?: Enumerable<userRolePermissionUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<userRolePermissionUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<userRolePermissionScalarWhereInput>
  }

  export type rolesPermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<Enumerable<rolesPermissionCreateWithoutPermissionInput>, Enumerable<rolesPermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<rolesPermissionCreateOrConnectWithoutPermissionInput>
    createMany?: rolesPermissionCreateManyPermissionInputEnvelope
    connect?: Enumerable<rolesPermissionWhereUniqueInput>
  }

  export type rolesPermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<Enumerable<rolesPermissionCreateWithoutPermissionInput>, Enumerable<rolesPermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<rolesPermissionCreateOrConnectWithoutPermissionInput>
    createMany?: rolesPermissionCreateManyPermissionInputEnvelope
    connect?: Enumerable<rolesPermissionWhereUniqueInput>
  }

  export type rolesPermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<Enumerable<rolesPermissionCreateWithoutPermissionInput>, Enumerable<rolesPermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<rolesPermissionCreateOrConnectWithoutPermissionInput>
    upsert?: Enumerable<rolesPermissionUpsertWithWhereUniqueWithoutPermissionInput>
    createMany?: rolesPermissionCreateManyPermissionInputEnvelope
    set?: Enumerable<rolesPermissionWhereUniqueInput>
    disconnect?: Enumerable<rolesPermissionWhereUniqueInput>
    delete?: Enumerable<rolesPermissionWhereUniqueInput>
    connect?: Enumerable<rolesPermissionWhereUniqueInput>
    update?: Enumerable<rolesPermissionUpdateWithWhereUniqueWithoutPermissionInput>
    updateMany?: Enumerable<rolesPermissionUpdateManyWithWhereWithoutPermissionInput>
    deleteMany?: Enumerable<rolesPermissionScalarWhereInput>
  }

  export type rolesPermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<Enumerable<rolesPermissionCreateWithoutPermissionInput>, Enumerable<rolesPermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<rolesPermissionCreateOrConnectWithoutPermissionInput>
    upsert?: Enumerable<rolesPermissionUpsertWithWhereUniqueWithoutPermissionInput>
    createMany?: rolesPermissionCreateManyPermissionInputEnvelope
    set?: Enumerable<rolesPermissionWhereUniqueInput>
    disconnect?: Enumerable<rolesPermissionWhereUniqueInput>
    delete?: Enumerable<rolesPermissionWhereUniqueInput>
    connect?: Enumerable<rolesPermissionWhereUniqueInput>
    update?: Enumerable<rolesPermissionUpdateWithWhereUniqueWithoutPermissionInput>
    updateMany?: Enumerable<rolesPermissionUpdateManyWithWhereWithoutPermissionInput>
    deleteMany?: Enumerable<rolesPermissionScalarWhereInput>
  }

  export type rolesCreateNestedOneWithoutRolePermissionInput = {
    create?: XOR<rolesCreateWithoutRolePermissionInput, rolesUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRolePermissionInput
    connect?: rolesWhereUniqueInput
  }

  export type permissionCreateNestedOneWithoutRolePermissionInput = {
    create?: XOR<permissionCreateWithoutRolePermissionInput, permissionUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: permissionCreateOrConnectWithoutRolePermissionInput
    connect?: permissionWhereUniqueInput
  }

  export type rolesUpdateOneRequiredWithoutRolePermissionNestedInput = {
    create?: XOR<rolesCreateWithoutRolePermissionInput, rolesUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRolePermissionInput
    upsert?: rolesUpsertWithoutRolePermissionInput
    connect?: rolesWhereUniqueInput
    update?: XOR<rolesUpdateWithoutRolePermissionInput, rolesUncheckedUpdateWithoutRolePermissionInput>
  }

  export type permissionUpdateOneRequiredWithoutRolePermissionNestedInput = {
    create?: XOR<permissionCreateWithoutRolePermissionInput, permissionUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: permissionCreateOrConnectWithoutRolePermissionInput
    upsert?: permissionUpsertWithoutRolePermissionInput
    connect?: permissionWhereUniqueInput
    update?: XOR<permissionUpdateWithoutRolePermissionInput, permissionUncheckedUpdateWithoutRolePermissionInput>
  }

  export type userCreateNestedOneWithoutUserRolePermissionInput = {
    create?: XOR<userCreateWithoutUserRolePermissionInput, userUncheckedCreateWithoutUserRolePermissionInput>
    connectOrCreate?: userCreateOrConnectWithoutUserRolePermissionInput
    connect?: userWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutUserInput = {
    create?: XOR<rolesCreateWithoutUserInput, rolesUncheckedCreateWithoutUserInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUserInput
    connect?: rolesWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUserRolePermissionNestedInput = {
    create?: XOR<userCreateWithoutUserRolePermissionInput, userUncheckedCreateWithoutUserRolePermissionInput>
    connectOrCreate?: userCreateOrConnectWithoutUserRolePermissionInput
    upsert?: userUpsertWithoutUserRolePermissionInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutUserRolePermissionInput, userUncheckedUpdateWithoutUserRolePermissionInput>
  }

  export type rolesUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<rolesCreateWithoutUserInput, rolesUncheckedCreateWithoutUserInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUserInput
    upsert?: rolesUpsertWithoutUserInput
    connect?: rolesWhereUniqueInput
    update?: XOR<rolesUpdateWithoutUserInput, rolesUncheckedUpdateWithoutUserInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type purchaseOrderCreateWithoutUserInput = {
    purchaseOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: purchaseItemsCreateNestedManyWithoutPurchaseOrderInput
    vendorName: VendorCreateNestedOneWithoutPurchaseOrderInput
  }

  export type purchaseOrderUncheckedCreateWithoutUserInput = {
    id?: number
    purchaseOrderNo?: string | null
    vendorId: number
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: purchaseItemsUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type purchaseOrderCreateOrConnectWithoutUserInput = {
    where: purchaseOrderWhereUniqueInput
    create: XOR<purchaseOrderCreateWithoutUserInput, purchaseOrderUncheckedCreateWithoutUserInput>
  }

  export type purchaseOrderCreateManyUserInputEnvelope = {
    data: Enumerable<purchaseOrderCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type salesOrderCreateWithoutUserInput = {
    salesOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: salesItemsCreateNestedManyWithoutSalesOrderInput
    customerName: customerCreateNestedOneWithoutSalesOrderInput
  }

  export type salesOrderUncheckedCreateWithoutUserInput = {
    id?: number
    salesOrderNo?: string | null
    customerId: number
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: salesItemsUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type salesOrderCreateOrConnectWithoutUserInput = {
    where: salesOrderWhereUniqueInput
    create: XOR<salesOrderCreateWithoutUserInput, salesOrderUncheckedCreateWithoutUserInput>
  }

  export type salesOrderCreateManyUserInputEnvelope = {
    data: Enumerable<salesOrderCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type userTokensCreateWithoutUserInput = {
    expiry: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userTokensUncheckedCreateWithoutUserInput = {
    id?: number
    expiry: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userTokensCreateOrConnectWithoutUserInput = {
    where: userTokensWhereUniqueInput
    create: XOR<userTokensCreateWithoutUserInput, userTokensUncheckedCreateWithoutUserInput>
  }

  export type userTokensCreateManyUserInputEnvelope = {
    data: Enumerable<userTokensCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type userRolePermissionCreateWithoutUserInput = {
    role: rolesCreateNestedOneWithoutUserInput
  }

  export type userRolePermissionUncheckedCreateWithoutUserInput = {
    id?: number
    roleid: number
  }

  export type userRolePermissionCreateOrConnectWithoutUserInput = {
    where: userRolePermissionWhereUniqueInput
    create: XOR<userRolePermissionCreateWithoutUserInput, userRolePermissionUncheckedCreateWithoutUserInput>
  }

  export type userRolePermissionCreateManyUserInputEnvelope = {
    data: Enumerable<userRolePermissionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type purchaseOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: purchaseOrderWhereUniqueInput
    update: XOR<purchaseOrderUpdateWithoutUserInput, purchaseOrderUncheckedUpdateWithoutUserInput>
    create: XOR<purchaseOrderCreateWithoutUserInput, purchaseOrderUncheckedCreateWithoutUserInput>
  }

  export type purchaseOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: purchaseOrderWhereUniqueInput
    data: XOR<purchaseOrderUpdateWithoutUserInput, purchaseOrderUncheckedUpdateWithoutUserInput>
  }

  export type purchaseOrderUpdateManyWithWhereWithoutUserInput = {
    where: purchaseOrderScalarWhereInput
    data: XOR<purchaseOrderUpdateManyMutationInput, purchaseOrderUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type purchaseOrderScalarWhereInput = {
    AND?: Enumerable<purchaseOrderScalarWhereInput>
    OR?: Enumerable<purchaseOrderScalarWhereInput>
    NOT?: Enumerable<purchaseOrderScalarWhereInput>
    id?: IntFilter | number
    purchaseOrderNo?: StringNullableFilter | string | null
    vendorId?: IntFilter | number
    remarks?: StringNullableFilter | string | null
    total?: FloatFilter | number
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type salesOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: salesOrderWhereUniqueInput
    update: XOR<salesOrderUpdateWithoutUserInput, salesOrderUncheckedUpdateWithoutUserInput>
    create: XOR<salesOrderCreateWithoutUserInput, salesOrderUncheckedCreateWithoutUserInput>
  }

  export type salesOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: salesOrderWhereUniqueInput
    data: XOR<salesOrderUpdateWithoutUserInput, salesOrderUncheckedUpdateWithoutUserInput>
  }

  export type salesOrderUpdateManyWithWhereWithoutUserInput = {
    where: salesOrderScalarWhereInput
    data: XOR<salesOrderUpdateManyMutationInput, salesOrderUncheckedUpdateManyWithoutSalesOrderInput>
  }

  export type salesOrderScalarWhereInput = {
    AND?: Enumerable<salesOrderScalarWhereInput>
    OR?: Enumerable<salesOrderScalarWhereInput>
    NOT?: Enumerable<salesOrderScalarWhereInput>
    id?: IntFilter | number
    salesOrderNo?: StringNullableFilter | string | null
    customerId?: IntFilter | number
    userId?: IntNullableFilter | number | null
    remarks?: StringNullableFilter | string | null
    total?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type userTokensUpsertWithWhereUniqueWithoutUserInput = {
    where: userTokensWhereUniqueInput
    update: XOR<userTokensUpdateWithoutUserInput, userTokensUncheckedUpdateWithoutUserInput>
    create: XOR<userTokensCreateWithoutUserInput, userTokensUncheckedCreateWithoutUserInput>
  }

  export type userTokensUpdateWithWhereUniqueWithoutUserInput = {
    where: userTokensWhereUniqueInput
    data: XOR<userTokensUpdateWithoutUserInput, userTokensUncheckedUpdateWithoutUserInput>
  }

  export type userTokensUpdateManyWithWhereWithoutUserInput = {
    where: userTokensScalarWhereInput
    data: XOR<userTokensUpdateManyMutationInput, userTokensUncheckedUpdateManyWithoutUserTokensInput>
  }

  export type userTokensScalarWhereInput = {
    AND?: Enumerable<userTokensScalarWhereInput>
    OR?: Enumerable<userTokensScalarWhereInput>
    NOT?: Enumerable<userTokensScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    expiry?: DateTimeFilter | Date | string
    token?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type userRolePermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: userRolePermissionWhereUniqueInput
    update: XOR<userRolePermissionUpdateWithoutUserInput, userRolePermissionUncheckedUpdateWithoutUserInput>
    create: XOR<userRolePermissionCreateWithoutUserInput, userRolePermissionUncheckedCreateWithoutUserInput>
  }

  export type userRolePermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: userRolePermissionWhereUniqueInput
    data: XOR<userRolePermissionUpdateWithoutUserInput, userRolePermissionUncheckedUpdateWithoutUserInput>
  }

  export type userRolePermissionUpdateManyWithWhereWithoutUserInput = {
    where: userRolePermissionScalarWhereInput
    data: XOR<userRolePermissionUpdateManyMutationInput, userRolePermissionUncheckedUpdateManyWithoutUserRolePermissionInput>
  }

  export type userRolePermissionScalarWhereInput = {
    AND?: Enumerable<userRolePermissionScalarWhereInput>
    OR?: Enumerable<userRolePermissionScalarWhereInput>
    NOT?: Enumerable<userRolePermissionScalarWhereInput>
    id?: IntFilter | number
    userid?: IntFilter | number
    roleid?: IntFilter | number
  }

  export type purchaseItemsCreateWithoutProductInput = {
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: purchaseOrderCreateNestedOneWithoutOrdersInput
  }

  export type purchaseItemsUncheckedCreateWithoutProductInput = {
    id?: number
    purchaseOrderId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseItemsCreateOrConnectWithoutProductInput = {
    where: purchaseItemsWhereUniqueInput
    create: XOR<purchaseItemsCreateWithoutProductInput, purchaseItemsUncheckedCreateWithoutProductInput>
  }

  export type purchaseItemsCreateManyProductInputEnvelope = {
    data: Enumerable<purchaseItemsCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type salesItemsCreateWithoutProductInput = {
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    salesOrder: salesOrderCreateNestedOneWithoutOrdersInput
  }

  export type salesItemsUncheckedCreateWithoutProductInput = {
    id?: number
    salesOrderId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesItemsCreateOrConnectWithoutProductInput = {
    where: salesItemsWhereUniqueInput
    create: XOR<salesItemsCreateWithoutProductInput, salesItemsUncheckedCreateWithoutProductInput>
  }

  export type salesItemsCreateManyProductInputEnvelope = {
    data: Enumerable<salesItemsCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type purchaseItemsUpsertWithWhereUniqueWithoutProductInput = {
    where: purchaseItemsWhereUniqueInput
    update: XOR<purchaseItemsUpdateWithoutProductInput, purchaseItemsUncheckedUpdateWithoutProductInput>
    create: XOR<purchaseItemsCreateWithoutProductInput, purchaseItemsUncheckedCreateWithoutProductInput>
  }

  export type purchaseItemsUpdateWithWhereUniqueWithoutProductInput = {
    where: purchaseItemsWhereUniqueInput
    data: XOR<purchaseItemsUpdateWithoutProductInput, purchaseItemsUncheckedUpdateWithoutProductInput>
  }

  export type purchaseItemsUpdateManyWithWhereWithoutProductInput = {
    where: purchaseItemsScalarWhereInput
    data: XOR<purchaseItemsUpdateManyMutationInput, purchaseItemsUncheckedUpdateManyWithoutPurchaseItemsInput>
  }

  export type purchaseItemsScalarWhereInput = {
    AND?: Enumerable<purchaseItemsScalarWhereInput>
    OR?: Enumerable<purchaseItemsScalarWhereInput>
    NOT?: Enumerable<purchaseItemsScalarWhereInput>
    id?: IntFilter | number
    purchaseOrderId?: IntFilter | number
    productId?: IntFilter | number
    quantity?: IntFilter | number
    purchasePrice?: FloatFilter | number
    total?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type salesItemsUpsertWithWhereUniqueWithoutProductInput = {
    where: salesItemsWhereUniqueInput
    update: XOR<salesItemsUpdateWithoutProductInput, salesItemsUncheckedUpdateWithoutProductInput>
    create: XOR<salesItemsCreateWithoutProductInput, salesItemsUncheckedCreateWithoutProductInput>
  }

  export type salesItemsUpdateWithWhereUniqueWithoutProductInput = {
    where: salesItemsWhereUniqueInput
    data: XOR<salesItemsUpdateWithoutProductInput, salesItemsUncheckedUpdateWithoutProductInput>
  }

  export type salesItemsUpdateManyWithWhereWithoutProductInput = {
    where: salesItemsScalarWhereInput
    data: XOR<salesItemsUpdateManyMutationInput, salesItemsUncheckedUpdateManyWithoutSalesItemsInput>
  }

  export type salesItemsScalarWhereInput = {
    AND?: Enumerable<salesItemsScalarWhereInput>
    OR?: Enumerable<salesItemsScalarWhereInput>
    NOT?: Enumerable<salesItemsScalarWhereInput>
    id?: IntFilter | number
    salesOrderId?: IntFilter | number
    productId?: IntFilter | number
    quantity?: IntFilter | number
    sellingPrice?: FloatFilter | number
    total?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type purchaseItemsCreateWithoutPurchaseOrderInput = {
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutPurchaseItemsInput
  }

  export type purchaseItemsUncheckedCreateWithoutPurchaseOrderInput = {
    id?: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseItemsCreateOrConnectWithoutPurchaseOrderInput = {
    where: purchaseItemsWhereUniqueInput
    create: XOR<purchaseItemsCreateWithoutPurchaseOrderInput, purchaseItemsUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type purchaseItemsCreateManyPurchaseOrderInputEnvelope = {
    data: Enumerable<purchaseItemsCreateManyPurchaseOrderInput>
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutPurchaseOrderInput = {
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUncheckedCreateWithoutPurchaseOrderInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorCreateOrConnectWithoutPurchaseOrderInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPurchaseOrderInput, VendorUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type userCreateWithoutPurchaseOrderInput = {
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salesOrder?: salesOrderCreateNestedManyWithoutUserInput
    userTokens?: userTokensCreateNestedManyWithoutUserInput
    userRolePermission?: userRolePermissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPurchaseOrderInput = {
    id?: number
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salesOrder?: salesOrderUncheckedCreateNestedManyWithoutUserInput
    userTokens?: userTokensUncheckedCreateNestedManyWithoutUserInput
    userRolePermission?: userRolePermissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPurchaseOrderInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPurchaseOrderInput, userUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type purchaseItemsUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: purchaseItemsWhereUniqueInput
    update: XOR<purchaseItemsUpdateWithoutPurchaseOrderInput, purchaseItemsUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<purchaseItemsCreateWithoutPurchaseOrderInput, purchaseItemsUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type purchaseItemsUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: purchaseItemsWhereUniqueInput
    data: XOR<purchaseItemsUpdateWithoutPurchaseOrderInput, purchaseItemsUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type purchaseItemsUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: purchaseItemsScalarWhereInput
    data: XOR<purchaseItemsUpdateManyMutationInput, purchaseItemsUncheckedUpdateManyWithoutOrdersInput>
  }

  export type VendorUpsertWithoutPurchaseOrderInput = {
    update: XOR<VendorUpdateWithoutPurchaseOrderInput, VendorUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<VendorCreateWithoutPurchaseOrderInput, VendorUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type VendorUpdateWithoutPurchaseOrderInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpsertWithoutPurchaseOrderInput = {
    update: XOR<userUpdateWithoutPurchaseOrderInput, userUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<userCreateWithoutPurchaseOrderInput, userUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type userUpdateWithoutPurchaseOrderInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesOrder?: salesOrderUpdateManyWithoutUserNestedInput
    userTokens?: userTokensUpdateManyWithoutUserNestedInput
    userRolePermission?: userRolePermissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesOrder?: salesOrderUncheckedUpdateManyWithoutUserNestedInput
    userTokens?: userTokensUncheckedUpdateManyWithoutUserNestedInput
    userRolePermission?: userRolePermissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type purchaseOrderCreateWithoutOrdersInput = {
    purchaseOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorName: VendorCreateNestedOneWithoutPurchaseOrderInput
    user: userCreateNestedOneWithoutPurchaseOrderInput
  }

  export type purchaseOrderUncheckedCreateWithoutOrdersInput = {
    id?: number
    purchaseOrderNo?: string | null
    vendorId: number
    remarks?: string | null
    total: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseOrderCreateOrConnectWithoutOrdersInput = {
    where: purchaseOrderWhereUniqueInput
    create: XOR<purchaseOrderCreateWithoutOrdersInput, purchaseOrderUncheckedCreateWithoutOrdersInput>
  }

  export type productCreateWithoutPurchaseItemsInput = {
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    salesItems?: salesItemsCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutPurchaseItemsInput = {
    id?: number
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    salesItems?: salesItemsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutPurchaseItemsInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutPurchaseItemsInput, productUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type purchaseOrderUpsertWithoutOrdersInput = {
    update: XOR<purchaseOrderUpdateWithoutOrdersInput, purchaseOrderUncheckedUpdateWithoutOrdersInput>
    create: XOR<purchaseOrderCreateWithoutOrdersInput, purchaseOrderUncheckedCreateWithoutOrdersInput>
  }

  export type purchaseOrderUpdateWithoutOrdersInput = {
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorName?: VendorUpdateOneRequiredWithoutPurchaseOrderNestedInput
    user?: userUpdateOneRequiredWithoutPurchaseOrderNestedInput
  }

  export type purchaseOrderUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productUpsertWithoutPurchaseItemsInput = {
    update: XOR<productUpdateWithoutPurchaseItemsInput, productUncheckedUpdateWithoutPurchaseItemsInput>
    create: XOR<productCreateWithoutPurchaseItemsInput, productUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type productUpdateWithoutPurchaseItemsInput = {
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesItems?: salesItemsUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutPurchaseItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesItems?: salesItemsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type salesItemsCreateWithoutSalesOrderInput = {
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productCreateNestedOneWithoutSalesItemsInput
  }

  export type salesItemsUncheckedCreateWithoutSalesOrderInput = {
    id?: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesItemsCreateOrConnectWithoutSalesOrderInput = {
    where: salesItemsWhereUniqueInput
    create: XOR<salesItemsCreateWithoutSalesOrderInput, salesItemsUncheckedCreateWithoutSalesOrderInput>
  }

  export type salesItemsCreateManySalesOrderInputEnvelope = {
    data: Enumerable<salesItemsCreateManySalesOrderInput>
    skipDuplicates?: boolean
  }

  export type customerCreateWithoutSalesOrderInput = {
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerUncheckedCreateWithoutSalesOrderInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerCreateOrConnectWithoutSalesOrderInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutSalesOrderInput, customerUncheckedCreateWithoutSalesOrderInput>
  }

  export type userCreateWithoutSalesOrderInput = {
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: purchaseOrderCreateNestedManyWithoutUserInput
    userTokens?: userTokensCreateNestedManyWithoutUserInput
    userRolePermission?: userRolePermissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSalesOrderInput = {
    id?: number
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: purchaseOrderUncheckedCreateNestedManyWithoutUserInput
    userTokens?: userTokensUncheckedCreateNestedManyWithoutUserInput
    userRolePermission?: userRolePermissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSalesOrderInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSalesOrderInput, userUncheckedCreateWithoutSalesOrderInput>
  }

  export type salesItemsUpsertWithWhereUniqueWithoutSalesOrderInput = {
    where: salesItemsWhereUniqueInput
    update: XOR<salesItemsUpdateWithoutSalesOrderInput, salesItemsUncheckedUpdateWithoutSalesOrderInput>
    create: XOR<salesItemsCreateWithoutSalesOrderInput, salesItemsUncheckedCreateWithoutSalesOrderInput>
  }

  export type salesItemsUpdateWithWhereUniqueWithoutSalesOrderInput = {
    where: salesItemsWhereUniqueInput
    data: XOR<salesItemsUpdateWithoutSalesOrderInput, salesItemsUncheckedUpdateWithoutSalesOrderInput>
  }

  export type salesItemsUpdateManyWithWhereWithoutSalesOrderInput = {
    where: salesItemsScalarWhereInput
    data: XOR<salesItemsUpdateManyMutationInput, salesItemsUncheckedUpdateManyWithoutOrdersInput>
  }

  export type customerUpsertWithoutSalesOrderInput = {
    update: XOR<customerUpdateWithoutSalesOrderInput, customerUncheckedUpdateWithoutSalesOrderInput>
    create: XOR<customerCreateWithoutSalesOrderInput, customerUncheckedCreateWithoutSalesOrderInput>
  }

  export type customerUpdateWithoutSalesOrderInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerUncheckedUpdateWithoutSalesOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpsertWithoutSalesOrderInput = {
    update: XOR<userUpdateWithoutSalesOrderInput, userUncheckedUpdateWithoutSalesOrderInput>
    create: XOR<userCreateWithoutSalesOrderInput, userUncheckedCreateWithoutSalesOrderInput>
  }

  export type userUpdateWithoutSalesOrderInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: purchaseOrderUpdateManyWithoutUserNestedInput
    userTokens?: userTokensUpdateManyWithoutUserNestedInput
    userRolePermission?: userRolePermissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSalesOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: purchaseOrderUncheckedUpdateManyWithoutUserNestedInput
    userTokens?: userTokensUncheckedUpdateManyWithoutUserNestedInput
    userRolePermission?: userRolePermissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type salesOrderCreateWithoutOrdersInput = {
    salesOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customerName: customerCreateNestedOneWithoutSalesOrderInput
    user?: userCreateNestedOneWithoutSalesOrderInput
  }

  export type salesOrderUncheckedCreateWithoutOrdersInput = {
    id?: number
    salesOrderNo?: string | null
    customerId: number
    userId?: number | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesOrderCreateOrConnectWithoutOrdersInput = {
    where: salesOrderWhereUniqueInput
    create: XOR<salesOrderCreateWithoutOrdersInput, salesOrderUncheckedCreateWithoutOrdersInput>
  }

  export type productCreateWithoutSalesItemsInput = {
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseItems?: purchaseItemsCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutSalesItemsInput = {
    id?: number
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseItems?: purchaseItemsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutSalesItemsInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutSalesItemsInput, productUncheckedCreateWithoutSalesItemsInput>
  }

  export type salesOrderUpsertWithoutOrdersInput = {
    update: XOR<salesOrderUpdateWithoutOrdersInput, salesOrderUncheckedUpdateWithoutOrdersInput>
    create: XOR<salesOrderCreateWithoutOrdersInput, salesOrderUncheckedCreateWithoutOrdersInput>
  }

  export type salesOrderUpdateWithoutOrdersInput = {
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerName?: customerUpdateOneRequiredWithoutSalesOrderNestedInput
    user?: userUpdateOneWithoutSalesOrderNestedInput
  }

  export type salesOrderUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productUpsertWithoutSalesItemsInput = {
    update: XOR<productUpdateWithoutSalesItemsInput, productUncheckedUpdateWithoutSalesItemsInput>
    create: XOR<productCreateWithoutSalesItemsInput, productUncheckedCreateWithoutSalesItemsInput>
  }

  export type productUpdateWithoutSalesItemsInput = {
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: purchaseItemsUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutSalesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: purchaseItemsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type purchaseOrderCreateWithoutVendorNameInput = {
    purchaseOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: purchaseItemsCreateNestedManyWithoutPurchaseOrderInput
    user: userCreateNestedOneWithoutPurchaseOrderInput
  }

  export type purchaseOrderUncheckedCreateWithoutVendorNameInput = {
    id?: number
    purchaseOrderNo?: string | null
    remarks?: string | null
    total: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: purchaseItemsUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type purchaseOrderCreateOrConnectWithoutVendorNameInput = {
    where: purchaseOrderWhereUniqueInput
    create: XOR<purchaseOrderCreateWithoutVendorNameInput, purchaseOrderUncheckedCreateWithoutVendorNameInput>
  }

  export type purchaseOrderCreateManyVendorNameInputEnvelope = {
    data: Enumerable<purchaseOrderCreateManyVendorNameInput>
    skipDuplicates?: boolean
  }

  export type purchaseOrderUpsertWithWhereUniqueWithoutVendorNameInput = {
    where: purchaseOrderWhereUniqueInput
    update: XOR<purchaseOrderUpdateWithoutVendorNameInput, purchaseOrderUncheckedUpdateWithoutVendorNameInput>
    create: XOR<purchaseOrderCreateWithoutVendorNameInput, purchaseOrderUncheckedCreateWithoutVendorNameInput>
  }

  export type purchaseOrderUpdateWithWhereUniqueWithoutVendorNameInput = {
    where: purchaseOrderWhereUniqueInput
    data: XOR<purchaseOrderUpdateWithoutVendorNameInput, purchaseOrderUncheckedUpdateWithoutVendorNameInput>
  }

  export type purchaseOrderUpdateManyWithWhereWithoutVendorNameInput = {
    where: purchaseOrderScalarWhereInput
    data: XOR<purchaseOrderUpdateManyMutationInput, purchaseOrderUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type salesOrderCreateWithoutCustomerNameInput = {
    salesOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: salesItemsCreateNestedManyWithoutSalesOrderInput
    user?: userCreateNestedOneWithoutSalesOrderInput
  }

  export type salesOrderUncheckedCreateWithoutCustomerNameInput = {
    id?: number
    salesOrderNo?: string | null
    userId?: number | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: salesItemsUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type salesOrderCreateOrConnectWithoutCustomerNameInput = {
    where: salesOrderWhereUniqueInput
    create: XOR<salesOrderCreateWithoutCustomerNameInput, salesOrderUncheckedCreateWithoutCustomerNameInput>
  }

  export type salesOrderCreateManyCustomerNameInputEnvelope = {
    data: Enumerable<salesOrderCreateManyCustomerNameInput>
    skipDuplicates?: boolean
  }

  export type salesOrderUpsertWithWhereUniqueWithoutCustomerNameInput = {
    where: salesOrderWhereUniqueInput
    update: XOR<salesOrderUpdateWithoutCustomerNameInput, salesOrderUncheckedUpdateWithoutCustomerNameInput>
    create: XOR<salesOrderCreateWithoutCustomerNameInput, salesOrderUncheckedCreateWithoutCustomerNameInput>
  }

  export type salesOrderUpdateWithWhereUniqueWithoutCustomerNameInput = {
    where: salesOrderWhereUniqueInput
    data: XOR<salesOrderUpdateWithoutCustomerNameInput, salesOrderUncheckedUpdateWithoutCustomerNameInput>
  }

  export type salesOrderUpdateManyWithWhereWithoutCustomerNameInput = {
    where: salesOrderScalarWhereInput
    data: XOR<salesOrderUpdateManyMutationInput, salesOrderUncheckedUpdateManyWithoutSalesOrderInput>
  }

  export type userCreateWithoutUserTokensInput = {
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: purchaseOrderCreateNestedManyWithoutUserInput
    salesOrder?: salesOrderCreateNestedManyWithoutUserInput
    userRolePermission?: userRolePermissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserTokensInput = {
    id?: number
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: purchaseOrderUncheckedCreateNestedManyWithoutUserInput
    salesOrder?: salesOrderUncheckedCreateNestedManyWithoutUserInput
    userRolePermission?: userRolePermissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserTokensInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserTokensInput, userUncheckedCreateWithoutUserTokensInput>
  }

  export type userUpsertWithoutUserTokensInput = {
    update: XOR<userUpdateWithoutUserTokensInput, userUncheckedUpdateWithoutUserTokensInput>
    create: XOR<userCreateWithoutUserTokensInput, userUncheckedCreateWithoutUserTokensInput>
  }

  export type userUpdateWithoutUserTokensInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: purchaseOrderUpdateManyWithoutUserNestedInput
    salesOrder?: salesOrderUpdateManyWithoutUserNestedInput
    userRolePermission?: userRolePermissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: purchaseOrderUncheckedUpdateManyWithoutUserNestedInput
    salesOrder?: salesOrderUncheckedUpdateManyWithoutUserNestedInput
    userRolePermission?: userRolePermissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type rolesPermissionCreateWithoutRoleInput = {
    permission: permissionCreateNestedOneWithoutRolePermissionInput
  }

  export type rolesPermissionUncheckedCreateWithoutRoleInput = {
    id?: number
    permissionid: number
  }

  export type rolesPermissionCreateOrConnectWithoutRoleInput = {
    where: rolesPermissionWhereUniqueInput
    create: XOR<rolesPermissionCreateWithoutRoleInput, rolesPermissionUncheckedCreateWithoutRoleInput>
  }

  export type rolesPermissionCreateManyRoleInputEnvelope = {
    data: Enumerable<rolesPermissionCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type userRolePermissionCreateWithoutRoleInput = {
    user: userCreateNestedOneWithoutUserRolePermissionInput
  }

  export type userRolePermissionUncheckedCreateWithoutRoleInput = {
    id?: number
    userid: number
  }

  export type userRolePermissionCreateOrConnectWithoutRoleInput = {
    where: userRolePermissionWhereUniqueInput
    create: XOR<userRolePermissionCreateWithoutRoleInput, userRolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type userRolePermissionCreateManyRoleInputEnvelope = {
    data: Enumerable<userRolePermissionCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type rolesPermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: rolesPermissionWhereUniqueInput
    update: XOR<rolesPermissionUpdateWithoutRoleInput, rolesPermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<rolesPermissionCreateWithoutRoleInput, rolesPermissionUncheckedCreateWithoutRoleInput>
  }

  export type rolesPermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: rolesPermissionWhereUniqueInput
    data: XOR<rolesPermissionUpdateWithoutRoleInput, rolesPermissionUncheckedUpdateWithoutRoleInput>
  }

  export type rolesPermissionUpdateManyWithWhereWithoutRoleInput = {
    where: rolesPermissionScalarWhereInput
    data: XOR<rolesPermissionUpdateManyMutationInput, rolesPermissionUncheckedUpdateManyWithoutRolePermissionInput>
  }

  export type rolesPermissionScalarWhereInput = {
    AND?: Enumerable<rolesPermissionScalarWhereInput>
    OR?: Enumerable<rolesPermissionScalarWhereInput>
    NOT?: Enumerable<rolesPermissionScalarWhereInput>
    id?: IntFilter | number
    roleid?: IntFilter | number
    permissionid?: IntFilter | number
  }

  export type userRolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: userRolePermissionWhereUniqueInput
    update: XOR<userRolePermissionUpdateWithoutRoleInput, userRolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<userRolePermissionCreateWithoutRoleInput, userRolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type userRolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: userRolePermissionWhereUniqueInput
    data: XOR<userRolePermissionUpdateWithoutRoleInput, userRolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type userRolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: userRolePermissionScalarWhereInput
    data: XOR<userRolePermissionUpdateManyMutationInput, userRolePermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type rolesPermissionCreateWithoutPermissionInput = {
    role: rolesCreateNestedOneWithoutRolePermissionInput
  }

  export type rolesPermissionUncheckedCreateWithoutPermissionInput = {
    id?: number
    roleid: number
  }

  export type rolesPermissionCreateOrConnectWithoutPermissionInput = {
    where: rolesPermissionWhereUniqueInput
    create: XOR<rolesPermissionCreateWithoutPermissionInput, rolesPermissionUncheckedCreateWithoutPermissionInput>
  }

  export type rolesPermissionCreateManyPermissionInputEnvelope = {
    data: Enumerable<rolesPermissionCreateManyPermissionInput>
    skipDuplicates?: boolean
  }

  export type rolesPermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: rolesPermissionWhereUniqueInput
    update: XOR<rolesPermissionUpdateWithoutPermissionInput, rolesPermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<rolesPermissionCreateWithoutPermissionInput, rolesPermissionUncheckedCreateWithoutPermissionInput>
  }

  export type rolesPermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: rolesPermissionWhereUniqueInput
    data: XOR<rolesPermissionUpdateWithoutPermissionInput, rolesPermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type rolesPermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: rolesPermissionScalarWhereInput
    data: XOR<rolesPermissionUpdateManyMutationInput, rolesPermissionUncheckedUpdateManyWithoutRolePermissionInput>
  }

  export type rolesCreateWithoutRolePermissionInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userRolePermissionCreateNestedManyWithoutRoleInput
  }

  export type rolesUncheckedCreateWithoutRolePermissionInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userRolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type rolesCreateOrConnectWithoutRolePermissionInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutRolePermissionInput, rolesUncheckedCreateWithoutRolePermissionInput>
  }

  export type permissionCreateWithoutRolePermissionInput = {
    name: string
    slug: string
  }

  export type permissionUncheckedCreateWithoutRolePermissionInput = {
    id?: number
    name: string
    slug: string
  }

  export type permissionCreateOrConnectWithoutRolePermissionInput = {
    where: permissionWhereUniqueInput
    create: XOR<permissionCreateWithoutRolePermissionInput, permissionUncheckedCreateWithoutRolePermissionInput>
  }

  export type rolesUpsertWithoutRolePermissionInput = {
    update: XOR<rolesUpdateWithoutRolePermissionInput, rolesUncheckedUpdateWithoutRolePermissionInput>
    create: XOR<rolesCreateWithoutRolePermissionInput, rolesUncheckedCreateWithoutRolePermissionInput>
  }

  export type rolesUpdateWithoutRolePermissionInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userRolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type rolesUncheckedUpdateWithoutRolePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userRolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type permissionUpsertWithoutRolePermissionInput = {
    update: XOR<permissionUpdateWithoutRolePermissionInput, permissionUncheckedUpdateWithoutRolePermissionInput>
    create: XOR<permissionCreateWithoutRolePermissionInput, permissionUncheckedCreateWithoutRolePermissionInput>
  }

  export type permissionUpdateWithoutRolePermissionInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type permissionUncheckedUpdateWithoutRolePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateWithoutUserRolePermissionInput = {
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: purchaseOrderCreateNestedManyWithoutUserInput
    salesOrder?: salesOrderCreateNestedManyWithoutUserInput
    userTokens?: userTokensCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserRolePermissionInput = {
    id?: number
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: purchaseOrderUncheckedCreateNestedManyWithoutUserInput
    salesOrder?: salesOrderUncheckedCreateNestedManyWithoutUserInput
    userTokens?: userTokensUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserRolePermissionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserRolePermissionInput, userUncheckedCreateWithoutUserRolePermissionInput>
  }

  export type rolesCreateWithoutUserInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermission?: rolesPermissionCreateNestedManyWithoutRoleInput
  }

  export type rolesUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermission?: rolesPermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type rolesCreateOrConnectWithoutUserInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutUserInput, rolesUncheckedCreateWithoutUserInput>
  }

  export type userUpsertWithoutUserRolePermissionInput = {
    update: XOR<userUpdateWithoutUserRolePermissionInput, userUncheckedUpdateWithoutUserRolePermissionInput>
    create: XOR<userCreateWithoutUserRolePermissionInput, userUncheckedCreateWithoutUserRolePermissionInput>
  }

  export type userUpdateWithoutUserRolePermissionInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: purchaseOrderUpdateManyWithoutUserNestedInput
    salesOrder?: salesOrderUpdateManyWithoutUserNestedInput
    userTokens?: userTokensUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserRolePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: purchaseOrderUncheckedUpdateManyWithoutUserNestedInput
    salesOrder?: salesOrderUncheckedUpdateManyWithoutUserNestedInput
    userTokens?: userTokensUncheckedUpdateManyWithoutUserNestedInput
  }

  export type rolesUpsertWithoutUserInput = {
    update: XOR<rolesUpdateWithoutUserInput, rolesUncheckedUpdateWithoutUserInput>
    create: XOR<rolesCreateWithoutUserInput, rolesUncheckedCreateWithoutUserInput>
  }

  export type rolesUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermission?: rolesPermissionUpdateManyWithoutRoleNestedInput
  }

  export type rolesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermission?: rolesPermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type purchaseOrderCreateManyUserInput = {
    id?: number
    purchaseOrderNo?: string | null
    vendorId: number
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesOrderCreateManyUserInput = {
    id?: number
    salesOrderNo?: string | null
    customerId: number
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userTokensCreateManyUserInput = {
    id?: number
    expiry: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userRolePermissionCreateManyUserInput = {
    id?: number
    roleid: number
  }

  export type purchaseOrderUpdateWithoutUserInput = {
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: purchaseItemsUpdateManyWithoutPurchaseOrderNestedInput
    vendorName?: VendorUpdateOneRequiredWithoutPurchaseOrderNestedInput
  }

  export type purchaseOrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: purchaseItemsUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type purchaseOrderUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesOrderUpdateWithoutUserInput = {
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: salesItemsUpdateManyWithoutSalesOrderNestedInput
    customerName?: customerUpdateOneRequiredWithoutSalesOrderNestedInput
  }

  export type salesOrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: salesItemsUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type salesOrderUncheckedUpdateManyWithoutSalesOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userTokensUpdateWithoutUserInput = {
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userTokensUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userTokensUncheckedUpdateManyWithoutUserTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userRolePermissionUpdateWithoutUserInput = {
    role?: rolesUpdateOneRequiredWithoutUserNestedInput
  }

  export type userRolePermissionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleid?: IntFieldUpdateOperationsInput | number
  }

  export type userRolePermissionUncheckedUpdateManyWithoutUserRolePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleid?: IntFieldUpdateOperationsInput | number
  }

  export type purchaseItemsCreateManyProductInput = {
    id?: number
    purchaseOrderId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesItemsCreateManyProductInput = {
    id?: number
    salesOrderId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseItemsUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: purchaseOrderUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type purchaseItemsUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseItemsUncheckedUpdateManyWithoutPurchaseItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesItemsUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesOrder?: salesOrderUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type salesItemsUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesItemsUncheckedUpdateManyWithoutSalesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseItemsCreateManyPurchaseOrderInput = {
    id?: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseItemsUpdateWithoutPurchaseOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutPurchaseItemsNestedInput
  }

  export type purchaseItemsUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseItemsUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesItemsCreateManySalesOrderInput = {
    id?: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesItemsUpdateWithoutSalesOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutSalesItemsNestedInput
  }

  export type salesItemsUncheckedUpdateWithoutSalesOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salesItemsUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseOrderCreateManyVendorNameInput = {
    id?: number
    purchaseOrderNo?: string | null
    remarks?: string | null
    total: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseOrderUpdateWithoutVendorNameInput = {
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: purchaseItemsUpdateManyWithoutPurchaseOrderNestedInput
    user?: userUpdateOneRequiredWithoutPurchaseOrderNestedInput
  }

  export type purchaseOrderUncheckedUpdateWithoutVendorNameInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: purchaseItemsUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type salesOrderCreateManyCustomerNameInput = {
    id?: number
    salesOrderNo?: string | null
    userId?: number | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type salesOrderUpdateWithoutCustomerNameInput = {
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: salesItemsUpdateManyWithoutSalesOrderNestedInput
    user?: userUpdateOneWithoutSalesOrderNestedInput
  }

  export type salesOrderUncheckedUpdateWithoutCustomerNameInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: salesItemsUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type rolesPermissionCreateManyRoleInput = {
    id?: number
    permissionid: number
  }

  export type userRolePermissionCreateManyRoleInput = {
    id?: number
    userid: number
  }

  export type rolesPermissionUpdateWithoutRoleInput = {
    permission?: permissionUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type rolesPermissionUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionid?: IntFieldUpdateOperationsInput | number
  }

  export type rolesPermissionUncheckedUpdateManyWithoutRolePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionid?: IntFieldUpdateOperationsInput | number
  }

  export type userRolePermissionUpdateWithoutRoleInput = {
    user?: userUpdateOneRequiredWithoutUserRolePermissionNestedInput
  }

  export type userRolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
  }

  export type userRolePermissionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: IntFieldUpdateOperationsInput | number
  }

  export type rolesPermissionCreateManyPermissionInput = {
    id?: number
    roleid: number
  }

  export type rolesPermissionUpdateWithoutPermissionInput = {
    role?: rolesUpdateOneRequiredWithoutRolePermissionNestedInput
  }

  export type rolesPermissionUncheckedUpdateWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleid?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}