
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = {
  id: number
  email: string
  firstName: string | null
  lastName: string | null
  address: string | null
  password: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: number
  productName: string
  description: string | null
  purchasePrice: number
  sellingPrice: number
  quantity: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = {
  id: number
  purchaseOrderNo: string | null
  vendorId: number
  remarks: string | null
  total: number
  userId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model PurchaseItems
 * 
 */
export type PurchaseItems = {
  id: number
  purchaseOrderId: number
  productId: number
  quantity: number
  purchasePrice: number
  total: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SalesOrder
 * 
 */
export type SalesOrder = {
  id: number
  salesOrderNo: string | null
  customerId: number
  userId: number | null
  remarks: string | null
  total: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SalesItems
 * 
 */
export type SalesItems = {
  id: number
  salesOrderId: number
  productId: number
  quantity: number
  sellingPrice: number
  total: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Vendor
 * 
 */
export type Vendor = {
  id: number
  name: string
  address: string | null
  phone: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Customer
 * 
 */
export type Customer = {
  id: number
  name: string
  address: string | null
  phone: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Roles
 * 
 */
export type Roles = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserRoles
 * 
 */
export type UserRoles = {
  id: number
  userId: number
  roleId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserTokens
 * 
 */
export type UserTokens = {
  id: number
  userId: number
  expiry: Date
  token: string
  createdAt: Date
  updatedAt: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<GlobalReject>;

  /**
   * `prisma.purchaseItems`: Exposes CRUD operations for the **PurchaseItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseItems
    * const purchaseItems = await prisma.purchaseItems.findMany()
    * ```
    */
  get purchaseItems(): Prisma.PurchaseItemsDelegate<GlobalReject>;

  /**
   * `prisma.salesOrder`: Exposes CRUD operations for the **SalesOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesOrders
    * const salesOrders = await prisma.salesOrder.findMany()
    * ```
    */
  get salesOrder(): Prisma.SalesOrderDelegate<GlobalReject>;

  /**
   * `prisma.salesItems`: Exposes CRUD operations for the **SalesItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesItems
    * const salesItems = await prisma.salesItems.findMany()
    * ```
    */
  get salesItems(): Prisma.SalesItemsDelegate<GlobalReject>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<GlobalReject>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<GlobalReject>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<GlobalReject>;

  /**
   * `prisma.userRoles`: Exposes CRUD operations for the **UserRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRoles.findMany()
    * ```
    */
  get userRoles(): Prisma.UserRolesDelegate<GlobalReject>;

  /**
   * `prisma.userTokens`: Exposes CRUD operations for the **UserTokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTokens
    * const userTokens = await prisma.userTokens.findMany()
    * ```
    */
  get userTokens(): Prisma.UserTokensDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.15.0
   * Query Engine version: 8fbc245156db7124f997f4cecdd8d1219e360944
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Product: 'Product',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseItems: 'PurchaseItems',
    SalesOrder: 'SalesOrder',
    SalesItems: 'SalesItems',
    Vendor: 'Vendor',
    Customer: 'Customer',
    Roles: 'Roles',
    UserRoles: 'UserRoles',
    UserTokens: 'UserTokens'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    PurchaseOrder: number
    SalesOrder: number
    UserRoles: number
    UserTokens: number
  }

  export type UserCountOutputTypeSelect = {
    PurchaseOrder?: boolean
    SalesOrder?: boolean
    UserRoles?: boolean
    UserTokens?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    purchaseItems: number
    salesItems: number
  }

  export type ProductCountOutputTypeSelect = {
    purchaseItems?: boolean
    salesItems?: boolean
  }

  export type ProductCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductCountOutputTypeArgs)
    ? ProductCountOutputType 
    : S extends { select: any } & (ProductCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductCountOutputType ? ProductCountOutputType[P] : never
  } 
      : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type PurchaseOrderCountOutputType
   */


  export type PurchaseOrderCountOutputType = {
    orders: number
  }

  export type PurchaseOrderCountOutputTypeSelect = {
    orders?: boolean
  }

  export type PurchaseOrderCountOutputTypeGetPayload<S extends boolean | null | undefined | PurchaseOrderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PurchaseOrderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PurchaseOrderCountOutputTypeArgs)
    ? PurchaseOrderCountOutputType 
    : S extends { select: any } & (PurchaseOrderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PurchaseOrderCountOutputType ? PurchaseOrderCountOutputType[P] : never
  } 
      : PurchaseOrderCountOutputType




  // Custom InputTypes

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect | null
  }



  /**
   * Count Type SalesOrderCountOutputType
   */


  export type SalesOrderCountOutputType = {
    orders: number
  }

  export type SalesOrderCountOutputTypeSelect = {
    orders?: boolean
  }

  export type SalesOrderCountOutputTypeGetPayload<S extends boolean | null | undefined | SalesOrderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SalesOrderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SalesOrderCountOutputTypeArgs)
    ? SalesOrderCountOutputType 
    : S extends { select: any } & (SalesOrderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SalesOrderCountOutputType ? SalesOrderCountOutputType[P] : never
  } 
      : SalesOrderCountOutputType




  // Custom InputTypes

  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SalesOrderCountOutputType
     */
    select?: SalesOrderCountOutputTypeSelect | null
  }



  /**
   * Count Type VendorCountOutputType
   */


  export type VendorCountOutputType = {
    PurchaseOrder: number
  }

  export type VendorCountOutputTypeSelect = {
    PurchaseOrder?: boolean
  }

  export type VendorCountOutputTypeGetPayload<S extends boolean | null | undefined | VendorCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VendorCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VendorCountOutputTypeArgs)
    ? VendorCountOutputType 
    : S extends { select: any } & (VendorCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VendorCountOutputType ? VendorCountOutputType[P] : never
  } 
      : VendorCountOutputType




  // Custom InputTypes

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect | null
  }



  /**
   * Count Type CustomerCountOutputType
   */


  export type CustomerCountOutputType = {
    SalesOrder: number
  }

  export type CustomerCountOutputTypeSelect = {
    SalesOrder?: boolean
  }

  export type CustomerCountOutputTypeGetPayload<S extends boolean | null | undefined | CustomerCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CustomerCountOutputTypeArgs)
    ? CustomerCountOutputType 
    : S extends { select: any } & (CustomerCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CustomerCountOutputType ? CustomerCountOutputType[P] : never
  } 
      : CustomerCountOutputType




  // Custom InputTypes

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect | null
  }



  /**
   * Count Type RolesCountOutputType
   */


  export type RolesCountOutputType = {
    UserRoles: number
  }

  export type RolesCountOutputTypeSelect = {
    UserRoles?: boolean
  }

  export type RolesCountOutputTypeGetPayload<S extends boolean | null | undefined | RolesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RolesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RolesCountOutputTypeArgs)
    ? RolesCountOutputType 
    : S extends { select: any } & (RolesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RolesCountOutputType ? RolesCountOutputType[P] : never
  } 
      : RolesCountOutputType




  // Custom InputTypes

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    firstName: string | null
    lastName: string | null
    address: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    firstName: string | null
    lastName: string | null
    address: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    address: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    address?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    address?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    address?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    email: string
    firstName: string | null
    lastName: string | null
    address: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    address?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    PurchaseOrder?: boolean | User$PurchaseOrderArgs
    SalesOrder?: boolean | User$SalesOrderArgs
    UserRoles?: boolean | User$UserRolesArgs
    UserTokens?: boolean | User$UserTokensArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    PurchaseOrder?: boolean | User$PurchaseOrderArgs
    SalesOrder?: boolean | User$SalesOrderArgs
    UserRoles?: boolean | User$UserRolesArgs
    UserTokens?: boolean | User$UserTokensArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'PurchaseOrder' ? Array < PurchaseOrderGetPayload<S['include'][P]>>  :
        P extends 'SalesOrder' ? Array < SalesOrderGetPayload<S['include'][P]>>  :
        P extends 'UserRoles' ? Array < UserRolesGetPayload<S['include'][P]>>  :
        P extends 'UserTokens' ? Array < UserTokensGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'PurchaseOrder' ? Array < PurchaseOrderGetPayload<S['select'][P]>>  :
        P extends 'SalesOrder' ? Array < SalesOrderGetPayload<S['select'][P]>>  :
        P extends 'UserRoles' ? Array < UserRolesGetPayload<S['select'][P]>>  :
        P extends 'UserTokens' ? Array < UserTokensGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    PurchaseOrder<T extends User$PurchaseOrderArgs= {}>(args?: Subset<T, User$PurchaseOrderArgs>): Prisma.PrismaPromise<Array<PurchaseOrderGetPayload<T>>| Null>;

    SalesOrder<T extends User$SalesOrderArgs= {}>(args?: Subset<T, User$SalesOrderArgs>): Prisma.PrismaPromise<Array<SalesOrderGetPayload<T>>| Null>;

    UserRoles<T extends User$UserRolesArgs= {}>(args?: Subset<T, User$UserRolesArgs>): Prisma.PrismaPromise<Array<UserRolesGetPayload<T>>| Null>;

    UserTokens<T extends User$UserTokensArgs= {}>(args?: Subset<T, User$UserTokensArgs>): Prisma.PrismaPromise<Array<UserTokensGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.PurchaseOrder
   */
  export type User$PurchaseOrderArgs = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseOrderInclude | null
    where?: PurchaseOrderWhereInput
    orderBy?: Enumerable<PurchaseOrderOrderByWithRelationInput>
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PurchaseOrderScalarFieldEnum>
  }


  /**
   * User.SalesOrder
   */
  export type User$SalesOrderArgs = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesOrderInclude | null
    where?: SalesOrderWhereInput
    orderBy?: Enumerable<SalesOrderOrderByWithRelationInput>
    cursor?: SalesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesOrderScalarFieldEnum>
  }


  /**
   * User.UserRoles
   */
  export type User$UserRolesArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude | null
    where?: UserRolesWhereInput
    orderBy?: Enumerable<UserRolesOrderByWithRelationInput>
    cursor?: UserRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserRolesScalarFieldEnum>
  }


  /**
   * User.UserTokens
   */
  export type User$UserTokensArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     */
    select?: UserTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTokensInclude | null
    where?: UserTokensWhereInput
    orderBy?: Enumerable<UserTokensOrderByWithRelationInput>
    cursor?: UserTokensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserTokensScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    purchasePrice: number | null
    sellingPrice: number | null
    quantity: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    purchasePrice: number | null
    sellingPrice: number | null
    quantity: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    productName: string | null
    description: string | null
    purchasePrice: number | null
    sellingPrice: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    productName: string | null
    description: string | null
    purchasePrice: number | null
    sellingPrice: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    productName: number
    description: number
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    purchasePrice?: true
    sellingPrice?: true
    quantity?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    purchasePrice?: true
    sellingPrice?: true
    quantity?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    productName?: true
    description?: true
    purchasePrice?: true
    sellingPrice?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    productName?: true
    description?: true
    purchasePrice?: true
    sellingPrice?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    productName?: true
    description?: true
    purchasePrice?: true
    sellingPrice?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: ProductScalarFieldEnum[]
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: number
    productName: string
    description: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    productName?: boolean
    description?: boolean
    purchasePrice?: boolean
    sellingPrice?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseItems?: boolean | Product$purchaseItemsArgs
    salesItems?: boolean | Product$salesItemsArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }


  export type ProductInclude = {
    purchaseItems?: boolean | Product$purchaseItemsArgs
    salesItems?: boolean | Product$salesItemsArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductGetPayload<S extends boolean | null | undefined | ProductArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Product :
    S extends undefined ? never :
    S extends { include: any } & (ProductArgs | ProductFindManyArgs)
    ? Product  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'purchaseItems' ? Array < PurchaseItemsGetPayload<S['include'][P]>>  :
        P extends 'salesItems' ? Array < SalesItemsGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductArgs | ProductFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'purchaseItems' ? Array < PurchaseItemsGetPayload<S['select'][P]>>  :
        P extends 'salesItems' ? Array < SalesItemsGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Product ? Product[P] : never
  } 
      : Product


  type ProductCountArgs = 
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? Prisma__ProductClient<ProductGetPayload<T>> : Prisma__ProductClient<ProductGetPayload<T> | null, null>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? Prisma__ProductClient<ProductGetPayload<T>> : Prisma__ProductClient<ProductGetPayload<T> | null, null>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProductGetPayload<T>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): Prisma__ProductClient<ProductGetPayload<T>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    purchaseItems<T extends Product$purchaseItemsArgs= {}>(args?: Subset<T, Product$purchaseItemsArgs>): Prisma.PrismaPromise<Array<PurchaseItemsGetPayload<T>>| Null>;

    salesItems<T extends Product$salesItemsArgs= {}>(args?: Subset<T, Product$salesItemsArgs>): Prisma.PrismaPromise<Array<SalesItemsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Product base type for findUnique actions
   */
  export type ProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUnique
   */
  export interface ProductFindUniqueArgs extends ProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product base type for findFirst actions
   */
  export type ProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * Product findFirst
   */
  export interface ProductFindFirstArgs extends ProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     */
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }


  /**
   * Product.purchaseItems
   */
  export type Product$purchaseItemsArgs = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseItemsInclude | null
    where?: PurchaseItemsWhereInput
    orderBy?: Enumerable<PurchaseItemsOrderByWithRelationInput>
    cursor?: PurchaseItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PurchaseItemsScalarFieldEnum>
  }


  /**
   * Product.salesItems
   */
  export type Product$salesItemsArgs = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesItemsInclude | null
    where?: SalesItemsWhereInput
    orderBy?: Enumerable<SalesItemsOrderByWithRelationInput>
    cursor?: SalesItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesItemsScalarFieldEnum>
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude | null
  }



  /**
   * Model PurchaseOrder
   */


  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
    total: number | null
    userId: number | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
    total: number | null
    userId: number | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: number | null
    purchaseOrderNo: string | null
    vendorId: number | null
    remarks: string | null
    total: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: number | null
    purchaseOrderNo: string | null
    vendorId: number | null
    remarks: string | null
    total: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    purchaseOrderNo: number
    vendorId: number
    remarks: number
    total: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    id?: true
    vendorId?: true
    total?: true
    userId?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    id?: true
    vendorId?: true
    total?: true
    userId?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    purchaseOrderNo?: true
    vendorId?: true
    remarks?: true
    total?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    purchaseOrderNo?: true
    vendorId?: true
    remarks?: true
    total?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    purchaseOrderNo?: true
    vendorId?: true
    remarks?: true
    total?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: Enumerable<PurchaseOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs = {
    where?: PurchaseOrderWhereInput
    orderBy?: Enumerable<PurchaseOrderOrderByWithAggregationInput>
    by: PurchaseOrderScalarFieldEnum[]
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }


  export type PurchaseOrderGroupByOutputType = {
    id: number
    purchaseOrderNo: string | null
    vendorId: number
    remarks: string | null
    total: number
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect = {
    id?: boolean
    purchaseOrderNo?: boolean
    vendorId?: boolean
    remarks?: boolean
    total?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | PurchaseOrder$ordersArgs
    vendorName?: boolean | VendorArgs
    user?: boolean | UserArgs
    _count?: boolean | PurchaseOrderCountOutputTypeArgs
  }


  export type PurchaseOrderInclude = {
    orders?: boolean | PurchaseOrder$ordersArgs
    vendorName?: boolean | VendorArgs
    user?: boolean | UserArgs
    _count?: boolean | PurchaseOrderCountOutputTypeArgs
  }

  export type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PurchaseOrder :
    S extends undefined ? never :
    S extends { include: any } & (PurchaseOrderArgs | PurchaseOrderFindManyArgs)
    ? PurchaseOrder  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'orders' ? Array < PurchaseItemsGetPayload<S['include'][P]>>  :
        P extends 'vendorName' ? VendorGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends '_count' ? PurchaseOrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PurchaseOrderArgs | PurchaseOrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'orders' ? Array < PurchaseItemsGetPayload<S['select'][P]>>  :
        P extends 'vendorName' ? VendorGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends '_count' ? PurchaseOrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PurchaseOrder ? PurchaseOrder[P] : never
  } 
      : PurchaseOrder


  type PurchaseOrderCountArgs = 
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PurchaseOrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PurchaseOrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PurchaseOrder'> extends True ? Prisma__PurchaseOrderClient<PurchaseOrderGetPayload<T>> : Prisma__PurchaseOrderClient<PurchaseOrderGetPayload<T> | null, null>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs>
    ): Prisma__PurchaseOrderClient<PurchaseOrderGetPayload<T>>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PurchaseOrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PurchaseOrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PurchaseOrder'> extends True ? Prisma__PurchaseOrderClient<PurchaseOrderGetPayload<T>> : Prisma__PurchaseOrderClient<PurchaseOrderGetPayload<T> | null, null>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs>
    ): Prisma__PurchaseOrderClient<PurchaseOrderGetPayload<T>>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PurchaseOrderFindManyArgs>(
      args?: SelectSubset<T, PurchaseOrderFindManyArgs>
    ): Prisma.PrismaPromise<Array<PurchaseOrderGetPayload<T>>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
    **/
    create<T extends PurchaseOrderCreateArgs>(
      args: SelectSubset<T, PurchaseOrderCreateArgs>
    ): Prisma__PurchaseOrderClient<PurchaseOrderGetPayload<T>>

    /**
     * Create many PurchaseOrders.
     *     @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     *     @example
     *     // Create many PurchaseOrders
     *     const purchaseOrder = await prisma.purchaseOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PurchaseOrderCreateManyArgs>(
      args?: SelectSubset<T, PurchaseOrderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
    **/
    delete<T extends PurchaseOrderDeleteArgs>(
      args: SelectSubset<T, PurchaseOrderDeleteArgs>
    ): Prisma__PurchaseOrderClient<PurchaseOrderGetPayload<T>>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PurchaseOrderUpdateArgs>(
      args: SelectSubset<T, PurchaseOrderUpdateArgs>
    ): Prisma__PurchaseOrderClient<PurchaseOrderGetPayload<T>>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(
      args?: SelectSubset<T, PurchaseOrderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PurchaseOrderUpdateManyArgs>(
      args: SelectSubset<T, PurchaseOrderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
    **/
    upsert<T extends PurchaseOrderUpsertArgs>(
      args: SelectSubset<T, PurchaseOrderUpsertArgs>
    ): Prisma__PurchaseOrderClient<PurchaseOrderGetPayload<T>>

    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PurchaseOrderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    orders<T extends PurchaseOrder$ordersArgs= {}>(args?: Subset<T, PurchaseOrder$ordersArgs>): Prisma.PrismaPromise<Array<PurchaseItemsGetPayload<T>>| Null>;

    vendorName<T extends VendorArgs= {}>(args?: Subset<T, VendorArgs>): Prisma__VendorClient<VendorGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PurchaseOrder base type for findUnique actions
   */
  export type PurchaseOrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseOrderInclude | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUnique
   */
  export interface PurchaseOrderFindUniqueArgs extends PurchaseOrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseOrderInclude | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }


  /**
   * PurchaseOrder base type for findFirst actions
   */
  export type PurchaseOrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseOrderInclude | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: Enumerable<PurchaseOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: Enumerable<PurchaseOrderScalarFieldEnum>
  }

  /**
   * PurchaseOrder findFirst
   */
  export interface PurchaseOrderFindFirstArgs extends PurchaseOrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseOrderInclude | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: Enumerable<PurchaseOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: Enumerable<PurchaseOrderScalarFieldEnum>
  }


  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseOrderInclude | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: Enumerable<PurchaseOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: Enumerable<PurchaseOrderScalarFieldEnum>
  }


  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseOrderInclude | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }


  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: Enumerable<PurchaseOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseOrderInclude | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }


  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
  }


  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseOrderInclude | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }


  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseOrderInclude | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }


  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
  }


  /**
   * PurchaseOrder.orders
   */
  export type PurchaseOrder$ordersArgs = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseItemsInclude | null
    where?: PurchaseItemsWhereInput
    orderBy?: Enumerable<PurchaseItemsOrderByWithRelationInput>
    cursor?: PurchaseItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PurchaseItemsScalarFieldEnum>
  }


  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderArgs = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseOrderInclude | null
  }



  /**
   * Model PurchaseItems
   */


  export type AggregatePurchaseItems = {
    _count: PurchaseItemsCountAggregateOutputType | null
    _avg: PurchaseItemsAvgAggregateOutputType | null
    _sum: PurchaseItemsSumAggregateOutputType | null
    _min: PurchaseItemsMinAggregateOutputType | null
    _max: PurchaseItemsMaxAggregateOutputType | null
  }

  export type PurchaseItemsAvgAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    productId: number | null
    quantity: number | null
    purchasePrice: number | null
    total: number | null
  }

  export type PurchaseItemsSumAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    productId: number | null
    quantity: number | null
    purchasePrice: number | null
    total: number | null
  }

  export type PurchaseItemsMinAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    productId: number | null
    quantity: number | null
    purchasePrice: number | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseItemsMaxAggregateOutputType = {
    id: number | null
    purchaseOrderId: number | null
    productId: number | null
    quantity: number | null
    purchasePrice: number | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseItemsCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseItemsAvgAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    purchasePrice?: true
    total?: true
  }

  export type PurchaseItemsSumAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    purchasePrice?: true
    total?: true
  }

  export type PurchaseItemsMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    purchasePrice?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseItemsMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    purchasePrice?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseItemsCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    purchasePrice?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseItemsAggregateArgs = {
    /**
     * Filter which PurchaseItems to aggregate.
     */
    where?: PurchaseItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: Enumerable<PurchaseItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseItems
    **/
    _count?: true | PurchaseItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseItemsMaxAggregateInputType
  }

  export type GetPurchaseItemsAggregateType<T extends PurchaseItemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseItems[P]>
      : GetScalarType<T[P], AggregatePurchaseItems[P]>
  }




  export type PurchaseItemsGroupByArgs = {
    where?: PurchaseItemsWhereInput
    orderBy?: Enumerable<PurchaseItemsOrderByWithAggregationInput>
    by: PurchaseItemsScalarFieldEnum[]
    having?: PurchaseItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseItemsCountAggregateInputType | true
    _avg?: PurchaseItemsAvgAggregateInputType
    _sum?: PurchaseItemsSumAggregateInputType
    _min?: PurchaseItemsMinAggregateInputType
    _max?: PurchaseItemsMaxAggregateInputType
  }


  export type PurchaseItemsGroupByOutputType = {
    id: number
    purchaseOrderId: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseItemsCountAggregateOutputType | null
    _avg: PurchaseItemsAvgAggregateOutputType | null
    _sum: PurchaseItemsSumAggregateOutputType | null
    _min: PurchaseItemsMinAggregateOutputType | null
    _max: PurchaseItemsMaxAggregateOutputType | null
  }

  type GetPurchaseItemsGroupByPayload<T extends PurchaseItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PurchaseItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseItemsGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseItemsGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseItemsSelect = {
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    purchasePrice?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderArgs
    product?: boolean | ProductArgs
  }


  export type PurchaseItemsInclude = {
    purchaseOrder?: boolean | PurchaseOrderArgs
    product?: boolean | ProductArgs
  }

  export type PurchaseItemsGetPayload<S extends boolean | null | undefined | PurchaseItemsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PurchaseItems :
    S extends undefined ? never :
    S extends { include: any } & (PurchaseItemsArgs | PurchaseItemsFindManyArgs)
    ? PurchaseItems  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'purchaseOrder' ? PurchaseOrderGetPayload<S['include'][P]> :
        P extends 'product' ? ProductGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PurchaseItemsArgs | PurchaseItemsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'purchaseOrder' ? PurchaseOrderGetPayload<S['select'][P]> :
        P extends 'product' ? ProductGetPayload<S['select'][P]> :  P extends keyof PurchaseItems ? PurchaseItems[P] : never
  } 
      : PurchaseItems


  type PurchaseItemsCountArgs = 
    Omit<PurchaseItemsFindManyArgs, 'select' | 'include'> & {
      select?: PurchaseItemsCountAggregateInputType | true
    }

  export interface PurchaseItemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PurchaseItems that matches the filter.
     * @param {PurchaseItemsFindUniqueArgs} args - Arguments to find a PurchaseItems
     * @example
     * // Get one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PurchaseItemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PurchaseItemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PurchaseItems'> extends True ? Prisma__PurchaseItemsClient<PurchaseItemsGetPayload<T>> : Prisma__PurchaseItemsClient<PurchaseItemsGetPayload<T> | null, null>

    /**
     * Find one PurchaseItems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PurchaseItemsFindUniqueOrThrowArgs} args - Arguments to find a PurchaseItems
     * @example
     * // Get one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PurchaseItemsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PurchaseItemsFindUniqueOrThrowArgs>
    ): Prisma__PurchaseItemsClient<PurchaseItemsGetPayload<T>>

    /**
     * Find the first PurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsFindFirstArgs} args - Arguments to find a PurchaseItems
     * @example
     * // Get one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PurchaseItemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PurchaseItemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PurchaseItems'> extends True ? Prisma__PurchaseItemsClient<PurchaseItemsGetPayload<T>> : Prisma__PurchaseItemsClient<PurchaseItemsGetPayload<T> | null, null>

    /**
     * Find the first PurchaseItems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsFindFirstOrThrowArgs} args - Arguments to find a PurchaseItems
     * @example
     * // Get one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PurchaseItemsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PurchaseItemsFindFirstOrThrowArgs>
    ): Prisma__PurchaseItemsClient<PurchaseItemsGetPayload<T>>

    /**
     * Find zero or more PurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findMany()
     * 
     * // Get first 10 PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseItemsWithIdOnly = await prisma.purchaseItems.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PurchaseItemsFindManyArgs>(
      args?: SelectSubset<T, PurchaseItemsFindManyArgs>
    ): Prisma.PrismaPromise<Array<PurchaseItemsGetPayload<T>>>

    /**
     * Create a PurchaseItems.
     * @param {PurchaseItemsCreateArgs} args - Arguments to create a PurchaseItems.
     * @example
     * // Create one PurchaseItems
     * const PurchaseItems = await prisma.purchaseItems.create({
     *   data: {
     *     // ... data to create a PurchaseItems
     *   }
     * })
     * 
    **/
    create<T extends PurchaseItemsCreateArgs>(
      args: SelectSubset<T, PurchaseItemsCreateArgs>
    ): Prisma__PurchaseItemsClient<PurchaseItemsGetPayload<T>>

    /**
     * Create many PurchaseItems.
     *     @param {PurchaseItemsCreateManyArgs} args - Arguments to create many PurchaseItems.
     *     @example
     *     // Create many PurchaseItems
     *     const purchaseItems = await prisma.purchaseItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PurchaseItemsCreateManyArgs>(
      args?: SelectSubset<T, PurchaseItemsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseItems.
     * @param {PurchaseItemsDeleteArgs} args - Arguments to delete one PurchaseItems.
     * @example
     * // Delete one PurchaseItems
     * const PurchaseItems = await prisma.purchaseItems.delete({
     *   where: {
     *     // ... filter to delete one PurchaseItems
     *   }
     * })
     * 
    **/
    delete<T extends PurchaseItemsDeleteArgs>(
      args: SelectSubset<T, PurchaseItemsDeleteArgs>
    ): Prisma__PurchaseItemsClient<PurchaseItemsGetPayload<T>>

    /**
     * Update one PurchaseItems.
     * @param {PurchaseItemsUpdateArgs} args - Arguments to update one PurchaseItems.
     * @example
     * // Update one PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PurchaseItemsUpdateArgs>(
      args: SelectSubset<T, PurchaseItemsUpdateArgs>
    ): Prisma__PurchaseItemsClient<PurchaseItemsGetPayload<T>>

    /**
     * Delete zero or more PurchaseItems.
     * @param {PurchaseItemsDeleteManyArgs} args - Arguments to filter PurchaseItems to delete.
     * @example
     * // Delete a few PurchaseItems
     * const { count } = await prisma.purchaseItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PurchaseItemsDeleteManyArgs>(
      args?: SelectSubset<T, PurchaseItemsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PurchaseItemsUpdateManyArgs>(
      args: SelectSubset<T, PurchaseItemsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseItems.
     * @param {PurchaseItemsUpsertArgs} args - Arguments to update or create a PurchaseItems.
     * @example
     * // Update or create a PurchaseItems
     * const purchaseItems = await prisma.purchaseItems.upsert({
     *   create: {
     *     // ... data to create a PurchaseItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseItems we want to update
     *   }
     * })
    **/
    upsert<T extends PurchaseItemsUpsertArgs>(
      args: SelectSubset<T, PurchaseItemsUpsertArgs>
    ): Prisma__PurchaseItemsClient<PurchaseItemsGetPayload<T>>

    /**
     * Count the number of PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsCountArgs} args - Arguments to filter PurchaseItems to count.
     * @example
     * // Count the number of PurchaseItems
     * const count = await prisma.purchaseItems.count({
     *   where: {
     *     // ... the filter for the PurchaseItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseItemsCountArgs>(
      args?: Subset<T, PurchaseItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseItemsAggregateArgs>(args: Subset<T, PurchaseItemsAggregateArgs>): Prisma.PrismaPromise<GetPurchaseItemsAggregateType<T>>

    /**
     * Group by PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseItemsGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PurchaseItemsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    purchaseOrder<T extends PurchaseOrderArgs= {}>(args?: Subset<T, PurchaseOrderArgs>): Prisma__PurchaseOrderClient<PurchaseOrderGetPayload<T> | Null>;

    product<T extends ProductArgs= {}>(args?: Subset<T, ProductArgs>): Prisma__ProductClient<ProductGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PurchaseItems base type for findUnique actions
   */
  export type PurchaseItemsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseItemsInclude | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where: PurchaseItemsWhereUniqueInput
  }

  /**
   * PurchaseItems findUnique
   */
  export interface PurchaseItemsFindUniqueArgs extends PurchaseItemsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PurchaseItems findUniqueOrThrow
   */
  export type PurchaseItemsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseItemsInclude | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where: PurchaseItemsWhereUniqueInput
  }


  /**
   * PurchaseItems base type for findFirst actions
   */
  export type PurchaseItemsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseItemsInclude | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where?: PurchaseItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: Enumerable<PurchaseItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: Enumerable<PurchaseItemsScalarFieldEnum>
  }

  /**
   * PurchaseItems findFirst
   */
  export interface PurchaseItemsFindFirstArgs extends PurchaseItemsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PurchaseItems findFirstOrThrow
   */
  export type PurchaseItemsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseItemsInclude | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where?: PurchaseItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: Enumerable<PurchaseItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: Enumerable<PurchaseItemsScalarFieldEnum>
  }


  /**
   * PurchaseItems findMany
   */
  export type PurchaseItemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseItemsInclude | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where?: PurchaseItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: Enumerable<PurchaseItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseItems.
     */
    cursor?: PurchaseItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    distinct?: Enumerable<PurchaseItemsScalarFieldEnum>
  }


  /**
   * PurchaseItems create
   */
  export type PurchaseItemsCreateArgs = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseItemsInclude | null
    /**
     * The data needed to create a PurchaseItems.
     */
    data: XOR<PurchaseItemsCreateInput, PurchaseItemsUncheckedCreateInput>
  }


  /**
   * PurchaseItems createMany
   */
  export type PurchaseItemsCreateManyArgs = {
    /**
     * The data used to create many PurchaseItems.
     */
    data: Enumerable<PurchaseItemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PurchaseItems update
   */
  export type PurchaseItemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseItemsInclude | null
    /**
     * The data needed to update a PurchaseItems.
     */
    data: XOR<PurchaseItemsUpdateInput, PurchaseItemsUncheckedUpdateInput>
    /**
     * Choose, which PurchaseItems to update.
     */
    where: PurchaseItemsWhereUniqueInput
  }


  /**
   * PurchaseItems updateMany
   */
  export type PurchaseItemsUpdateManyArgs = {
    /**
     * The data used to update PurchaseItems.
     */
    data: XOR<PurchaseItemsUpdateManyMutationInput, PurchaseItemsUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItems to update
     */
    where?: PurchaseItemsWhereInput
  }


  /**
   * PurchaseItems upsert
   */
  export type PurchaseItemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseItemsInclude | null
    /**
     * The filter to search for the PurchaseItems to update in case it exists.
     */
    where: PurchaseItemsWhereUniqueInput
    /**
     * In case the PurchaseItems found by the `where` argument doesn't exist, create a new PurchaseItems with this data.
     */
    create: XOR<PurchaseItemsCreateInput, PurchaseItemsUncheckedCreateInput>
    /**
     * In case the PurchaseItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseItemsUpdateInput, PurchaseItemsUncheckedUpdateInput>
  }


  /**
   * PurchaseItems delete
   */
  export type PurchaseItemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseItemsInclude | null
    /**
     * Filter which PurchaseItems to delete.
     */
    where: PurchaseItemsWhereUniqueInput
  }


  /**
   * PurchaseItems deleteMany
   */
  export type PurchaseItemsDeleteManyArgs = {
    /**
     * Filter which PurchaseItems to delete
     */
    where?: PurchaseItemsWhereInput
  }


  /**
   * PurchaseItems without action
   */
  export type PurchaseItemsArgs = {
    /**
     * Select specific fields to fetch from the PurchaseItems
     */
    select?: PurchaseItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseItemsInclude | null
  }



  /**
   * Model SalesOrder
   */


  export type AggregateSalesOrder = {
    _count: SalesOrderCountAggregateOutputType | null
    _avg: SalesOrderAvgAggregateOutputType | null
    _sum: SalesOrderSumAggregateOutputType | null
    _min: SalesOrderMinAggregateOutputType | null
    _max: SalesOrderMaxAggregateOutputType | null
  }

  export type SalesOrderAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    userId: number | null
    total: number | null
  }

  export type SalesOrderSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    userId: number | null
    total: number | null
  }

  export type SalesOrderMinAggregateOutputType = {
    id: number | null
    salesOrderNo: string | null
    customerId: number | null
    userId: number | null
    remarks: string | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesOrderMaxAggregateOutputType = {
    id: number | null
    salesOrderNo: string | null
    customerId: number | null
    userId: number | null
    remarks: string | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesOrderCountAggregateOutputType = {
    id: number
    salesOrderNo: number
    customerId: number
    userId: number
    remarks: number
    total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesOrderAvgAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
    total?: true
  }

  export type SalesOrderSumAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
    total?: true
  }

  export type SalesOrderMinAggregateInputType = {
    id?: true
    salesOrderNo?: true
    customerId?: true
    userId?: true
    remarks?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesOrderMaxAggregateInputType = {
    id?: true
    salesOrderNo?: true
    customerId?: true
    userId?: true
    remarks?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesOrderCountAggregateInputType = {
    id?: true
    salesOrderNo?: true
    customerId?: true
    userId?: true
    remarks?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesOrderAggregateArgs = {
    /**
     * Filter which SalesOrder to aggregate.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: Enumerable<SalesOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesOrders
    **/
    _count?: true | SalesOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesOrderMaxAggregateInputType
  }

  export type GetSalesOrderAggregateType<T extends SalesOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesOrder[P]>
      : GetScalarType<T[P], AggregateSalesOrder[P]>
  }




  export type SalesOrderGroupByArgs = {
    where?: SalesOrderWhereInput
    orderBy?: Enumerable<SalesOrderOrderByWithAggregationInput>
    by: SalesOrderScalarFieldEnum[]
    having?: SalesOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesOrderCountAggregateInputType | true
    _avg?: SalesOrderAvgAggregateInputType
    _sum?: SalesOrderSumAggregateInputType
    _min?: SalesOrderMinAggregateInputType
    _max?: SalesOrderMaxAggregateInputType
  }


  export type SalesOrderGroupByOutputType = {
    id: number
    salesOrderNo: string | null
    customerId: number
    userId: number | null
    remarks: string | null
    total: number
    createdAt: Date
    updatedAt: Date
    _count: SalesOrderCountAggregateOutputType | null
    _avg: SalesOrderAvgAggregateOutputType | null
    _sum: SalesOrderSumAggregateOutputType | null
    _min: SalesOrderMinAggregateOutputType | null
    _max: SalesOrderMaxAggregateOutputType | null
  }

  type GetSalesOrderGroupByPayload<T extends SalesOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SalesOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesOrderGroupByOutputType[P]>
            : GetScalarType<T[P], SalesOrderGroupByOutputType[P]>
        }
      >
    >


  export type SalesOrderSelect = {
    id?: boolean
    salesOrderNo?: boolean
    customerId?: boolean
    userId?: boolean
    remarks?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | SalesOrder$ordersArgs
    customerName?: boolean | CustomerArgs
    User?: boolean | UserArgs
    _count?: boolean | SalesOrderCountOutputTypeArgs
  }


  export type SalesOrderInclude = {
    orders?: boolean | SalesOrder$ordersArgs
    customerName?: boolean | CustomerArgs
    User?: boolean | UserArgs
    _count?: boolean | SalesOrderCountOutputTypeArgs
  }

  export type SalesOrderGetPayload<S extends boolean | null | undefined | SalesOrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SalesOrder :
    S extends undefined ? never :
    S extends { include: any } & (SalesOrderArgs | SalesOrderFindManyArgs)
    ? SalesOrder  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'orders' ? Array < SalesItemsGetPayload<S['include'][P]>>  :
        P extends 'customerName' ? CustomerGetPayload<S['include'][P]> :
        P extends 'User' ? UserGetPayload<S['include'][P]> | null :
        P extends '_count' ? SalesOrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SalesOrderArgs | SalesOrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'orders' ? Array < SalesItemsGetPayload<S['select'][P]>>  :
        P extends 'customerName' ? CustomerGetPayload<S['select'][P]> :
        P extends 'User' ? UserGetPayload<S['select'][P]> | null :
        P extends '_count' ? SalesOrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SalesOrder ? SalesOrder[P] : never
  } 
      : SalesOrder


  type SalesOrderCountArgs = 
    Omit<SalesOrderFindManyArgs, 'select' | 'include'> & {
      select?: SalesOrderCountAggregateInputType | true
    }

  export interface SalesOrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SalesOrder that matches the filter.
     * @param {SalesOrderFindUniqueArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SalesOrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SalesOrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SalesOrder'> extends True ? Prisma__SalesOrderClient<SalesOrderGetPayload<T>> : Prisma__SalesOrderClient<SalesOrderGetPayload<T> | null, null>

    /**
     * Find one SalesOrder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SalesOrderFindUniqueOrThrowArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SalesOrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SalesOrderFindUniqueOrThrowArgs>
    ): Prisma__SalesOrderClient<SalesOrderGetPayload<T>>

    /**
     * Find the first SalesOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindFirstArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SalesOrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SalesOrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SalesOrder'> extends True ? Prisma__SalesOrderClient<SalesOrderGetPayload<T>> : Prisma__SalesOrderClient<SalesOrderGetPayload<T> | null, null>

    /**
     * Find the first SalesOrder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindFirstOrThrowArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SalesOrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SalesOrderFindFirstOrThrowArgs>
    ): Prisma__SalesOrderClient<SalesOrderGetPayload<T>>

    /**
     * Find zero or more SalesOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesOrders
     * const salesOrders = await prisma.salesOrder.findMany()
     * 
     * // Get first 10 SalesOrders
     * const salesOrders = await prisma.salesOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesOrderWithIdOnly = await prisma.salesOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SalesOrderFindManyArgs>(
      args?: SelectSubset<T, SalesOrderFindManyArgs>
    ): Prisma.PrismaPromise<Array<SalesOrderGetPayload<T>>>

    /**
     * Create a SalesOrder.
     * @param {SalesOrderCreateArgs} args - Arguments to create a SalesOrder.
     * @example
     * // Create one SalesOrder
     * const SalesOrder = await prisma.salesOrder.create({
     *   data: {
     *     // ... data to create a SalesOrder
     *   }
     * })
     * 
    **/
    create<T extends SalesOrderCreateArgs>(
      args: SelectSubset<T, SalesOrderCreateArgs>
    ): Prisma__SalesOrderClient<SalesOrderGetPayload<T>>

    /**
     * Create many SalesOrders.
     *     @param {SalesOrderCreateManyArgs} args - Arguments to create many SalesOrders.
     *     @example
     *     // Create many SalesOrders
     *     const salesOrder = await prisma.salesOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SalesOrderCreateManyArgs>(
      args?: SelectSubset<T, SalesOrderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SalesOrder.
     * @param {SalesOrderDeleteArgs} args - Arguments to delete one SalesOrder.
     * @example
     * // Delete one SalesOrder
     * const SalesOrder = await prisma.salesOrder.delete({
     *   where: {
     *     // ... filter to delete one SalesOrder
     *   }
     * })
     * 
    **/
    delete<T extends SalesOrderDeleteArgs>(
      args: SelectSubset<T, SalesOrderDeleteArgs>
    ): Prisma__SalesOrderClient<SalesOrderGetPayload<T>>

    /**
     * Update one SalesOrder.
     * @param {SalesOrderUpdateArgs} args - Arguments to update one SalesOrder.
     * @example
     * // Update one SalesOrder
     * const salesOrder = await prisma.salesOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SalesOrderUpdateArgs>(
      args: SelectSubset<T, SalesOrderUpdateArgs>
    ): Prisma__SalesOrderClient<SalesOrderGetPayload<T>>

    /**
     * Delete zero or more SalesOrders.
     * @param {SalesOrderDeleteManyArgs} args - Arguments to filter SalesOrders to delete.
     * @example
     * // Delete a few SalesOrders
     * const { count } = await prisma.salesOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SalesOrderDeleteManyArgs>(
      args?: SelectSubset<T, SalesOrderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesOrders
     * const salesOrder = await prisma.salesOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SalesOrderUpdateManyArgs>(
      args: SelectSubset<T, SalesOrderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesOrder.
     * @param {SalesOrderUpsertArgs} args - Arguments to update or create a SalesOrder.
     * @example
     * // Update or create a SalesOrder
     * const salesOrder = await prisma.salesOrder.upsert({
     *   create: {
     *     // ... data to create a SalesOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesOrder we want to update
     *   }
     * })
    **/
    upsert<T extends SalesOrderUpsertArgs>(
      args: SelectSubset<T, SalesOrderUpsertArgs>
    ): Prisma__SalesOrderClient<SalesOrderGetPayload<T>>

    /**
     * Count the number of SalesOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderCountArgs} args - Arguments to filter SalesOrders to count.
     * @example
     * // Count the number of SalesOrders
     * const count = await prisma.salesOrder.count({
     *   where: {
     *     // ... the filter for the SalesOrders we want to count
     *   }
     * })
    **/
    count<T extends SalesOrderCountArgs>(
      args?: Subset<T, SalesOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesOrderAggregateArgs>(args: Subset<T, SalesOrderAggregateArgs>): Prisma.PrismaPromise<GetSalesOrderAggregateType<T>>

    /**
     * Group by SalesOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesOrderGroupByArgs['orderBy'] }
        : { orderBy?: SalesOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SalesOrderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    orders<T extends SalesOrder$ordersArgs= {}>(args?: Subset<T, SalesOrder$ordersArgs>): Prisma.PrismaPromise<Array<SalesItemsGetPayload<T>>| Null>;

    customerName<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SalesOrder base type for findUnique actions
   */
  export type SalesOrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesOrderInclude | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder findUnique
   */
  export interface SalesOrderFindUniqueArgs extends SalesOrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SalesOrder findUniqueOrThrow
   */
  export type SalesOrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesOrderInclude | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where: SalesOrderWhereUniqueInput
  }


  /**
   * SalesOrder base type for findFirst actions
   */
  export type SalesOrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesOrderInclude | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: Enumerable<SalesOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrders.
     */
    distinct?: Enumerable<SalesOrderScalarFieldEnum>
  }

  /**
   * SalesOrder findFirst
   */
  export interface SalesOrderFindFirstArgs extends SalesOrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SalesOrder findFirstOrThrow
   */
  export type SalesOrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesOrderInclude | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: Enumerable<SalesOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrders.
     */
    distinct?: Enumerable<SalesOrderScalarFieldEnum>
  }


  /**
   * SalesOrder findMany
   */
  export type SalesOrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesOrderInclude | null
    /**
     * Filter, which SalesOrders to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: Enumerable<SalesOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    distinct?: Enumerable<SalesOrderScalarFieldEnum>
  }


  /**
   * SalesOrder create
   */
  export type SalesOrderCreateArgs = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesOrderInclude | null
    /**
     * The data needed to create a SalesOrder.
     */
    data: XOR<SalesOrderCreateInput, SalesOrderUncheckedCreateInput>
  }


  /**
   * SalesOrder createMany
   */
  export type SalesOrderCreateManyArgs = {
    /**
     * The data used to create many SalesOrders.
     */
    data: Enumerable<SalesOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SalesOrder update
   */
  export type SalesOrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesOrderInclude | null
    /**
     * The data needed to update a SalesOrder.
     */
    data: XOR<SalesOrderUpdateInput, SalesOrderUncheckedUpdateInput>
    /**
     * Choose, which SalesOrder to update.
     */
    where: SalesOrderWhereUniqueInput
  }


  /**
   * SalesOrder updateMany
   */
  export type SalesOrderUpdateManyArgs = {
    /**
     * The data used to update SalesOrders.
     */
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyInput>
    /**
     * Filter which SalesOrders to update
     */
    where?: SalesOrderWhereInput
  }


  /**
   * SalesOrder upsert
   */
  export type SalesOrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesOrderInclude | null
    /**
     * The filter to search for the SalesOrder to update in case it exists.
     */
    where: SalesOrderWhereUniqueInput
    /**
     * In case the SalesOrder found by the `where` argument doesn't exist, create a new SalesOrder with this data.
     */
    create: XOR<SalesOrderCreateInput, SalesOrderUncheckedCreateInput>
    /**
     * In case the SalesOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesOrderUpdateInput, SalesOrderUncheckedUpdateInput>
  }


  /**
   * SalesOrder delete
   */
  export type SalesOrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesOrderInclude | null
    /**
     * Filter which SalesOrder to delete.
     */
    where: SalesOrderWhereUniqueInput
  }


  /**
   * SalesOrder deleteMany
   */
  export type SalesOrderDeleteManyArgs = {
    /**
     * Filter which SalesOrders to delete
     */
    where?: SalesOrderWhereInput
  }


  /**
   * SalesOrder.orders
   */
  export type SalesOrder$ordersArgs = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesItemsInclude | null
    where?: SalesItemsWhereInput
    orderBy?: Enumerable<SalesItemsOrderByWithRelationInput>
    cursor?: SalesItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesItemsScalarFieldEnum>
  }


  /**
   * SalesOrder without action
   */
  export type SalesOrderArgs = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesOrderInclude | null
  }



  /**
   * Model SalesItems
   */


  export type AggregateSalesItems = {
    _count: SalesItemsCountAggregateOutputType | null
    _avg: SalesItemsAvgAggregateOutputType | null
    _sum: SalesItemsSumAggregateOutputType | null
    _min: SalesItemsMinAggregateOutputType | null
    _max: SalesItemsMaxAggregateOutputType | null
  }

  export type SalesItemsAvgAggregateOutputType = {
    id: number | null
    salesOrderId: number | null
    productId: number | null
    quantity: number | null
    sellingPrice: number | null
    total: number | null
  }

  export type SalesItemsSumAggregateOutputType = {
    id: number | null
    salesOrderId: number | null
    productId: number | null
    quantity: number | null
    sellingPrice: number | null
    total: number | null
  }

  export type SalesItemsMinAggregateOutputType = {
    id: number | null
    salesOrderId: number | null
    productId: number | null
    quantity: number | null
    sellingPrice: number | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesItemsMaxAggregateOutputType = {
    id: number | null
    salesOrderId: number | null
    productId: number | null
    quantity: number | null
    sellingPrice: number | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesItemsCountAggregateOutputType = {
    id: number
    salesOrderId: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesItemsAvgAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    quantity?: true
    sellingPrice?: true
    total?: true
  }

  export type SalesItemsSumAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    quantity?: true
    sellingPrice?: true
    total?: true
  }

  export type SalesItemsMinAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    quantity?: true
    sellingPrice?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesItemsMaxAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    quantity?: true
    sellingPrice?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesItemsCountAggregateInputType = {
    id?: true
    salesOrderId?: true
    productId?: true
    quantity?: true
    sellingPrice?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesItemsAggregateArgs = {
    /**
     * Filter which SalesItems to aggregate.
     */
    where?: SalesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesItems to fetch.
     */
    orderBy?: Enumerable<SalesItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesItems
    **/
    _count?: true | SalesItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesItemsMaxAggregateInputType
  }

  export type GetSalesItemsAggregateType<T extends SalesItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesItems[P]>
      : GetScalarType<T[P], AggregateSalesItems[P]>
  }




  export type SalesItemsGroupByArgs = {
    where?: SalesItemsWhereInput
    orderBy?: Enumerable<SalesItemsOrderByWithAggregationInput>
    by: SalesItemsScalarFieldEnum[]
    having?: SalesItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesItemsCountAggregateInputType | true
    _avg?: SalesItemsAvgAggregateInputType
    _sum?: SalesItemsSumAggregateInputType
    _min?: SalesItemsMinAggregateInputType
    _max?: SalesItemsMaxAggregateInputType
  }


  export type SalesItemsGroupByOutputType = {
    id: number
    salesOrderId: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt: Date
    updatedAt: Date
    _count: SalesItemsCountAggregateOutputType | null
    _avg: SalesItemsAvgAggregateOutputType | null
    _sum: SalesItemsSumAggregateOutputType | null
    _min: SalesItemsMinAggregateOutputType | null
    _max: SalesItemsMaxAggregateOutputType | null
  }

  type GetSalesItemsGroupByPayload<T extends SalesItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SalesItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesItemsGroupByOutputType[P]>
            : GetScalarType<T[P], SalesItemsGroupByOutputType[P]>
        }
      >
    >


  export type SalesItemsSelect = {
    id?: boolean
    salesOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    sellingPrice?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salesOrder?: boolean | SalesOrderArgs
    product?: boolean | ProductArgs
  }


  export type SalesItemsInclude = {
    salesOrder?: boolean | SalesOrderArgs
    product?: boolean | ProductArgs
  }

  export type SalesItemsGetPayload<S extends boolean | null | undefined | SalesItemsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SalesItems :
    S extends undefined ? never :
    S extends { include: any } & (SalesItemsArgs | SalesItemsFindManyArgs)
    ? SalesItems  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'salesOrder' ? SalesOrderGetPayload<S['include'][P]> :
        P extends 'product' ? ProductGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SalesItemsArgs | SalesItemsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'salesOrder' ? SalesOrderGetPayload<S['select'][P]> :
        P extends 'product' ? ProductGetPayload<S['select'][P]> :  P extends keyof SalesItems ? SalesItems[P] : never
  } 
      : SalesItems


  type SalesItemsCountArgs = 
    Omit<SalesItemsFindManyArgs, 'select' | 'include'> & {
      select?: SalesItemsCountAggregateInputType | true
    }

  export interface SalesItemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SalesItems that matches the filter.
     * @param {SalesItemsFindUniqueArgs} args - Arguments to find a SalesItems
     * @example
     * // Get one SalesItems
     * const salesItems = await prisma.salesItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SalesItemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SalesItemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SalesItems'> extends True ? Prisma__SalesItemsClient<SalesItemsGetPayload<T>> : Prisma__SalesItemsClient<SalesItemsGetPayload<T> | null, null>

    /**
     * Find one SalesItems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SalesItemsFindUniqueOrThrowArgs} args - Arguments to find a SalesItems
     * @example
     * // Get one SalesItems
     * const salesItems = await prisma.salesItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SalesItemsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SalesItemsFindUniqueOrThrowArgs>
    ): Prisma__SalesItemsClient<SalesItemsGetPayload<T>>

    /**
     * Find the first SalesItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsFindFirstArgs} args - Arguments to find a SalesItems
     * @example
     * // Get one SalesItems
     * const salesItems = await prisma.salesItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SalesItemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SalesItemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SalesItems'> extends True ? Prisma__SalesItemsClient<SalesItemsGetPayload<T>> : Prisma__SalesItemsClient<SalesItemsGetPayload<T> | null, null>

    /**
     * Find the first SalesItems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsFindFirstOrThrowArgs} args - Arguments to find a SalesItems
     * @example
     * // Get one SalesItems
     * const salesItems = await prisma.salesItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SalesItemsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SalesItemsFindFirstOrThrowArgs>
    ): Prisma__SalesItemsClient<SalesItemsGetPayload<T>>

    /**
     * Find zero or more SalesItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesItems
     * const salesItems = await prisma.salesItems.findMany()
     * 
     * // Get first 10 SalesItems
     * const salesItems = await prisma.salesItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesItemsWithIdOnly = await prisma.salesItems.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SalesItemsFindManyArgs>(
      args?: SelectSubset<T, SalesItemsFindManyArgs>
    ): Prisma.PrismaPromise<Array<SalesItemsGetPayload<T>>>

    /**
     * Create a SalesItems.
     * @param {SalesItemsCreateArgs} args - Arguments to create a SalesItems.
     * @example
     * // Create one SalesItems
     * const SalesItems = await prisma.salesItems.create({
     *   data: {
     *     // ... data to create a SalesItems
     *   }
     * })
     * 
    **/
    create<T extends SalesItemsCreateArgs>(
      args: SelectSubset<T, SalesItemsCreateArgs>
    ): Prisma__SalesItemsClient<SalesItemsGetPayload<T>>

    /**
     * Create many SalesItems.
     *     @param {SalesItemsCreateManyArgs} args - Arguments to create many SalesItems.
     *     @example
     *     // Create many SalesItems
     *     const salesItems = await prisma.salesItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SalesItemsCreateManyArgs>(
      args?: SelectSubset<T, SalesItemsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SalesItems.
     * @param {SalesItemsDeleteArgs} args - Arguments to delete one SalesItems.
     * @example
     * // Delete one SalesItems
     * const SalesItems = await prisma.salesItems.delete({
     *   where: {
     *     // ... filter to delete one SalesItems
     *   }
     * })
     * 
    **/
    delete<T extends SalesItemsDeleteArgs>(
      args: SelectSubset<T, SalesItemsDeleteArgs>
    ): Prisma__SalesItemsClient<SalesItemsGetPayload<T>>

    /**
     * Update one SalesItems.
     * @param {SalesItemsUpdateArgs} args - Arguments to update one SalesItems.
     * @example
     * // Update one SalesItems
     * const salesItems = await prisma.salesItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SalesItemsUpdateArgs>(
      args: SelectSubset<T, SalesItemsUpdateArgs>
    ): Prisma__SalesItemsClient<SalesItemsGetPayload<T>>

    /**
     * Delete zero or more SalesItems.
     * @param {SalesItemsDeleteManyArgs} args - Arguments to filter SalesItems to delete.
     * @example
     * // Delete a few SalesItems
     * const { count } = await prisma.salesItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SalesItemsDeleteManyArgs>(
      args?: SelectSubset<T, SalesItemsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesItems
     * const salesItems = await prisma.salesItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SalesItemsUpdateManyArgs>(
      args: SelectSubset<T, SalesItemsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesItems.
     * @param {SalesItemsUpsertArgs} args - Arguments to update or create a SalesItems.
     * @example
     * // Update or create a SalesItems
     * const salesItems = await prisma.salesItems.upsert({
     *   create: {
     *     // ... data to create a SalesItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesItems we want to update
     *   }
     * })
    **/
    upsert<T extends SalesItemsUpsertArgs>(
      args: SelectSubset<T, SalesItemsUpsertArgs>
    ): Prisma__SalesItemsClient<SalesItemsGetPayload<T>>

    /**
     * Count the number of SalesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsCountArgs} args - Arguments to filter SalesItems to count.
     * @example
     * // Count the number of SalesItems
     * const count = await prisma.salesItems.count({
     *   where: {
     *     // ... the filter for the SalesItems we want to count
     *   }
     * })
    **/
    count<T extends SalesItemsCountArgs>(
      args?: Subset<T, SalesItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesItemsAggregateArgs>(args: Subset<T, SalesItemsAggregateArgs>): Prisma.PrismaPromise<GetSalesItemsAggregateType<T>>

    /**
     * Group by SalesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesItemsGroupByArgs['orderBy'] }
        : { orderBy?: SalesItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SalesItemsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    salesOrder<T extends SalesOrderArgs= {}>(args?: Subset<T, SalesOrderArgs>): Prisma__SalesOrderClient<SalesOrderGetPayload<T> | Null>;

    product<T extends ProductArgs= {}>(args?: Subset<T, ProductArgs>): Prisma__ProductClient<ProductGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SalesItems base type for findUnique actions
   */
  export type SalesItemsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesItemsInclude | null
    /**
     * Filter, which SalesItems to fetch.
     */
    where: SalesItemsWhereUniqueInput
  }

  /**
   * SalesItems findUnique
   */
  export interface SalesItemsFindUniqueArgs extends SalesItemsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SalesItems findUniqueOrThrow
   */
  export type SalesItemsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesItemsInclude | null
    /**
     * Filter, which SalesItems to fetch.
     */
    where: SalesItemsWhereUniqueInput
  }


  /**
   * SalesItems base type for findFirst actions
   */
  export type SalesItemsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesItemsInclude | null
    /**
     * Filter, which SalesItems to fetch.
     */
    where?: SalesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesItems to fetch.
     */
    orderBy?: Enumerable<SalesItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesItems.
     */
    cursor?: SalesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesItems.
     */
    distinct?: Enumerable<SalesItemsScalarFieldEnum>
  }

  /**
   * SalesItems findFirst
   */
  export interface SalesItemsFindFirstArgs extends SalesItemsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SalesItems findFirstOrThrow
   */
  export type SalesItemsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesItemsInclude | null
    /**
     * Filter, which SalesItems to fetch.
     */
    where?: SalesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesItems to fetch.
     */
    orderBy?: Enumerable<SalesItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesItems.
     */
    cursor?: SalesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesItems.
     */
    distinct?: Enumerable<SalesItemsScalarFieldEnum>
  }


  /**
   * SalesItems findMany
   */
  export type SalesItemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesItemsInclude | null
    /**
     * Filter, which SalesItems to fetch.
     */
    where?: SalesItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesItems to fetch.
     */
    orderBy?: Enumerable<SalesItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesItems.
     */
    cursor?: SalesItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesItems.
     */
    skip?: number
    distinct?: Enumerable<SalesItemsScalarFieldEnum>
  }


  /**
   * SalesItems create
   */
  export type SalesItemsCreateArgs = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesItemsInclude | null
    /**
     * The data needed to create a SalesItems.
     */
    data: XOR<SalesItemsCreateInput, SalesItemsUncheckedCreateInput>
  }


  /**
   * SalesItems createMany
   */
  export type SalesItemsCreateManyArgs = {
    /**
     * The data used to create many SalesItems.
     */
    data: Enumerable<SalesItemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SalesItems update
   */
  export type SalesItemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesItemsInclude | null
    /**
     * The data needed to update a SalesItems.
     */
    data: XOR<SalesItemsUpdateInput, SalesItemsUncheckedUpdateInput>
    /**
     * Choose, which SalesItems to update.
     */
    where: SalesItemsWhereUniqueInput
  }


  /**
   * SalesItems updateMany
   */
  export type SalesItemsUpdateManyArgs = {
    /**
     * The data used to update SalesItems.
     */
    data: XOR<SalesItemsUpdateManyMutationInput, SalesItemsUncheckedUpdateManyInput>
    /**
     * Filter which SalesItems to update
     */
    where?: SalesItemsWhereInput
  }


  /**
   * SalesItems upsert
   */
  export type SalesItemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesItemsInclude | null
    /**
     * The filter to search for the SalesItems to update in case it exists.
     */
    where: SalesItemsWhereUniqueInput
    /**
     * In case the SalesItems found by the `where` argument doesn't exist, create a new SalesItems with this data.
     */
    create: XOR<SalesItemsCreateInput, SalesItemsUncheckedCreateInput>
    /**
     * In case the SalesItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesItemsUpdateInput, SalesItemsUncheckedUpdateInput>
  }


  /**
   * SalesItems delete
   */
  export type SalesItemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesItemsInclude | null
    /**
     * Filter which SalesItems to delete.
     */
    where: SalesItemsWhereUniqueInput
  }


  /**
   * SalesItems deleteMany
   */
  export type SalesItemsDeleteManyArgs = {
    /**
     * Filter which SalesItems to delete
     */
    where?: SalesItemsWhereInput
  }


  /**
   * SalesItems without action
   */
  export type SalesItemsArgs = {
    /**
     * Select specific fields to fetch from the SalesItems
     */
    select?: SalesItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesItemsInclude | null
  }



  /**
   * Model Vendor
   */


  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    id: number | null
  }

  export type VendorSumAggregateOutputType = {
    id: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    id?: true
  }

  export type VendorSumAggregateInputType = {
    id?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs = {
    where?: VendorWhereInput
    orderBy?: Enumerable<VendorOrderByWithAggregationInput>
    by: VendorScalarFieldEnum[]
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }


  export type VendorGroupByOutputType = {
    id: number
    name: string
    address: string | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    PurchaseOrder?: boolean | Vendor$PurchaseOrderArgs
    _count?: boolean | VendorCountOutputTypeArgs
  }


  export type VendorInclude = {
    PurchaseOrder?: boolean | Vendor$PurchaseOrderArgs
    _count?: boolean | VendorCountOutputTypeArgs
  }

  export type VendorGetPayload<S extends boolean | null | undefined | VendorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Vendor :
    S extends undefined ? never :
    S extends { include: any } & (VendorArgs | VendorFindManyArgs)
    ? Vendor  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'PurchaseOrder' ? Array < PurchaseOrderGetPayload<S['include'][P]>>  :
        P extends '_count' ? VendorCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (VendorArgs | VendorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'PurchaseOrder' ? Array < PurchaseOrderGetPayload<S['select'][P]>>  :
        P extends '_count' ? VendorCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Vendor ? Vendor[P] : never
  } 
      : Vendor


  type VendorCountArgs = 
    Omit<VendorFindManyArgs, 'select' | 'include'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VendorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VendorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vendor'> extends True ? Prisma__VendorClient<VendorGetPayload<T>> : Prisma__VendorClient<VendorGetPayload<T> | null, null>

    /**
     * Find one Vendor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VendorFindUniqueOrThrowArgs>
    ): Prisma__VendorClient<VendorGetPayload<T>>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VendorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VendorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vendor'> extends True ? Prisma__VendorClient<VendorGetPayload<T>> : Prisma__VendorClient<VendorGetPayload<T> | null, null>

    /**
     * Find the first Vendor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VendorFindFirstOrThrowArgs>
    ): Prisma__VendorClient<VendorGetPayload<T>>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VendorFindManyArgs>(
      args?: SelectSubset<T, VendorFindManyArgs>
    ): Prisma.PrismaPromise<Array<VendorGetPayload<T>>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
    **/
    create<T extends VendorCreateArgs>(
      args: SelectSubset<T, VendorCreateArgs>
    ): Prisma__VendorClient<VendorGetPayload<T>>

    /**
     * Create many Vendors.
     *     @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     *     @example
     *     // Create many Vendors
     *     const vendor = await prisma.vendor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VendorCreateManyArgs>(
      args?: SelectSubset<T, VendorCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
    **/
    delete<T extends VendorDeleteArgs>(
      args: SelectSubset<T, VendorDeleteArgs>
    ): Prisma__VendorClient<VendorGetPayload<T>>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VendorUpdateArgs>(
      args: SelectSubset<T, VendorUpdateArgs>
    ): Prisma__VendorClient<VendorGetPayload<T>>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VendorDeleteManyArgs>(
      args?: SelectSubset<T, VendorDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VendorUpdateManyArgs>(
      args: SelectSubset<T, VendorUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
    **/
    upsert<T extends VendorUpsertArgs>(
      args: SelectSubset<T, VendorUpsertArgs>
    ): Prisma__VendorClient<VendorGetPayload<T>>

    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VendorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    PurchaseOrder<T extends Vendor$PurchaseOrderArgs= {}>(args?: Subset<T, Vendor$PurchaseOrderArgs>): Prisma.PrismaPromise<Array<PurchaseOrderGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Vendor base type for findUnique actions
   */
  export type VendorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUnique
   */
  export interface VendorFindUniqueArgs extends VendorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor base type for findFirst actions
   */
  export type VendorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: Enumerable<VendorScalarFieldEnum>
  }

  /**
   * Vendor findFirst
   */
  export interface VendorFindFirstArgs extends VendorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: Enumerable<VendorScalarFieldEnum>
  }


  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: Enumerable<VendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: Enumerable<VendorScalarFieldEnum>
  }


  /**
   * Vendor create
   */
  export type VendorCreateArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }


  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs = {
    /**
     * The data used to create many Vendors.
     */
    data: Enumerable<VendorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vendor update
   */
  export type VendorUpdateArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
  }


  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }


  /**
   * Vendor delete
   */
  export type VendorDeleteArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }


  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
  }


  /**
   * Vendor.PurchaseOrder
   */
  export type Vendor$PurchaseOrderArgs = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PurchaseOrderInclude | null
    where?: PurchaseOrderWhereInput
    orderBy?: Enumerable<PurchaseOrderOrderByWithRelationInput>
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PurchaseOrderScalarFieldEnum>
  }


  /**
   * Vendor without action
   */
  export type VendorArgs = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VendorInclude | null
  }



  /**
   * Model Customer
   */


  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs = {
    where?: CustomerWhereInput
    orderBy?: Enumerable<CustomerOrderByWithAggregationInput>
    by: CustomerScalarFieldEnum[]
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }


  export type CustomerGroupByOutputType = {
    id: number
    name: string
    address: string | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SalesOrder?: boolean | Customer$SalesOrderArgs
    _count?: boolean | CustomerCountOutputTypeArgs
  }


  export type CustomerInclude = {
    SalesOrder?: boolean | Customer$SalesOrderArgs
    _count?: boolean | CustomerCountOutputTypeArgs
  }

  export type CustomerGetPayload<S extends boolean | null | undefined | CustomerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Customer :
    S extends undefined ? never :
    S extends { include: any } & (CustomerArgs | CustomerFindManyArgs)
    ? Customer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'SalesOrder' ? Array < SalesOrderGetPayload<S['include'][P]>>  :
        P extends '_count' ? CustomerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomerArgs | CustomerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'SalesOrder' ? Array < SalesOrderGetPayload<S['select'][P]>>  :
        P extends '_count' ? CustomerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Customer ? Customer[P] : never
  } 
      : Customer


  type CustomerCountArgs = 
    Omit<CustomerFindManyArgs, 'select' | 'include'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customer'> extends True ? Prisma__CustomerClient<CustomerGetPayload<T>> : Prisma__CustomerClient<CustomerGetPayload<T> | null, null>

    /**
     * Find one Customer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindUniqueOrThrowArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customer'> extends True ? Prisma__CustomerClient<CustomerGetPayload<T>> : Prisma__CustomerClient<CustomerGetPayload<T> | null, null>

    /**
     * Find the first Customer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindFirstOrThrowArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerFindManyArgs>(
      args?: SelectSubset<T, CustomerFindManyArgs>
    ): Prisma.PrismaPromise<Array<CustomerGetPayload<T>>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends CustomerCreateArgs>(
      args: SelectSubset<T, CustomerCreateArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Create many Customers.
     *     @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customer = await prisma.customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerCreateManyArgs>(
      args?: SelectSubset<T, CustomerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeleteArgs>(
      args: SelectSubset<T, CustomerDeleteArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerUpdateArgs>(
      args: SelectSubset<T, CustomerUpdateArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeleteManyArgs>(
      args?: SelectSubset<T, CustomerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerUpdateManyArgs>(
      args: SelectSubset<T, CustomerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerUpsertArgs>(
      args: SelectSubset<T, CustomerUpsertArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    SalesOrder<T extends Customer$SalesOrderArgs= {}>(args?: Subset<T, Customer$SalesOrderArgs>): Prisma.PrismaPromise<Array<SalesOrderGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Customer base type for findUnique actions
   */
  export type CustomerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUnique
   */
  export interface CustomerFindUniqueArgs extends CustomerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer base type for findFirst actions
   */
  export type CustomerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }

  /**
   * Customer findFirst
   */
  export interface CustomerFindFirstArgs extends CustomerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer create
   */
  export type CustomerCreateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }


  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs = {
    /**
     * The data used to create many Customers.
     */
    data: Enumerable<CustomerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customer update
   */
  export type CustomerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }


  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }


  /**
   * Customer delete
   */
  export type CustomerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }


  /**
   * Customer.SalesOrder
   */
  export type Customer$SalesOrderArgs = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SalesOrderInclude | null
    where?: SalesOrderWhereInput
    orderBy?: Enumerable<SalesOrderOrderByWithRelationInput>
    cursor?: SalesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SalesOrderScalarFieldEnum>
  }


  /**
   * Customer without action
   */
  export type CustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
  }



  /**
   * Model Roles
   */


  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RolesAggregateArgs = {
    /**
     * Filter which Roles to aggregate.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs = {
    where?: RolesWhereInput
    orderBy?: Enumerable<RolesOrderByWithAggregationInput>
    by: RolesScalarFieldEnum[]
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }


  export type RolesGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    UserRoles?: boolean | Roles$UserRolesArgs
    _count?: boolean | RolesCountOutputTypeArgs
  }


  export type RolesInclude = {
    UserRoles?: boolean | Roles$UserRolesArgs
    _count?: boolean | RolesCountOutputTypeArgs
  }

  export type RolesGetPayload<S extends boolean | null | undefined | RolesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Roles :
    S extends undefined ? never :
    S extends { include: any } & (RolesArgs | RolesFindManyArgs)
    ? Roles  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'UserRoles' ? Array < UserRolesGetPayload<S['include'][P]>>  :
        P extends '_count' ? RolesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RolesArgs | RolesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'UserRoles' ? Array < UserRolesGetPayload<S['select'][P]>>  :
        P extends '_count' ? RolesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Roles ? Roles[P] : never
  } 
      : Roles


  type RolesCountArgs = 
    Omit<RolesFindManyArgs, 'select' | 'include'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface RolesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RolesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Roles'> extends True ? Prisma__RolesClient<RolesGetPayload<T>> : Prisma__RolesClient<RolesGetPayload<T> | null, null>

    /**
     * Find one Roles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RolesFindUniqueOrThrowArgs>
    ): Prisma__RolesClient<RolesGetPayload<T>>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RolesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Roles'> extends True ? Prisma__RolesClient<RolesGetPayload<T>> : Prisma__RolesClient<RolesGetPayload<T> | null, null>

    /**
     * Find the first Roles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RolesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RolesFindFirstOrThrowArgs>
    ): Prisma__RolesClient<RolesGetPayload<T>>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RolesFindManyArgs>(
      args?: SelectSubset<T, RolesFindManyArgs>
    ): Prisma.PrismaPromise<Array<RolesGetPayload<T>>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
    **/
    create<T extends RolesCreateArgs>(
      args: SelectSubset<T, RolesCreateArgs>
    ): Prisma__RolesClient<RolesGetPayload<T>>

    /**
     * Create many Roles.
     *     @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const roles = await prisma.roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolesCreateManyArgs>(
      args?: SelectSubset<T, RolesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
    **/
    delete<T extends RolesDeleteArgs>(
      args: SelectSubset<T, RolesDeleteArgs>
    ): Prisma__RolesClient<RolesGetPayload<T>>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolesUpdateArgs>(
      args: SelectSubset<T, RolesUpdateArgs>
    ): Prisma__RolesClient<RolesGetPayload<T>>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolesDeleteManyArgs>(
      args?: SelectSubset<T, RolesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolesUpdateManyArgs>(
      args: SelectSubset<T, RolesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
    **/
    upsert<T extends RolesUpsertArgs>(
      args: SelectSubset<T, RolesUpsertArgs>
    ): Prisma__RolesClient<RolesGetPayload<T>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RolesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    UserRoles<T extends Roles$UserRolesArgs= {}>(args?: Subset<T, Roles$UserRolesArgs>): Prisma.PrismaPromise<Array<UserRolesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Roles base type for findUnique actions
   */
  export type RolesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findUnique
   */
  export interface RolesFindUniqueArgs extends RolesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Roles findUniqueOrThrow
   */
  export type RolesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }


  /**
   * Roles base type for findFirst actions
   */
  export type RolesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RolesScalarFieldEnum>
  }

  /**
   * Roles findFirst
   */
  export interface RolesFindFirstArgs extends RolesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Roles findFirstOrThrow
   */
  export type RolesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RolesScalarFieldEnum>
  }


  /**
   * Roles findMany
   */
  export type RolesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: Enumerable<RolesScalarFieldEnum>
  }


  /**
   * Roles create
   */
  export type RolesCreateArgs = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude | null
    /**
     * The data needed to create a Roles.
     */
    data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }


  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs = {
    /**
     * The data used to create many Roles.
     */
    data: Enumerable<RolesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Roles update
   */
  export type RolesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude | null
    /**
     * The data needed to update a Roles.
     */
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     */
    where: RolesWhereUniqueInput
  }


  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
  }


  /**
   * Roles upsert
   */
  export type RolesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude | null
    /**
     * The filter to search for the Roles to update in case it exists.
     */
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     */
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }


  /**
   * Roles delete
   */
  export type RolesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude | null
    /**
     * Filter which Roles to delete.
     */
    where: RolesWhereUniqueInput
  }


  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     */
    where?: RolesWhereInput
  }


  /**
   * Roles.UserRoles
   */
  export type Roles$UserRolesArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude | null
    where?: UserRolesWhereInput
    orderBy?: Enumerable<UserRolesOrderByWithRelationInput>
    cursor?: UserRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserRolesScalarFieldEnum>
  }


  /**
   * Roles without action
   */
  export type RolesArgs = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude | null
  }



  /**
   * Model UserRoles
   */


  export type AggregateUserRoles = {
    _count: UserRolesCountAggregateOutputType | null
    _avg: UserRolesAvgAggregateOutputType | null
    _sum: UserRolesSumAggregateOutputType | null
    _min: UserRolesMinAggregateOutputType | null
    _max: UserRolesMaxAggregateOutputType | null
  }

  export type UserRolesAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type UserRolesSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type UserRolesMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserRolesMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserRolesCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserRolesAvgAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserRolesSumAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserRolesMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserRolesMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserRolesCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserRolesAggregateArgs = {
    /**
     * Filter which UserRoles to aggregate.
     */
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: Enumerable<UserRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRolesMaxAggregateInputType
  }

  export type GetUserRolesAggregateType<T extends UserRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRoles[P]>
      : GetScalarType<T[P], AggregateUserRoles[P]>
  }




  export type UserRolesGroupByArgs = {
    where?: UserRolesWhereInput
    orderBy?: Enumerable<UserRolesOrderByWithAggregationInput>
    by: UserRolesScalarFieldEnum[]
    having?: UserRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRolesCountAggregateInputType | true
    _avg?: UserRolesAvgAggregateInputType
    _sum?: UserRolesSumAggregateInputType
    _min?: UserRolesMinAggregateInputType
    _max?: UserRolesMaxAggregateInputType
  }


  export type UserRolesGroupByOutputType = {
    id: number
    userId: number
    roleId: number
    createdAt: Date
    updatedAt: Date
    _count: UserRolesCountAggregateOutputType | null
    _avg: UserRolesAvgAggregateOutputType | null
    _sum: UserRolesSumAggregateOutputType | null
    _min: UserRolesMinAggregateOutputType | null
    _max: UserRolesMaxAggregateOutputType | null
  }

  type GetUserRolesGroupByPayload<T extends UserRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRolesGroupByOutputType[P]>
            : GetScalarType<T[P], UserRolesGroupByOutputType[P]>
        }
      >
    >


  export type UserRolesSelect = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    role?: boolean | RolesArgs
  }


  export type UserRolesInclude = {
    user?: boolean | UserArgs
    role?: boolean | RolesArgs
  }

  export type UserRolesGetPayload<S extends boolean | null | undefined | UserRolesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserRoles :
    S extends undefined ? never :
    S extends { include: any } & (UserRolesArgs | UserRolesFindManyArgs)
    ? UserRoles  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'role' ? RolesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserRolesArgs | UserRolesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'role' ? RolesGetPayload<S['select'][P]> :  P extends keyof UserRoles ? UserRoles[P] : never
  } 
      : UserRoles


  type UserRolesCountArgs = 
    Omit<UserRolesFindManyArgs, 'select' | 'include'> & {
      select?: UserRolesCountAggregateInputType | true
    }

  export interface UserRolesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserRoles that matches the filter.
     * @param {UserRolesFindUniqueArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserRolesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserRolesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserRoles'> extends True ? Prisma__UserRolesClient<UserRolesGetPayload<T>> : Prisma__UserRolesClient<UserRolesGetPayload<T> | null, null>

    /**
     * Find one UserRoles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserRolesFindUniqueOrThrowArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserRolesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserRolesFindUniqueOrThrowArgs>
    ): Prisma__UserRolesClient<UserRolesGetPayload<T>>

    /**
     * Find the first UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesFindFirstArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserRolesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserRolesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserRoles'> extends True ? Prisma__UserRolesClient<UserRolesGetPayload<T>> : Prisma__UserRolesClient<UserRolesGetPayload<T> | null, null>

    /**
     * Find the first UserRoles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesFindFirstOrThrowArgs} args - Arguments to find a UserRoles
     * @example
     * // Get one UserRoles
     * const userRoles = await prisma.userRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserRolesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserRolesFindFirstOrThrowArgs>
    ): Prisma__UserRolesClient<UserRolesGetPayload<T>>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRoles.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRoles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRolesWithIdOnly = await prisma.userRoles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserRolesFindManyArgs>(
      args?: SelectSubset<T, UserRolesFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserRolesGetPayload<T>>>

    /**
     * Create a UserRoles.
     * @param {UserRolesCreateArgs} args - Arguments to create a UserRoles.
     * @example
     * // Create one UserRoles
     * const UserRoles = await prisma.userRoles.create({
     *   data: {
     *     // ... data to create a UserRoles
     *   }
     * })
     * 
    **/
    create<T extends UserRolesCreateArgs>(
      args: SelectSubset<T, UserRolesCreateArgs>
    ): Prisma__UserRolesClient<UserRolesGetPayload<T>>

    /**
     * Create many UserRoles.
     *     @param {UserRolesCreateManyArgs} args - Arguments to create many UserRoles.
     *     @example
     *     // Create many UserRoles
     *     const userRoles = await prisma.userRoles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserRolesCreateManyArgs>(
      args?: SelectSubset<T, UserRolesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRoles.
     * @param {UserRolesDeleteArgs} args - Arguments to delete one UserRoles.
     * @example
     * // Delete one UserRoles
     * const UserRoles = await prisma.userRoles.delete({
     *   where: {
     *     // ... filter to delete one UserRoles
     *   }
     * })
     * 
    **/
    delete<T extends UserRolesDeleteArgs>(
      args: SelectSubset<T, UserRolesDeleteArgs>
    ): Prisma__UserRolesClient<UserRolesGetPayload<T>>

    /**
     * Update one UserRoles.
     * @param {UserRolesUpdateArgs} args - Arguments to update one UserRoles.
     * @example
     * // Update one UserRoles
     * const userRoles = await prisma.userRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserRolesUpdateArgs>(
      args: SelectSubset<T, UserRolesUpdateArgs>
    ): Prisma__UserRolesClient<UserRolesGetPayload<T>>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRolesDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserRolesDeleteManyArgs>(
      args?: SelectSubset<T, UserRolesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRoles = await prisma.userRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserRolesUpdateManyArgs>(
      args: SelectSubset<T, UserRolesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRoles.
     * @param {UserRolesUpsertArgs} args - Arguments to update or create a UserRoles.
     * @example
     * // Update or create a UserRoles
     * const userRoles = await prisma.userRoles.upsert({
     *   create: {
     *     // ... data to create a UserRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRoles we want to update
     *   }
     * })
    **/
    upsert<T extends UserRolesUpsertArgs>(
      args: SelectSubset<T, UserRolesUpsertArgs>
    ): Prisma__UserRolesClient<UserRolesGetPayload<T>>

    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRoles.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRolesCountArgs>(
      args?: Subset<T, UserRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRolesAggregateArgs>(args: Subset<T, UserRolesAggregateArgs>): Prisma.PrismaPromise<GetUserRolesAggregateType<T>>

    /**
     * Group by UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRolesGroupByArgs['orderBy'] }
        : { orderBy?: UserRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserRolesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    role<T extends RolesArgs= {}>(args?: Subset<T, RolesArgs>): Prisma__RolesClient<RolesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserRoles base type for findUnique actions
   */
  export type UserRolesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where: UserRolesWhereUniqueInput
  }

  /**
   * UserRoles findUnique
   */
  export interface UserRolesFindUniqueArgs extends UserRolesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserRoles findUniqueOrThrow
   */
  export type UserRolesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where: UserRolesWhereUniqueInput
  }


  /**
   * UserRoles base type for findFirst actions
   */
  export type UserRolesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: Enumerable<UserRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: Enumerable<UserRolesScalarFieldEnum>
  }

  /**
   * UserRoles findFirst
   */
  export interface UserRolesFindFirstArgs extends UserRolesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserRoles findFirstOrThrow
   */
  export type UserRolesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: Enumerable<UserRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: Enumerable<UserRolesScalarFieldEnum>
  }


  /**
   * UserRoles findMany
   */
  export type UserRolesFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: Enumerable<UserRolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: Enumerable<UserRolesScalarFieldEnum>
  }


  /**
   * UserRoles create
   */
  export type UserRolesCreateArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude | null
    /**
     * The data needed to create a UserRoles.
     */
    data: XOR<UserRolesCreateInput, UserRolesUncheckedCreateInput>
  }


  /**
   * UserRoles createMany
   */
  export type UserRolesCreateManyArgs = {
    /**
     * The data used to create many UserRoles.
     */
    data: Enumerable<UserRolesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserRoles update
   */
  export type UserRolesUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude | null
    /**
     * The data needed to update a UserRoles.
     */
    data: XOR<UserRolesUpdateInput, UserRolesUncheckedUpdateInput>
    /**
     * Choose, which UserRoles to update.
     */
    where: UserRolesWhereUniqueInput
  }


  /**
   * UserRoles updateMany
   */
  export type UserRolesUpdateManyArgs = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRolesUpdateManyMutationInput, UserRolesUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRolesWhereInput
  }


  /**
   * UserRoles upsert
   */
  export type UserRolesUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude | null
    /**
     * The filter to search for the UserRoles to update in case it exists.
     */
    where: UserRolesWhereUniqueInput
    /**
     * In case the UserRoles found by the `where` argument doesn't exist, create a new UserRoles with this data.
     */
    create: XOR<UserRolesCreateInput, UserRolesUncheckedCreateInput>
    /**
     * In case the UserRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRolesUpdateInput, UserRolesUncheckedUpdateInput>
  }


  /**
   * UserRoles delete
   */
  export type UserRolesDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude | null
    /**
     * Filter which UserRoles to delete.
     */
    where: UserRolesWhereUniqueInput
  }


  /**
   * UserRoles deleteMany
   */
  export type UserRolesDeleteManyArgs = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRolesWhereInput
  }


  /**
   * UserRoles without action
   */
  export type UserRolesArgs = {
    /**
     * Select specific fields to fetch from the UserRoles
     */
    select?: UserRolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRolesInclude | null
  }



  /**
   * Model UserTokens
   */


  export type AggregateUserTokens = {
    _count: UserTokensCountAggregateOutputType | null
    _avg: UserTokensAvgAggregateOutputType | null
    _sum: UserTokensSumAggregateOutputType | null
    _min: UserTokensMinAggregateOutputType | null
    _max: UserTokensMaxAggregateOutputType | null
  }

  export type UserTokensAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserTokensSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserTokensMinAggregateOutputType = {
    id: number | null
    userId: number | null
    expiry: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTokensMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    expiry: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTokensCountAggregateOutputType = {
    id: number
    userId: number
    expiry: number
    token: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserTokensAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserTokensSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserTokensMinAggregateInputType = {
    id?: true
    userId?: true
    expiry?: true
    token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTokensMaxAggregateInputType = {
    id?: true
    userId?: true
    expiry?: true
    token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTokensCountAggregateInputType = {
    id?: true
    userId?: true
    expiry?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserTokensAggregateArgs = {
    /**
     * Filter which UserTokens to aggregate.
     */
    where?: UserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTokens to fetch.
     */
    orderBy?: Enumerable<UserTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTokens
    **/
    _count?: true | UserTokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTokensMaxAggregateInputType
  }

  export type GetUserTokensAggregateType<T extends UserTokensAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTokens[P]>
      : GetScalarType<T[P], AggregateUserTokens[P]>
  }




  export type UserTokensGroupByArgs = {
    where?: UserTokensWhereInput
    orderBy?: Enumerable<UserTokensOrderByWithAggregationInput>
    by: UserTokensScalarFieldEnum[]
    having?: UserTokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTokensCountAggregateInputType | true
    _avg?: UserTokensAvgAggregateInputType
    _sum?: UserTokensSumAggregateInputType
    _min?: UserTokensMinAggregateInputType
    _max?: UserTokensMaxAggregateInputType
  }


  export type UserTokensGroupByOutputType = {
    id: number
    userId: number
    expiry: Date
    token: string
    createdAt: Date
    updatedAt: Date
    _count: UserTokensCountAggregateOutputType | null
    _avg: UserTokensAvgAggregateOutputType | null
    _sum: UserTokensSumAggregateOutputType | null
    _min: UserTokensMinAggregateOutputType | null
    _max: UserTokensMaxAggregateOutputType | null
  }

  type GetUserTokensGroupByPayload<T extends UserTokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserTokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTokensGroupByOutputType[P]>
            : GetScalarType<T[P], UserTokensGroupByOutputType[P]>
        }
      >
    >


  export type UserTokensSelect = {
    id?: boolean
    userId?: boolean
    expiry?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
  }


  export type UserTokensInclude = {
    user?: boolean | UserArgs
  }

  export type UserTokensGetPayload<S extends boolean | null | undefined | UserTokensArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserTokens :
    S extends undefined ? never :
    S extends { include: any } & (UserTokensArgs | UserTokensFindManyArgs)
    ? UserTokens  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserTokensArgs | UserTokensFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserTokens ? UserTokens[P] : never
  } 
      : UserTokens


  type UserTokensCountArgs = 
    Omit<UserTokensFindManyArgs, 'select' | 'include'> & {
      select?: UserTokensCountAggregateInputType | true
    }

  export interface UserTokensDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserTokens that matches the filter.
     * @param {UserTokensFindUniqueArgs} args - Arguments to find a UserTokens
     * @example
     * // Get one UserTokens
     * const userTokens = await prisma.userTokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserTokensFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserTokensFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserTokens'> extends True ? Prisma__UserTokensClient<UserTokensGetPayload<T>> : Prisma__UserTokensClient<UserTokensGetPayload<T> | null, null>

    /**
     * Find one UserTokens that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserTokensFindUniqueOrThrowArgs} args - Arguments to find a UserTokens
     * @example
     * // Get one UserTokens
     * const userTokens = await prisma.userTokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserTokensFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserTokensFindUniqueOrThrowArgs>
    ): Prisma__UserTokensClient<UserTokensGetPayload<T>>

    /**
     * Find the first UserTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensFindFirstArgs} args - Arguments to find a UserTokens
     * @example
     * // Get one UserTokens
     * const userTokens = await prisma.userTokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserTokensFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserTokensFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserTokens'> extends True ? Prisma__UserTokensClient<UserTokensGetPayload<T>> : Prisma__UserTokensClient<UserTokensGetPayload<T> | null, null>

    /**
     * Find the first UserTokens that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensFindFirstOrThrowArgs} args - Arguments to find a UserTokens
     * @example
     * // Get one UserTokens
     * const userTokens = await prisma.userTokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserTokensFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserTokensFindFirstOrThrowArgs>
    ): Prisma__UserTokensClient<UserTokensGetPayload<T>>

    /**
     * Find zero or more UserTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTokens
     * const userTokens = await prisma.userTokens.findMany()
     * 
     * // Get first 10 UserTokens
     * const userTokens = await prisma.userTokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTokensWithIdOnly = await prisma.userTokens.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserTokensFindManyArgs>(
      args?: SelectSubset<T, UserTokensFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserTokensGetPayload<T>>>

    /**
     * Create a UserTokens.
     * @param {UserTokensCreateArgs} args - Arguments to create a UserTokens.
     * @example
     * // Create one UserTokens
     * const UserTokens = await prisma.userTokens.create({
     *   data: {
     *     // ... data to create a UserTokens
     *   }
     * })
     * 
    **/
    create<T extends UserTokensCreateArgs>(
      args: SelectSubset<T, UserTokensCreateArgs>
    ): Prisma__UserTokensClient<UserTokensGetPayload<T>>

    /**
     * Create many UserTokens.
     *     @param {UserTokensCreateManyArgs} args - Arguments to create many UserTokens.
     *     @example
     *     // Create many UserTokens
     *     const userTokens = await prisma.userTokens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserTokensCreateManyArgs>(
      args?: SelectSubset<T, UserTokensCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserTokens.
     * @param {UserTokensDeleteArgs} args - Arguments to delete one UserTokens.
     * @example
     * // Delete one UserTokens
     * const UserTokens = await prisma.userTokens.delete({
     *   where: {
     *     // ... filter to delete one UserTokens
     *   }
     * })
     * 
    **/
    delete<T extends UserTokensDeleteArgs>(
      args: SelectSubset<T, UserTokensDeleteArgs>
    ): Prisma__UserTokensClient<UserTokensGetPayload<T>>

    /**
     * Update one UserTokens.
     * @param {UserTokensUpdateArgs} args - Arguments to update one UserTokens.
     * @example
     * // Update one UserTokens
     * const userTokens = await prisma.userTokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserTokensUpdateArgs>(
      args: SelectSubset<T, UserTokensUpdateArgs>
    ): Prisma__UserTokensClient<UserTokensGetPayload<T>>

    /**
     * Delete zero or more UserTokens.
     * @param {UserTokensDeleteManyArgs} args - Arguments to filter UserTokens to delete.
     * @example
     * // Delete a few UserTokens
     * const { count } = await prisma.userTokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserTokensDeleteManyArgs>(
      args?: SelectSubset<T, UserTokensDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTokens
     * const userTokens = await prisma.userTokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserTokensUpdateManyArgs>(
      args: SelectSubset<T, UserTokensUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTokens.
     * @param {UserTokensUpsertArgs} args - Arguments to update or create a UserTokens.
     * @example
     * // Update or create a UserTokens
     * const userTokens = await prisma.userTokens.upsert({
     *   create: {
     *     // ... data to create a UserTokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTokens we want to update
     *   }
     * })
    **/
    upsert<T extends UserTokensUpsertArgs>(
      args: SelectSubset<T, UserTokensUpsertArgs>
    ): Prisma__UserTokensClient<UserTokensGetPayload<T>>

    /**
     * Count the number of UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensCountArgs} args - Arguments to filter UserTokens to count.
     * @example
     * // Count the number of UserTokens
     * const count = await prisma.userTokens.count({
     *   where: {
     *     // ... the filter for the UserTokens we want to count
     *   }
     * })
    **/
    count<T extends UserTokensCountArgs>(
      args?: Subset<T, UserTokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTokensAggregateArgs>(args: Subset<T, UserTokensAggregateArgs>): Prisma.PrismaPromise<GetUserTokensAggregateType<T>>

    /**
     * Group by UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTokensGroupByArgs['orderBy'] }
        : { orderBy?: UserTokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserTokensClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserTokens base type for findUnique actions
   */
  export type UserTokensFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserTokens
     */
    select?: UserTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTokensInclude | null
    /**
     * Filter, which UserTokens to fetch.
     */
    where: UserTokensWhereUniqueInput
  }

  /**
   * UserTokens findUnique
   */
  export interface UserTokensFindUniqueArgs extends UserTokensFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserTokens findUniqueOrThrow
   */
  export type UserTokensFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     */
    select?: UserTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTokensInclude | null
    /**
     * Filter, which UserTokens to fetch.
     */
    where: UserTokensWhereUniqueInput
  }


  /**
   * UserTokens base type for findFirst actions
   */
  export type UserTokensFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserTokens
     */
    select?: UserTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTokensInclude | null
    /**
     * Filter, which UserTokens to fetch.
     */
    where?: UserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTokens to fetch.
     */
    orderBy?: Enumerable<UserTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTokens.
     */
    cursor?: UserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTokens.
     */
    distinct?: Enumerable<UserTokensScalarFieldEnum>
  }

  /**
   * UserTokens findFirst
   */
  export interface UserTokensFindFirstArgs extends UserTokensFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserTokens findFirstOrThrow
   */
  export type UserTokensFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     */
    select?: UserTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTokensInclude | null
    /**
     * Filter, which UserTokens to fetch.
     */
    where?: UserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTokens to fetch.
     */
    orderBy?: Enumerable<UserTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTokens.
     */
    cursor?: UserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTokens.
     */
    distinct?: Enumerable<UserTokensScalarFieldEnum>
  }


  /**
   * UserTokens findMany
   */
  export type UserTokensFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     */
    select?: UserTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTokensInclude | null
    /**
     * Filter, which UserTokens to fetch.
     */
    where?: UserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTokens to fetch.
     */
    orderBy?: Enumerable<UserTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTokens.
     */
    cursor?: UserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTokens.
     */
    skip?: number
    distinct?: Enumerable<UserTokensScalarFieldEnum>
  }


  /**
   * UserTokens create
   */
  export type UserTokensCreateArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     */
    select?: UserTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTokensInclude | null
    /**
     * The data needed to create a UserTokens.
     */
    data: XOR<UserTokensCreateInput, UserTokensUncheckedCreateInput>
  }


  /**
   * UserTokens createMany
   */
  export type UserTokensCreateManyArgs = {
    /**
     * The data used to create many UserTokens.
     */
    data: Enumerable<UserTokensCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserTokens update
   */
  export type UserTokensUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     */
    select?: UserTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTokensInclude | null
    /**
     * The data needed to update a UserTokens.
     */
    data: XOR<UserTokensUpdateInput, UserTokensUncheckedUpdateInput>
    /**
     * Choose, which UserTokens to update.
     */
    where: UserTokensWhereUniqueInput
  }


  /**
   * UserTokens updateMany
   */
  export type UserTokensUpdateManyArgs = {
    /**
     * The data used to update UserTokens.
     */
    data: XOR<UserTokensUpdateManyMutationInput, UserTokensUncheckedUpdateManyInput>
    /**
     * Filter which UserTokens to update
     */
    where?: UserTokensWhereInput
  }


  /**
   * UserTokens upsert
   */
  export type UserTokensUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     */
    select?: UserTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTokensInclude | null
    /**
     * The filter to search for the UserTokens to update in case it exists.
     */
    where: UserTokensWhereUniqueInput
    /**
     * In case the UserTokens found by the `where` argument doesn't exist, create a new UserTokens with this data.
     */
    create: XOR<UserTokensCreateInput, UserTokensUncheckedCreateInput>
    /**
     * In case the UserTokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTokensUpdateInput, UserTokensUncheckedUpdateInput>
  }


  /**
   * UserTokens delete
   */
  export type UserTokensDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     */
    select?: UserTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTokensInclude | null
    /**
     * Filter which UserTokens to delete.
     */
    where: UserTokensWhereUniqueInput
  }


  /**
   * UserTokens deleteMany
   */
  export type UserTokensDeleteManyArgs = {
    /**
     * Filter which UserTokens to delete
     */
    where?: UserTokensWhereInput
  }


  /**
   * UserTokens without action
   */
  export type UserTokensArgs = {
    /**
     * Select specific fields to fetch from the UserTokens
     */
    select?: UserTokensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserTokensInclude | null
  }



  /**
   * Enums
   */

  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    productName: 'productName',
    description: 'description',
    purchasePrice: 'purchasePrice',
    sellingPrice: 'sellingPrice',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const PurchaseItemsScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    productId: 'productId',
    quantity: 'quantity',
    purchasePrice: 'purchasePrice',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseItemsScalarFieldEnum = (typeof PurchaseItemsScalarFieldEnum)[keyof typeof PurchaseItemsScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    purchaseOrderNo: 'purchaseOrderNo',
    vendorId: 'vendorId',
    remarks: 'remarks',
    total: 'total',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const SalesItemsScalarFieldEnum: {
    id: 'id',
    salesOrderId: 'salesOrderId',
    productId: 'productId',
    quantity: 'quantity',
    sellingPrice: 'sellingPrice',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesItemsScalarFieldEnum = (typeof SalesItemsScalarFieldEnum)[keyof typeof SalesItemsScalarFieldEnum]


  export const SalesOrderScalarFieldEnum: {
    id: 'id',
    salesOrderNo: 'salesOrderNo',
    customerId: 'customerId',
    userId: 'userId',
    remarks: 'remarks',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesOrderScalarFieldEnum = (typeof SalesOrderScalarFieldEnum)[keyof typeof SalesOrderScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserRolesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserRolesScalarFieldEnum = (typeof UserRolesScalarFieldEnum)[keyof typeof UserRolesScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    address: 'address',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserTokensScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    expiry: 'expiry',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserTokensScalarFieldEnum = (typeof UserTokensScalarFieldEnum)[keyof typeof UserTokensScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    PurchaseOrder?: PurchaseOrderListRelationFilter
    SalesOrder?: SalesOrderListRelationFilter
    UserRoles?: UserRolesListRelationFilter
    UserTokens?: UserTokensListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    PurchaseOrder?: PurchaseOrderOrderByRelationAggregateInput
    SalesOrder?: SalesOrderOrderByRelationAggregateInput
    UserRoles?: UserRolesOrderByRelationAggregateInput
    UserTokens?: UserTokensOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    firstName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: IntFilter | number
    productName?: StringFilter | string
    description?: StringNullableFilter | string | null
    purchasePrice?: FloatFilter | number
    sellingPrice?: FloatFilter | number
    quantity?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    purchaseItems?: PurchaseItemsListRelationFilter
    salesItems?: SalesItemsListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    productName?: SortOrder
    description?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseItems?: PurchaseItemsOrderByRelationAggregateInput
    salesItems?: SalesItemsOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = {
    id?: number
    productName?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    productName?: SortOrder
    description?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productName?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    purchasePrice?: FloatWithAggregatesFilter | number
    sellingPrice?: FloatWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: Enumerable<PurchaseOrderWhereInput>
    OR?: Enumerable<PurchaseOrderWhereInput>
    NOT?: Enumerable<PurchaseOrderWhereInput>
    id?: IntFilter | number
    purchaseOrderNo?: StringNullableFilter | string | null
    vendorId?: IntFilter | number
    remarks?: StringNullableFilter | string | null
    total?: FloatFilter | number
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    orders?: PurchaseItemsListRelationFilter
    vendorName?: XOR<VendorRelationFilter, VendorWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderNo?: SortOrder
    vendorId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: PurchaseItemsOrderByRelationAggregateInput
    vendorName?: VendorOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PurchaseOrderWhereUniqueInput = {
    id?: number
  }

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderNo?: SortOrder
    vendorId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PurchaseOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<PurchaseOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PurchaseOrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    purchaseOrderNo?: StringNullableWithAggregatesFilter | string | null
    vendorId?: IntWithAggregatesFilter | number
    remarks?: StringNullableWithAggregatesFilter | string | null
    total?: FloatWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PurchaseItemsWhereInput = {
    AND?: Enumerable<PurchaseItemsWhereInput>
    OR?: Enumerable<PurchaseItemsWhereInput>
    NOT?: Enumerable<PurchaseItemsWhereInput>
    id?: IntFilter | number
    purchaseOrderId?: IntFilter | number
    productId?: IntFilter | number
    quantity?: IntFilter | number
    purchasePrice?: FloatFilter | number
    total?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    purchaseOrder?: XOR<PurchaseOrderRelationFilter, PurchaseOrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type PurchaseItemsOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type PurchaseItemsWhereUniqueInput = {
    id?: number
  }

  export type PurchaseItemsOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseItemsCountOrderByAggregateInput
    _avg?: PurchaseItemsAvgOrderByAggregateInput
    _max?: PurchaseItemsMaxOrderByAggregateInput
    _min?: PurchaseItemsMinOrderByAggregateInput
    _sum?: PurchaseItemsSumOrderByAggregateInput
  }

  export type PurchaseItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PurchaseItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PurchaseItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PurchaseItemsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    purchaseOrderId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
    purchasePrice?: FloatWithAggregatesFilter | number
    total?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SalesOrderWhereInput = {
    AND?: Enumerable<SalesOrderWhereInput>
    OR?: Enumerable<SalesOrderWhereInput>
    NOT?: Enumerable<SalesOrderWhereInput>
    id?: IntFilter | number
    salesOrderNo?: StringNullableFilter | string | null
    customerId?: IntFilter | number
    userId?: IntNullableFilter | number | null
    remarks?: StringNullableFilter | string | null
    total?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    orders?: SalesItemsListRelationFilter
    customerName?: XOR<CustomerRelationFilter, CustomerWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type SalesOrderOrderByWithRelationInput = {
    id?: SortOrder
    salesOrderNo?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: SalesItemsOrderByRelationAggregateInput
    customerName?: CustomerOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type SalesOrderWhereUniqueInput = {
    id?: number
  }

  export type SalesOrderOrderByWithAggregationInput = {
    id?: SortOrder
    salesOrderNo?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesOrderCountOrderByAggregateInput
    _avg?: SalesOrderAvgOrderByAggregateInput
    _max?: SalesOrderMaxOrderByAggregateInput
    _min?: SalesOrderMinOrderByAggregateInput
    _sum?: SalesOrderSumOrderByAggregateInput
  }

  export type SalesOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SalesOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<SalesOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SalesOrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    salesOrderNo?: StringNullableWithAggregatesFilter | string | null
    customerId?: IntWithAggregatesFilter | number
    userId?: IntNullableWithAggregatesFilter | number | null
    remarks?: StringNullableWithAggregatesFilter | string | null
    total?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SalesItemsWhereInput = {
    AND?: Enumerable<SalesItemsWhereInput>
    OR?: Enumerable<SalesItemsWhereInput>
    NOT?: Enumerable<SalesItemsWhereInput>
    id?: IntFilter | number
    salesOrderId?: IntFilter | number
    productId?: IntFilter | number
    quantity?: IntFilter | number
    sellingPrice?: FloatFilter | number
    total?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    salesOrder?: XOR<SalesOrderRelationFilter, SalesOrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type SalesItemsOrderByWithRelationInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salesOrder?: SalesOrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type SalesItemsWhereUniqueInput = {
    id?: number
  }

  export type SalesItemsOrderByWithAggregationInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesItemsCountOrderByAggregateInput
    _avg?: SalesItemsAvgOrderByAggregateInput
    _max?: SalesItemsMaxOrderByAggregateInput
    _min?: SalesItemsMinOrderByAggregateInput
    _sum?: SalesItemsSumOrderByAggregateInput
  }

  export type SalesItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SalesItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<SalesItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SalesItemsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    salesOrderId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
    sellingPrice?: FloatWithAggregatesFilter | number
    total?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VendorWhereInput = {
    AND?: Enumerable<VendorWhereInput>
    OR?: Enumerable<VendorWhereInput>
    NOT?: Enumerable<VendorWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    PurchaseOrder?: PurchaseOrderListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    PurchaseOrder?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VendorScalarWhereWithAggregatesInput>
    OR?: Enumerable<VendorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VendorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    address?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CustomerWhereInput = {
    AND?: Enumerable<CustomerWhereInput>
    OR?: Enumerable<CustomerWhereInput>
    NOT?: Enumerable<CustomerWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    SalesOrder?: SalesOrderListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    SalesOrder?: SalesOrderOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    address?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RolesWhereInput = {
    AND?: Enumerable<RolesWhereInput>
    OR?: Enumerable<RolesWhereInput>
    NOT?: Enumerable<RolesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    UserRoles?: UserRolesListRelationFilter
  }

  export type RolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    UserRoles?: UserRolesOrderByRelationAggregateInput
  }

  export type RolesWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type RolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<RolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RolesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserRolesWhereInput = {
    AND?: Enumerable<UserRolesWhereInput>
    OR?: Enumerable<UserRolesWhereInput>
    NOT?: Enumerable<UserRolesWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    roleId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RolesRelationFilter, RolesWhereInput>
  }

  export type UserRolesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RolesOrderByWithRelationInput
  }

  export type UserRolesWhereUniqueInput = {
    id?: number
  }

  export type UserRolesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserRolesCountOrderByAggregateInput
    _avg?: UserRolesAvgOrderByAggregateInput
    _max?: UserRolesMaxOrderByAggregateInput
    _min?: UserRolesMinOrderByAggregateInput
    _sum?: UserRolesSumOrderByAggregateInput
  }

  export type UserRolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserRolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserRolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserRolesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    roleId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserTokensWhereInput = {
    AND?: Enumerable<UserTokensWhereInput>
    OR?: Enumerable<UserTokensWhereInput>
    NOT?: Enumerable<UserTokensWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    expiry?: DateTimeFilter | Date | string
    token?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserTokensOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiry?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserTokensWhereUniqueInput = {
    id?: number
    token?: string
  }

  export type UserTokensOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiry?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserTokensCountOrderByAggregateInput
    _avg?: UserTokensAvgOrderByAggregateInput
    _max?: UserTokensMaxOrderByAggregateInput
    _min?: UserTokensMinOrderByAggregateInput
    _sum?: UserTokensSumOrderByAggregateInput
  }

  export type UserTokensScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserTokensScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserTokensScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserTokensScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    expiry?: DateTimeWithAggregatesFilter | Date | string
    token?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutUserInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutUserInput
    UserRoles?: UserRolesCreateNestedManyWithoutUserInput
    UserTokens?: UserTokensCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutUserInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutUserInput
    UserRoles?: UserRolesUncheckedCreateNestedManyWithoutUserInput
    UserTokens?: UserTokensUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutUserNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutUserNestedInput
    UserRoles?: UserRolesUpdateManyWithoutUserNestedInput
    UserTokens?: UserTokensUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutUserNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutUserNestedInput
    UserRoles?: UserRolesUncheckedUpdateManyWithoutUserNestedInput
    UserTokens?: UserTokensUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseItems?: PurchaseItemsCreateNestedManyWithoutProductInput
    salesItems?: SalesItemsCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseItems?: PurchaseItemsUncheckedCreateNestedManyWithoutProductInput
    salesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: PurchaseItemsUpdateManyWithoutProductNestedInput
    salesItems?: SalesItemsUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: PurchaseItemsUncheckedUpdateManyWithoutProductNestedInput
    salesItems?: SalesItemsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateInput = {
    purchaseOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: PurchaseItemsCreateNestedManyWithoutPurchaseOrderInput
    vendorName: VendorCreateNestedOneWithoutPurchaseOrderInput
    user: UserCreateNestedOneWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: number
    purchaseOrderNo?: string | null
    vendorId: number
    remarks?: string | null
    total: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: PurchaseItemsUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: PurchaseItemsUpdateManyWithoutPurchaseOrderNestedInput
    vendorName?: VendorUpdateOneRequiredWithoutPurchaseOrderNestedInput
    user?: UserUpdateOneRequiredWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: PurchaseItemsUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: number
    purchaseOrderNo?: string | null
    vendorId: number
    remarks?: string | null
    total: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemsCreateInput = {
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutOrdersInput
    product: ProductCreateNestedOneWithoutPurchaseItemsInput
  }

  export type PurchaseItemsUncheckedCreateInput = {
    id?: number
    purchaseOrderId: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemsUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutOrdersNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput
  }

  export type PurchaseItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemsCreateManyInput = {
    id?: number
    purchaseOrderId: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemsUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderCreateInput = {
    salesOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: SalesItemsCreateNestedManyWithoutSalesOrderInput
    customerName: CustomerCreateNestedOneWithoutSalesOrderInput
    User?: UserCreateNestedOneWithoutSalesOrderInput
  }

  export type SalesOrderUncheckedCreateInput = {
    id?: number
    salesOrderNo?: string | null
    customerId: number
    userId?: number | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: SalesItemsUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type SalesOrderUpdateInput = {
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: SalesItemsUpdateManyWithoutSalesOrderNestedInput
    customerName?: CustomerUpdateOneRequiredWithoutSalesOrderNestedInput
    User?: UserUpdateOneWithoutSalesOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: SalesItemsUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type SalesOrderCreateManyInput = {
    id?: number
    salesOrderNo?: string | null
    customerId: number
    userId?: number | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesOrderUpdateManyMutationInput = {
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesItemsCreateInput = {
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    salesOrder: SalesOrderCreateNestedOneWithoutOrdersInput
    product: ProductCreateNestedOneWithoutSalesItemsInput
  }

  export type SalesItemsUncheckedCreateInput = {
    id?: number
    salesOrderId: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesItemsUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesOrder?: SalesOrderUpdateOneRequiredWithoutOrdersNestedInput
    product?: ProductUpdateOneRequiredWithoutSalesItemsNestedInput
  }

  export type SalesItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesItemsCreateManyInput = {
    id?: number
    salesOrderId: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesItemsUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutVendorNameInput
  }

  export type VendorUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorNameInput
  }

  export type VendorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutVendorNameNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutVendorNameNestedInput
  }

  export type VendorCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesOrder?: SalesOrderCreateNestedManyWithoutCustomerNameInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutCustomerNameInput
  }

  export type CustomerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesOrder?: SalesOrderUpdateManyWithoutCustomerNameNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutCustomerNameNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolesCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRoles?: UserRolesCreateNestedManyWithoutRoleInput
  }

  export type RolesUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRoles?: UserRolesUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRoles?: UserRolesUpdateManyWithoutRoleNestedInput
  }

  export type RolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRoles?: UserRolesUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RolesCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRolesCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
    role: RolesCreateNestedOneWithoutUserRolesInput
  }

  export type UserRolesUncheckedCreateInput = {
    id?: number
    userId: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRolesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    role?: RolesUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRolesCreateManyInput = {
    id?: number
    userId: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRolesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTokensCreateInput = {
    expiry: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserTokensInput
  }

  export type UserTokensUncheckedCreateInput = {
    id?: number
    userId: number
    expiry: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTokensUpdateInput = {
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserTokensNestedInput
  }

  export type UserTokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTokensCreateManyInput = {
    id?: number
    userId: number
    expiry: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTokensUpdateManyMutationInput = {
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type SalesOrderListRelationFilter = {
    every?: SalesOrderWhereInput
    some?: SalesOrderWhereInput
    none?: SalesOrderWhereInput
  }

  export type UserRolesListRelationFilter = {
    every?: UserRolesWhereInput
    some?: UserRolesWhereInput
    none?: UserRolesWhereInput
  }

  export type UserTokensListRelationFilter = {
    every?: UserTokensWhereInput
    some?: UserTokensWhereInput
    none?: UserTokensWhereInput
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type PurchaseItemsListRelationFilter = {
    every?: PurchaseItemsWhereInput
    some?: PurchaseItemsWhereInput
    none?: PurchaseItemsWhereInput
  }

  export type SalesItemsListRelationFilter = {
    every?: SalesItemsWhereInput
    some?: SalesItemsWhereInput
    none?: SalesItemsWhereInput
  }

  export type PurchaseItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    description?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    description?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    description?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    purchasePrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type VendorRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderNo?: SortOrder
    vendorId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    total?: SortOrder
    userId?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderNo?: SortOrder
    vendorId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderNo?: SortOrder
    vendorId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    total?: SortOrder
    userId?: SortOrder
  }

  export type PurchaseOrderRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type PurchaseItemsCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
  }

  export type PurchaseItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseItemsMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseItemsSumOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    purchasePrice?: SortOrder
    total?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type SalesOrderCountOrderByAggregateInput = {
    id?: SortOrder
    salesOrderNo?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    total?: SortOrder
  }

  export type SalesOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    salesOrderNo?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesOrderMinOrderByAggregateInput = {
    id?: SortOrder
    salesOrderNo?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    remarks?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesOrderSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    total?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type SalesOrderRelationFilter = {
    is?: SalesOrderWhereInput
    isNot?: SalesOrderWhereInput
  }

  export type SalesItemsCountOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
  }

  export type SalesItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesItemsMinOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesItemsSumOrderByAggregateInput = {
    id?: SortOrder
    salesOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sellingPrice?: SortOrder
    total?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesRelationFilter = {
    is?: RolesWhereInput
    isNot?: RolesWhereInput
  }

  export type UserRolesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRolesAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRolesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRolesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRolesSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserTokensCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiry?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTokensAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserTokensMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiry?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTokensMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiry?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTokensSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PurchaseOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PurchaseOrderCreateWithoutUserInput>, Enumerable<PurchaseOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PurchaseOrderCreateOrConnectWithoutUserInput>
    createMany?: PurchaseOrderCreateManyUserInputEnvelope
    connect?: Enumerable<PurchaseOrderWhereUniqueInput>
  }

  export type SalesOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SalesOrderCreateWithoutUserInput>, Enumerable<SalesOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SalesOrderCreateOrConnectWithoutUserInput>
    createMany?: SalesOrderCreateManyUserInputEnvelope
    connect?: Enumerable<SalesOrderWhereUniqueInput>
  }

  export type UserRolesCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserRolesCreateWithoutUserInput>, Enumerable<UserRolesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserRolesCreateOrConnectWithoutUserInput>
    createMany?: UserRolesCreateManyUserInputEnvelope
    connect?: Enumerable<UserRolesWhereUniqueInput>
  }

  export type UserTokensCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserTokensCreateWithoutUserInput>, Enumerable<UserTokensUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTokensCreateOrConnectWithoutUserInput>
    createMany?: UserTokensCreateManyUserInputEnvelope
    connect?: Enumerable<UserTokensWhereUniqueInput>
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PurchaseOrderCreateWithoutUserInput>, Enumerable<PurchaseOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PurchaseOrderCreateOrConnectWithoutUserInput>
    createMany?: PurchaseOrderCreateManyUserInputEnvelope
    connect?: Enumerable<PurchaseOrderWhereUniqueInput>
  }

  export type SalesOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SalesOrderCreateWithoutUserInput>, Enumerable<SalesOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SalesOrderCreateOrConnectWithoutUserInput>
    createMany?: SalesOrderCreateManyUserInputEnvelope
    connect?: Enumerable<SalesOrderWhereUniqueInput>
  }

  export type UserRolesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserRolesCreateWithoutUserInput>, Enumerable<UserRolesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserRolesCreateOrConnectWithoutUserInput>
    createMany?: UserRolesCreateManyUserInputEnvelope
    connect?: Enumerable<UserRolesWhereUniqueInput>
  }

  export type UserTokensUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserTokensCreateWithoutUserInput>, Enumerable<UserTokensUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTokensCreateOrConnectWithoutUserInput>
    createMany?: UserTokensCreateManyUserInputEnvelope
    connect?: Enumerable<UserTokensWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PurchaseOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PurchaseOrderCreateWithoutUserInput>, Enumerable<PurchaseOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PurchaseOrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PurchaseOrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PurchaseOrderCreateManyUserInputEnvelope
    set?: Enumerable<PurchaseOrderWhereUniqueInput>
    disconnect?: Enumerable<PurchaseOrderWhereUniqueInput>
    delete?: Enumerable<PurchaseOrderWhereUniqueInput>
    connect?: Enumerable<PurchaseOrderWhereUniqueInput>
    update?: Enumerable<PurchaseOrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PurchaseOrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PurchaseOrderScalarWhereInput>
  }

  export type SalesOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SalesOrderCreateWithoutUserInput>, Enumerable<SalesOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SalesOrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SalesOrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SalesOrderCreateManyUserInputEnvelope
    set?: Enumerable<SalesOrderWhereUniqueInput>
    disconnect?: Enumerable<SalesOrderWhereUniqueInput>
    delete?: Enumerable<SalesOrderWhereUniqueInput>
    connect?: Enumerable<SalesOrderWhereUniqueInput>
    update?: Enumerable<SalesOrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SalesOrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SalesOrderScalarWhereInput>
  }

  export type UserRolesUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserRolesCreateWithoutUserInput>, Enumerable<UserRolesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserRolesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserRolesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserRolesCreateManyUserInputEnvelope
    set?: Enumerable<UserRolesWhereUniqueInput>
    disconnect?: Enumerable<UserRolesWhereUniqueInput>
    delete?: Enumerable<UserRolesWhereUniqueInput>
    connect?: Enumerable<UserRolesWhereUniqueInput>
    update?: Enumerable<UserRolesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserRolesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserRolesScalarWhereInput>
  }

  export type UserTokensUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserTokensCreateWithoutUserInput>, Enumerable<UserTokensUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTokensCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserTokensUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserTokensCreateManyUserInputEnvelope
    set?: Enumerable<UserTokensWhereUniqueInput>
    disconnect?: Enumerable<UserTokensWhereUniqueInput>
    delete?: Enumerable<UserTokensWhereUniqueInput>
    connect?: Enumerable<UserTokensWhereUniqueInput>
    update?: Enumerable<UserTokensUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserTokensUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserTokensScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PurchaseOrderCreateWithoutUserInput>, Enumerable<PurchaseOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PurchaseOrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PurchaseOrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PurchaseOrderCreateManyUserInputEnvelope
    set?: Enumerable<PurchaseOrderWhereUniqueInput>
    disconnect?: Enumerable<PurchaseOrderWhereUniqueInput>
    delete?: Enumerable<PurchaseOrderWhereUniqueInput>
    connect?: Enumerable<PurchaseOrderWhereUniqueInput>
    update?: Enumerable<PurchaseOrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PurchaseOrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PurchaseOrderScalarWhereInput>
  }

  export type SalesOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SalesOrderCreateWithoutUserInput>, Enumerable<SalesOrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SalesOrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SalesOrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SalesOrderCreateManyUserInputEnvelope
    set?: Enumerable<SalesOrderWhereUniqueInput>
    disconnect?: Enumerable<SalesOrderWhereUniqueInput>
    delete?: Enumerable<SalesOrderWhereUniqueInput>
    connect?: Enumerable<SalesOrderWhereUniqueInput>
    update?: Enumerable<SalesOrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SalesOrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SalesOrderScalarWhereInput>
  }

  export type UserRolesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserRolesCreateWithoutUserInput>, Enumerable<UserRolesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserRolesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserRolesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserRolesCreateManyUserInputEnvelope
    set?: Enumerable<UserRolesWhereUniqueInput>
    disconnect?: Enumerable<UserRolesWhereUniqueInput>
    delete?: Enumerable<UserRolesWhereUniqueInput>
    connect?: Enumerable<UserRolesWhereUniqueInput>
    update?: Enumerable<UserRolesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserRolesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserRolesScalarWhereInput>
  }

  export type UserTokensUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserTokensCreateWithoutUserInput>, Enumerable<UserTokensUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTokensCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserTokensUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserTokensCreateManyUserInputEnvelope
    set?: Enumerable<UserTokensWhereUniqueInput>
    disconnect?: Enumerable<UserTokensWhereUniqueInput>
    delete?: Enumerable<UserTokensWhereUniqueInput>
    connect?: Enumerable<UserTokensWhereUniqueInput>
    update?: Enumerable<UserTokensUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserTokensUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserTokensScalarWhereInput>
  }

  export type PurchaseItemsCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PurchaseItemsCreateWithoutProductInput>, Enumerable<PurchaseItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PurchaseItemsCreateOrConnectWithoutProductInput>
    createMany?: PurchaseItemsCreateManyProductInputEnvelope
    connect?: Enumerable<PurchaseItemsWhereUniqueInput>
  }

  export type SalesItemsCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<SalesItemsCreateWithoutProductInput>, Enumerable<SalesItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<SalesItemsCreateOrConnectWithoutProductInput>
    createMany?: SalesItemsCreateManyProductInputEnvelope
    connect?: Enumerable<SalesItemsWhereUniqueInput>
  }

  export type PurchaseItemsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PurchaseItemsCreateWithoutProductInput>, Enumerable<PurchaseItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PurchaseItemsCreateOrConnectWithoutProductInput>
    createMany?: PurchaseItemsCreateManyProductInputEnvelope
    connect?: Enumerable<PurchaseItemsWhereUniqueInput>
  }

  export type SalesItemsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<SalesItemsCreateWithoutProductInput>, Enumerable<SalesItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<SalesItemsCreateOrConnectWithoutProductInput>
    createMany?: SalesItemsCreateManyProductInputEnvelope
    connect?: Enumerable<SalesItemsWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PurchaseItemsUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<PurchaseItemsCreateWithoutProductInput>, Enumerable<PurchaseItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PurchaseItemsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PurchaseItemsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PurchaseItemsCreateManyProductInputEnvelope
    set?: Enumerable<PurchaseItemsWhereUniqueInput>
    disconnect?: Enumerable<PurchaseItemsWhereUniqueInput>
    delete?: Enumerable<PurchaseItemsWhereUniqueInput>
    connect?: Enumerable<PurchaseItemsWhereUniqueInput>
    update?: Enumerable<PurchaseItemsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PurchaseItemsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PurchaseItemsScalarWhereInput>
  }

  export type SalesItemsUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<SalesItemsCreateWithoutProductInput>, Enumerable<SalesItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<SalesItemsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<SalesItemsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: SalesItemsCreateManyProductInputEnvelope
    set?: Enumerable<SalesItemsWhereUniqueInput>
    disconnect?: Enumerable<SalesItemsWhereUniqueInput>
    delete?: Enumerable<SalesItemsWhereUniqueInput>
    connect?: Enumerable<SalesItemsWhereUniqueInput>
    update?: Enumerable<SalesItemsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<SalesItemsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<SalesItemsScalarWhereInput>
  }

  export type PurchaseItemsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<PurchaseItemsCreateWithoutProductInput>, Enumerable<PurchaseItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PurchaseItemsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PurchaseItemsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PurchaseItemsCreateManyProductInputEnvelope
    set?: Enumerable<PurchaseItemsWhereUniqueInput>
    disconnect?: Enumerable<PurchaseItemsWhereUniqueInput>
    delete?: Enumerable<PurchaseItemsWhereUniqueInput>
    connect?: Enumerable<PurchaseItemsWhereUniqueInput>
    update?: Enumerable<PurchaseItemsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PurchaseItemsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PurchaseItemsScalarWhereInput>
  }

  export type SalesItemsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<SalesItemsCreateWithoutProductInput>, Enumerable<SalesItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<SalesItemsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<SalesItemsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: SalesItemsCreateManyProductInputEnvelope
    set?: Enumerable<SalesItemsWhereUniqueInput>
    disconnect?: Enumerable<SalesItemsWhereUniqueInput>
    delete?: Enumerable<SalesItemsWhereUniqueInput>
    connect?: Enumerable<SalesItemsWhereUniqueInput>
    update?: Enumerable<SalesItemsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<SalesItemsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<SalesItemsScalarWhereInput>
  }

  export type PurchaseItemsCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<Enumerable<PurchaseItemsCreateWithoutPurchaseOrderInput>, Enumerable<PurchaseItemsUncheckedCreateWithoutPurchaseOrderInput>>
    connectOrCreate?: Enumerable<PurchaseItemsCreateOrConnectWithoutPurchaseOrderInput>
    createMany?: PurchaseItemsCreateManyPurchaseOrderInputEnvelope
    connect?: Enumerable<PurchaseItemsWhereUniqueInput>
  }

  export type VendorCreateNestedOneWithoutPurchaseOrderInput = {
    create?: XOR<VendorCreateWithoutPurchaseOrderInput, VendorUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseOrderInput
    connect?: VendorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPurchaseOrderInput = {
    create?: XOR<UserCreateWithoutPurchaseOrderInput, UserUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseOrderInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseItemsUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<Enumerable<PurchaseItemsCreateWithoutPurchaseOrderInput>, Enumerable<PurchaseItemsUncheckedCreateWithoutPurchaseOrderInput>>
    connectOrCreate?: Enumerable<PurchaseItemsCreateOrConnectWithoutPurchaseOrderInput>
    createMany?: PurchaseItemsCreateManyPurchaseOrderInputEnvelope
    connect?: Enumerable<PurchaseItemsWhereUniqueInput>
  }

  export type PurchaseItemsUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<Enumerable<PurchaseItemsCreateWithoutPurchaseOrderInput>, Enumerable<PurchaseItemsUncheckedCreateWithoutPurchaseOrderInput>>
    connectOrCreate?: Enumerable<PurchaseItemsCreateOrConnectWithoutPurchaseOrderInput>
    upsert?: Enumerable<PurchaseItemsUpsertWithWhereUniqueWithoutPurchaseOrderInput>
    createMany?: PurchaseItemsCreateManyPurchaseOrderInputEnvelope
    set?: Enumerable<PurchaseItemsWhereUniqueInput>
    disconnect?: Enumerable<PurchaseItemsWhereUniqueInput>
    delete?: Enumerable<PurchaseItemsWhereUniqueInput>
    connect?: Enumerable<PurchaseItemsWhereUniqueInput>
    update?: Enumerable<PurchaseItemsUpdateWithWhereUniqueWithoutPurchaseOrderInput>
    updateMany?: Enumerable<PurchaseItemsUpdateManyWithWhereWithoutPurchaseOrderInput>
    deleteMany?: Enumerable<PurchaseItemsScalarWhereInput>
  }

  export type VendorUpdateOneRequiredWithoutPurchaseOrderNestedInput = {
    create?: XOR<VendorCreateWithoutPurchaseOrderInput, VendorUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseOrderInput
    upsert?: VendorUpsertWithoutPurchaseOrderInput
    connect?: VendorWhereUniqueInput
    update?: XOR<VendorUpdateWithoutPurchaseOrderInput, VendorUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type UserUpdateOneRequiredWithoutPurchaseOrderNestedInput = {
    create?: XOR<UserCreateWithoutPurchaseOrderInput, UserUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseOrderInput
    upsert?: UserUpsertWithoutPurchaseOrderInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPurchaseOrderInput, UserUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseItemsUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<Enumerable<PurchaseItemsCreateWithoutPurchaseOrderInput>, Enumerable<PurchaseItemsUncheckedCreateWithoutPurchaseOrderInput>>
    connectOrCreate?: Enumerable<PurchaseItemsCreateOrConnectWithoutPurchaseOrderInput>
    upsert?: Enumerable<PurchaseItemsUpsertWithWhereUniqueWithoutPurchaseOrderInput>
    createMany?: PurchaseItemsCreateManyPurchaseOrderInputEnvelope
    set?: Enumerable<PurchaseItemsWhereUniqueInput>
    disconnect?: Enumerable<PurchaseItemsWhereUniqueInput>
    delete?: Enumerable<PurchaseItemsWhereUniqueInput>
    connect?: Enumerable<PurchaseItemsWhereUniqueInput>
    update?: Enumerable<PurchaseItemsUpdateWithWhereUniqueWithoutPurchaseOrderInput>
    updateMany?: Enumerable<PurchaseItemsUpdateManyWithWhereWithoutPurchaseOrderInput>
    deleteMany?: Enumerable<PurchaseItemsScalarWhereInput>
  }

  export type PurchaseOrderCreateNestedOneWithoutOrdersInput = {
    create?: XOR<PurchaseOrderCreateWithoutOrdersInput, PurchaseOrderUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutOrdersInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchaseItemsInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type PurchaseOrderUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutOrdersInput, PurchaseOrderUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutOrdersInput
    upsert?: PurchaseOrderUpsertWithoutOrdersInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<PurchaseOrderUpdateWithoutOrdersInput, PurchaseOrderUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemsInput
    upsert?: ProductUpsertWithoutPurchaseItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutPurchaseItemsInput, ProductUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type SalesItemsCreateNestedManyWithoutSalesOrderInput = {
    create?: XOR<Enumerable<SalesItemsCreateWithoutSalesOrderInput>, Enumerable<SalesItemsUncheckedCreateWithoutSalesOrderInput>>
    connectOrCreate?: Enumerable<SalesItemsCreateOrConnectWithoutSalesOrderInput>
    createMany?: SalesItemsCreateManySalesOrderInputEnvelope
    connect?: Enumerable<SalesItemsWhereUniqueInput>
  }

  export type CustomerCreateNestedOneWithoutSalesOrderInput = {
    create?: XOR<CustomerCreateWithoutSalesOrderInput, CustomerUncheckedCreateWithoutSalesOrderInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesOrderInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSalesOrderInput = {
    create?: XOR<UserCreateWithoutSalesOrderInput, UserUncheckedCreateWithoutSalesOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesOrderInput
    connect?: UserWhereUniqueInput
  }

  export type SalesItemsUncheckedCreateNestedManyWithoutSalesOrderInput = {
    create?: XOR<Enumerable<SalesItemsCreateWithoutSalesOrderInput>, Enumerable<SalesItemsUncheckedCreateWithoutSalesOrderInput>>
    connectOrCreate?: Enumerable<SalesItemsCreateOrConnectWithoutSalesOrderInput>
    createMany?: SalesItemsCreateManySalesOrderInputEnvelope
    connect?: Enumerable<SalesItemsWhereUniqueInput>
  }

  export type SalesItemsUpdateManyWithoutSalesOrderNestedInput = {
    create?: XOR<Enumerable<SalesItemsCreateWithoutSalesOrderInput>, Enumerable<SalesItemsUncheckedCreateWithoutSalesOrderInput>>
    connectOrCreate?: Enumerable<SalesItemsCreateOrConnectWithoutSalesOrderInput>
    upsert?: Enumerable<SalesItemsUpsertWithWhereUniqueWithoutSalesOrderInput>
    createMany?: SalesItemsCreateManySalesOrderInputEnvelope
    set?: Enumerable<SalesItemsWhereUniqueInput>
    disconnect?: Enumerable<SalesItemsWhereUniqueInput>
    delete?: Enumerable<SalesItemsWhereUniqueInput>
    connect?: Enumerable<SalesItemsWhereUniqueInput>
    update?: Enumerable<SalesItemsUpdateWithWhereUniqueWithoutSalesOrderInput>
    updateMany?: Enumerable<SalesItemsUpdateManyWithWhereWithoutSalesOrderInput>
    deleteMany?: Enumerable<SalesItemsScalarWhereInput>
  }

  export type CustomerUpdateOneRequiredWithoutSalesOrderNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesOrderInput, CustomerUncheckedCreateWithoutSalesOrderInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesOrderInput
    upsert?: CustomerUpsertWithoutSalesOrderInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutSalesOrderInput, CustomerUncheckedUpdateWithoutSalesOrderInput>
  }

  export type UserUpdateOneWithoutSalesOrderNestedInput = {
    create?: XOR<UserCreateWithoutSalesOrderInput, UserUncheckedCreateWithoutSalesOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesOrderInput
    upsert?: UserUpsertWithoutSalesOrderInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSalesOrderInput, UserUncheckedUpdateWithoutSalesOrderInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SalesItemsUncheckedUpdateManyWithoutSalesOrderNestedInput = {
    create?: XOR<Enumerable<SalesItemsCreateWithoutSalesOrderInput>, Enumerable<SalesItemsUncheckedCreateWithoutSalesOrderInput>>
    connectOrCreate?: Enumerable<SalesItemsCreateOrConnectWithoutSalesOrderInput>
    upsert?: Enumerable<SalesItemsUpsertWithWhereUniqueWithoutSalesOrderInput>
    createMany?: SalesItemsCreateManySalesOrderInputEnvelope
    set?: Enumerable<SalesItemsWhereUniqueInput>
    disconnect?: Enumerable<SalesItemsWhereUniqueInput>
    delete?: Enumerable<SalesItemsWhereUniqueInput>
    connect?: Enumerable<SalesItemsWhereUniqueInput>
    update?: Enumerable<SalesItemsUpdateWithWhereUniqueWithoutSalesOrderInput>
    updateMany?: Enumerable<SalesItemsUpdateManyWithWhereWithoutSalesOrderInput>
    deleteMany?: Enumerable<SalesItemsScalarWhereInput>
  }

  export type SalesOrderCreateNestedOneWithoutOrdersInput = {
    create?: XOR<SalesOrderCreateWithoutOrdersInput, SalesOrderUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutOrdersInput
    connect?: SalesOrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSalesItemsInput = {
    create?: XOR<ProductCreateWithoutSalesItemsInput, ProductUncheckedCreateWithoutSalesItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSalesItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type SalesOrderUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<SalesOrderCreateWithoutOrdersInput, SalesOrderUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutOrdersInput
    upsert?: SalesOrderUpsertWithoutOrdersInput
    connect?: SalesOrderWhereUniqueInput
    update?: XOR<SalesOrderUpdateWithoutOrdersInput, SalesOrderUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUpdateOneRequiredWithoutSalesItemsNestedInput = {
    create?: XOR<ProductCreateWithoutSalesItemsInput, ProductUncheckedCreateWithoutSalesItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSalesItemsInput
    upsert?: ProductUpsertWithoutSalesItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutSalesItemsInput, ProductUncheckedUpdateWithoutSalesItemsInput>
  }

  export type PurchaseOrderCreateNestedManyWithoutVendorNameInput = {
    create?: XOR<Enumerable<PurchaseOrderCreateWithoutVendorNameInput>, Enumerable<PurchaseOrderUncheckedCreateWithoutVendorNameInput>>
    connectOrCreate?: Enumerable<PurchaseOrderCreateOrConnectWithoutVendorNameInput>
    createMany?: PurchaseOrderCreateManyVendorNameInputEnvelope
    connect?: Enumerable<PurchaseOrderWhereUniqueInput>
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutVendorNameInput = {
    create?: XOR<Enumerable<PurchaseOrderCreateWithoutVendorNameInput>, Enumerable<PurchaseOrderUncheckedCreateWithoutVendorNameInput>>
    connectOrCreate?: Enumerable<PurchaseOrderCreateOrConnectWithoutVendorNameInput>
    createMany?: PurchaseOrderCreateManyVendorNameInputEnvelope
    connect?: Enumerable<PurchaseOrderWhereUniqueInput>
  }

  export type PurchaseOrderUpdateManyWithoutVendorNameNestedInput = {
    create?: XOR<Enumerable<PurchaseOrderCreateWithoutVendorNameInput>, Enumerable<PurchaseOrderUncheckedCreateWithoutVendorNameInput>>
    connectOrCreate?: Enumerable<PurchaseOrderCreateOrConnectWithoutVendorNameInput>
    upsert?: Enumerable<PurchaseOrderUpsertWithWhereUniqueWithoutVendorNameInput>
    createMany?: PurchaseOrderCreateManyVendorNameInputEnvelope
    set?: Enumerable<PurchaseOrderWhereUniqueInput>
    disconnect?: Enumerable<PurchaseOrderWhereUniqueInput>
    delete?: Enumerable<PurchaseOrderWhereUniqueInput>
    connect?: Enumerable<PurchaseOrderWhereUniqueInput>
    update?: Enumerable<PurchaseOrderUpdateWithWhereUniqueWithoutVendorNameInput>
    updateMany?: Enumerable<PurchaseOrderUpdateManyWithWhereWithoutVendorNameInput>
    deleteMany?: Enumerable<PurchaseOrderScalarWhereInput>
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutVendorNameNestedInput = {
    create?: XOR<Enumerable<PurchaseOrderCreateWithoutVendorNameInput>, Enumerable<PurchaseOrderUncheckedCreateWithoutVendorNameInput>>
    connectOrCreate?: Enumerable<PurchaseOrderCreateOrConnectWithoutVendorNameInput>
    upsert?: Enumerable<PurchaseOrderUpsertWithWhereUniqueWithoutVendorNameInput>
    createMany?: PurchaseOrderCreateManyVendorNameInputEnvelope
    set?: Enumerable<PurchaseOrderWhereUniqueInput>
    disconnect?: Enumerable<PurchaseOrderWhereUniqueInput>
    delete?: Enumerable<PurchaseOrderWhereUniqueInput>
    connect?: Enumerable<PurchaseOrderWhereUniqueInput>
    update?: Enumerable<PurchaseOrderUpdateWithWhereUniqueWithoutVendorNameInput>
    updateMany?: Enumerable<PurchaseOrderUpdateManyWithWhereWithoutVendorNameInput>
    deleteMany?: Enumerable<PurchaseOrderScalarWhereInput>
  }

  export type SalesOrderCreateNestedManyWithoutCustomerNameInput = {
    create?: XOR<Enumerable<SalesOrderCreateWithoutCustomerNameInput>, Enumerable<SalesOrderUncheckedCreateWithoutCustomerNameInput>>
    connectOrCreate?: Enumerable<SalesOrderCreateOrConnectWithoutCustomerNameInput>
    createMany?: SalesOrderCreateManyCustomerNameInputEnvelope
    connect?: Enumerable<SalesOrderWhereUniqueInput>
  }

  export type SalesOrderUncheckedCreateNestedManyWithoutCustomerNameInput = {
    create?: XOR<Enumerable<SalesOrderCreateWithoutCustomerNameInput>, Enumerable<SalesOrderUncheckedCreateWithoutCustomerNameInput>>
    connectOrCreate?: Enumerable<SalesOrderCreateOrConnectWithoutCustomerNameInput>
    createMany?: SalesOrderCreateManyCustomerNameInputEnvelope
    connect?: Enumerable<SalesOrderWhereUniqueInput>
  }

  export type SalesOrderUpdateManyWithoutCustomerNameNestedInput = {
    create?: XOR<Enumerable<SalesOrderCreateWithoutCustomerNameInput>, Enumerable<SalesOrderUncheckedCreateWithoutCustomerNameInput>>
    connectOrCreate?: Enumerable<SalesOrderCreateOrConnectWithoutCustomerNameInput>
    upsert?: Enumerable<SalesOrderUpsertWithWhereUniqueWithoutCustomerNameInput>
    createMany?: SalesOrderCreateManyCustomerNameInputEnvelope
    set?: Enumerable<SalesOrderWhereUniqueInput>
    disconnect?: Enumerable<SalesOrderWhereUniqueInput>
    delete?: Enumerable<SalesOrderWhereUniqueInput>
    connect?: Enumerable<SalesOrderWhereUniqueInput>
    update?: Enumerable<SalesOrderUpdateWithWhereUniqueWithoutCustomerNameInput>
    updateMany?: Enumerable<SalesOrderUpdateManyWithWhereWithoutCustomerNameInput>
    deleteMany?: Enumerable<SalesOrderScalarWhereInput>
  }

  export type SalesOrderUncheckedUpdateManyWithoutCustomerNameNestedInput = {
    create?: XOR<Enumerable<SalesOrderCreateWithoutCustomerNameInput>, Enumerable<SalesOrderUncheckedCreateWithoutCustomerNameInput>>
    connectOrCreate?: Enumerable<SalesOrderCreateOrConnectWithoutCustomerNameInput>
    upsert?: Enumerable<SalesOrderUpsertWithWhereUniqueWithoutCustomerNameInput>
    createMany?: SalesOrderCreateManyCustomerNameInputEnvelope
    set?: Enumerable<SalesOrderWhereUniqueInput>
    disconnect?: Enumerable<SalesOrderWhereUniqueInput>
    delete?: Enumerable<SalesOrderWhereUniqueInput>
    connect?: Enumerable<SalesOrderWhereUniqueInput>
    update?: Enumerable<SalesOrderUpdateWithWhereUniqueWithoutCustomerNameInput>
    updateMany?: Enumerable<SalesOrderUpdateManyWithWhereWithoutCustomerNameInput>
    deleteMany?: Enumerable<SalesOrderScalarWhereInput>
  }

  export type UserRolesCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserRolesCreateWithoutRoleInput>, Enumerable<UserRolesUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserRolesCreateOrConnectWithoutRoleInput>
    createMany?: UserRolesCreateManyRoleInputEnvelope
    connect?: Enumerable<UserRolesWhereUniqueInput>
  }

  export type UserRolesUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserRolesCreateWithoutRoleInput>, Enumerable<UserRolesUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserRolesCreateOrConnectWithoutRoleInput>
    createMany?: UserRolesCreateManyRoleInputEnvelope
    connect?: Enumerable<UserRolesWhereUniqueInput>
  }

  export type UserRolesUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<UserRolesCreateWithoutRoleInput>, Enumerable<UserRolesUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserRolesCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UserRolesUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UserRolesCreateManyRoleInputEnvelope
    set?: Enumerable<UserRolesWhereUniqueInput>
    disconnect?: Enumerable<UserRolesWhereUniqueInput>
    delete?: Enumerable<UserRolesWhereUniqueInput>
    connect?: Enumerable<UserRolesWhereUniqueInput>
    update?: Enumerable<UserRolesUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UserRolesUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UserRolesScalarWhereInput>
  }

  export type UserRolesUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<UserRolesCreateWithoutRoleInput>, Enumerable<UserRolesUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserRolesCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UserRolesUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UserRolesCreateManyRoleInputEnvelope
    set?: Enumerable<UserRolesWhereUniqueInput>
    disconnect?: Enumerable<UserRolesWhereUniqueInput>
    delete?: Enumerable<UserRolesWhereUniqueInput>
    connect?: Enumerable<UserRolesWhereUniqueInput>
    update?: Enumerable<UserRolesUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UserRolesUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UserRolesScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RolesCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RolesCreateWithoutUserRolesInput, RolesUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUserRolesInput
    connect?: RolesWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type RolesUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RolesCreateWithoutUserRolesInput, RolesUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUserRolesInput
    upsert?: RolesUpsertWithoutUserRolesInput
    connect?: RolesWhereUniqueInput
    update?: XOR<RolesUpdateWithoutUserRolesInput, RolesUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserCreateNestedOneWithoutUserTokensInput = {
    create?: XOR<UserCreateWithoutUserTokensInput, UserUncheckedCreateWithoutUserTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserTokensNestedInput = {
    create?: XOR<UserCreateWithoutUserTokensInput, UserUncheckedCreateWithoutUserTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTokensInput
    upsert?: UserUpsertWithoutUserTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserTokensInput, UserUncheckedUpdateWithoutUserTokensInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type PurchaseOrderCreateWithoutUserInput = {
    purchaseOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: PurchaseItemsCreateNestedManyWithoutPurchaseOrderInput
    vendorName: VendorCreateNestedOneWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutUserInput = {
    id?: number
    purchaseOrderNo?: string | null
    vendorId: number
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: PurchaseItemsUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutUserInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutUserInput, PurchaseOrderUncheckedCreateWithoutUserInput>
  }

  export type PurchaseOrderCreateManyUserInputEnvelope = {
    data: Enumerable<PurchaseOrderCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SalesOrderCreateWithoutUserInput = {
    salesOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: SalesItemsCreateNestedManyWithoutSalesOrderInput
    customerName: CustomerCreateNestedOneWithoutSalesOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutUserInput = {
    id?: number
    salesOrderNo?: string | null
    customerId: number
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: SalesItemsUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutUserInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutUserInput, SalesOrderUncheckedCreateWithoutUserInput>
  }

  export type SalesOrderCreateManyUserInputEnvelope = {
    data: Enumerable<SalesOrderCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserRolesCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RolesCreateNestedOneWithoutUserRolesInput
  }

  export type UserRolesUncheckedCreateWithoutUserInput = {
    id?: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRolesCreateOrConnectWithoutUserInput = {
    where: UserRolesWhereUniqueInput
    create: XOR<UserRolesCreateWithoutUserInput, UserRolesUncheckedCreateWithoutUserInput>
  }

  export type UserRolesCreateManyUserInputEnvelope = {
    data: Enumerable<UserRolesCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserTokensCreateWithoutUserInput = {
    expiry: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTokensUncheckedCreateWithoutUserInput = {
    id?: number
    expiry: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTokensCreateOrConnectWithoutUserInput = {
    where: UserTokensWhereUniqueInput
    create: XOR<UserTokensCreateWithoutUserInput, UserTokensUncheckedCreateWithoutUserInput>
  }

  export type UserTokensCreateManyUserInputEnvelope = {
    data: Enumerable<UserTokensCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutUserInput, PurchaseOrderUncheckedUpdateWithoutUserInput>
    create: XOR<PurchaseOrderCreateWithoutUserInput, PurchaseOrderUncheckedCreateWithoutUserInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutUserInput, PurchaseOrderUncheckedUpdateWithoutUserInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutUserInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: Enumerable<PurchaseOrderScalarWhereInput>
    OR?: Enumerable<PurchaseOrderScalarWhereInput>
    NOT?: Enumerable<PurchaseOrderScalarWhereInput>
    id?: IntFilter | number
    purchaseOrderNo?: StringNullableFilter | string | null
    vendorId?: IntFilter | number
    remarks?: StringNullableFilter | string | null
    total?: FloatFilter | number
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SalesOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: SalesOrderWhereUniqueInput
    update: XOR<SalesOrderUpdateWithoutUserInput, SalesOrderUncheckedUpdateWithoutUserInput>
    create: XOR<SalesOrderCreateWithoutUserInput, SalesOrderUncheckedCreateWithoutUserInput>
  }

  export type SalesOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: SalesOrderWhereUniqueInput
    data: XOR<SalesOrderUpdateWithoutUserInput, SalesOrderUncheckedUpdateWithoutUserInput>
  }

  export type SalesOrderUpdateManyWithWhereWithoutUserInput = {
    where: SalesOrderScalarWhereInput
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyWithoutSalesOrderInput>
  }

  export type SalesOrderScalarWhereInput = {
    AND?: Enumerable<SalesOrderScalarWhereInput>
    OR?: Enumerable<SalesOrderScalarWhereInput>
    NOT?: Enumerable<SalesOrderScalarWhereInput>
    id?: IntFilter | number
    salesOrderNo?: StringNullableFilter | string | null
    customerId?: IntFilter | number
    userId?: IntNullableFilter | number | null
    remarks?: StringNullableFilter | string | null
    total?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserRolesUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRolesWhereUniqueInput
    update: XOR<UserRolesUpdateWithoutUserInput, UserRolesUncheckedUpdateWithoutUserInput>
    create: XOR<UserRolesCreateWithoutUserInput, UserRolesUncheckedCreateWithoutUserInput>
  }

  export type UserRolesUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRolesWhereUniqueInput
    data: XOR<UserRolesUpdateWithoutUserInput, UserRolesUncheckedUpdateWithoutUserInput>
  }

  export type UserRolesUpdateManyWithWhereWithoutUserInput = {
    where: UserRolesScalarWhereInput
    data: XOR<UserRolesUpdateManyMutationInput, UserRolesUncheckedUpdateManyWithoutUserRolesInput>
  }

  export type UserRolesScalarWhereInput = {
    AND?: Enumerable<UserRolesScalarWhereInput>
    OR?: Enumerable<UserRolesScalarWhereInput>
    NOT?: Enumerable<UserRolesScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    roleId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserTokensUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTokensWhereUniqueInput
    update: XOR<UserTokensUpdateWithoutUserInput, UserTokensUncheckedUpdateWithoutUserInput>
    create: XOR<UserTokensCreateWithoutUserInput, UserTokensUncheckedCreateWithoutUserInput>
  }

  export type UserTokensUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTokensWhereUniqueInput
    data: XOR<UserTokensUpdateWithoutUserInput, UserTokensUncheckedUpdateWithoutUserInput>
  }

  export type UserTokensUpdateManyWithWhereWithoutUserInput = {
    where: UserTokensScalarWhereInput
    data: XOR<UserTokensUpdateManyMutationInput, UserTokensUncheckedUpdateManyWithoutUserTokensInput>
  }

  export type UserTokensScalarWhereInput = {
    AND?: Enumerable<UserTokensScalarWhereInput>
    OR?: Enumerable<UserTokensScalarWhereInput>
    NOT?: Enumerable<UserTokensScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    expiry?: DateTimeFilter | Date | string
    token?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PurchaseItemsCreateWithoutProductInput = {
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutOrdersInput
  }

  export type PurchaseItemsUncheckedCreateWithoutProductInput = {
    id?: number
    purchaseOrderId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemsCreateOrConnectWithoutProductInput = {
    where: PurchaseItemsWhereUniqueInput
    create: XOR<PurchaseItemsCreateWithoutProductInput, PurchaseItemsUncheckedCreateWithoutProductInput>
  }

  export type PurchaseItemsCreateManyProductInputEnvelope = {
    data: Enumerable<PurchaseItemsCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type SalesItemsCreateWithoutProductInput = {
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    salesOrder: SalesOrderCreateNestedOneWithoutOrdersInput
  }

  export type SalesItemsUncheckedCreateWithoutProductInput = {
    id?: number
    salesOrderId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesItemsCreateOrConnectWithoutProductInput = {
    where: SalesItemsWhereUniqueInput
    create: XOR<SalesItemsCreateWithoutProductInput, SalesItemsUncheckedCreateWithoutProductInput>
  }

  export type SalesItemsCreateManyProductInputEnvelope = {
    data: Enumerable<SalesItemsCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type PurchaseItemsUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseItemsWhereUniqueInput
    update: XOR<PurchaseItemsUpdateWithoutProductInput, PurchaseItemsUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseItemsCreateWithoutProductInput, PurchaseItemsUncheckedCreateWithoutProductInput>
  }

  export type PurchaseItemsUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseItemsWhereUniqueInput
    data: XOR<PurchaseItemsUpdateWithoutProductInput, PurchaseItemsUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseItemsUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseItemsScalarWhereInput
    data: XOR<PurchaseItemsUpdateManyMutationInput, PurchaseItemsUncheckedUpdateManyWithoutPurchaseItemsInput>
  }

  export type PurchaseItemsScalarWhereInput = {
    AND?: Enumerable<PurchaseItemsScalarWhereInput>
    OR?: Enumerable<PurchaseItemsScalarWhereInput>
    NOT?: Enumerable<PurchaseItemsScalarWhereInput>
    id?: IntFilter | number
    purchaseOrderId?: IntFilter | number
    productId?: IntFilter | number
    quantity?: IntFilter | number
    purchasePrice?: FloatFilter | number
    total?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SalesItemsUpsertWithWhereUniqueWithoutProductInput = {
    where: SalesItemsWhereUniqueInput
    update: XOR<SalesItemsUpdateWithoutProductInput, SalesItemsUncheckedUpdateWithoutProductInput>
    create: XOR<SalesItemsCreateWithoutProductInput, SalesItemsUncheckedCreateWithoutProductInput>
  }

  export type SalesItemsUpdateWithWhereUniqueWithoutProductInput = {
    where: SalesItemsWhereUniqueInput
    data: XOR<SalesItemsUpdateWithoutProductInput, SalesItemsUncheckedUpdateWithoutProductInput>
  }

  export type SalesItemsUpdateManyWithWhereWithoutProductInput = {
    where: SalesItemsScalarWhereInput
    data: XOR<SalesItemsUpdateManyMutationInput, SalesItemsUncheckedUpdateManyWithoutSalesItemsInput>
  }

  export type SalesItemsScalarWhereInput = {
    AND?: Enumerable<SalesItemsScalarWhereInput>
    OR?: Enumerable<SalesItemsScalarWhereInput>
    NOT?: Enumerable<SalesItemsScalarWhereInput>
    id?: IntFilter | number
    salesOrderId?: IntFilter | number
    productId?: IntFilter | number
    quantity?: IntFilter | number
    sellingPrice?: FloatFilter | number
    total?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PurchaseItemsCreateWithoutPurchaseOrderInput = {
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutPurchaseItemsInput
  }

  export type PurchaseItemsUncheckedCreateWithoutPurchaseOrderInput = {
    id?: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemsCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseItemsWhereUniqueInput
    create: XOR<PurchaseItemsCreateWithoutPurchaseOrderInput, PurchaseItemsUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseItemsCreateManyPurchaseOrderInputEnvelope = {
    data: Enumerable<PurchaseItemsCreateManyPurchaseOrderInput>
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutPurchaseOrderInput = {
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUncheckedCreateWithoutPurchaseOrderInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorCreateOrConnectWithoutPurchaseOrderInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPurchaseOrderInput, VendorUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type UserCreateWithoutPurchaseOrderInput = {
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesOrder?: SalesOrderCreateNestedManyWithoutUserInput
    UserRoles?: UserRolesCreateNestedManyWithoutUserInput
    UserTokens?: UserTokensCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPurchaseOrderInput = {
    id?: number
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutUserInput
    UserRoles?: UserRolesUncheckedCreateNestedManyWithoutUserInput
    UserTokens?: UserTokensUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPurchaseOrderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchaseOrderInput, UserUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseItemsUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseItemsWhereUniqueInput
    update: XOR<PurchaseItemsUpdateWithoutPurchaseOrderInput, PurchaseItemsUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseItemsCreateWithoutPurchaseOrderInput, PurchaseItemsUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseItemsUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseItemsWhereUniqueInput
    data: XOR<PurchaseItemsUpdateWithoutPurchaseOrderInput, PurchaseItemsUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseItemsUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseItemsScalarWhereInput
    data: XOR<PurchaseItemsUpdateManyMutationInput, PurchaseItemsUncheckedUpdateManyWithoutOrdersInput>
  }

  export type VendorUpsertWithoutPurchaseOrderInput = {
    update: XOR<VendorUpdateWithoutPurchaseOrderInput, VendorUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<VendorCreateWithoutPurchaseOrderInput, VendorUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type VendorUpdateWithoutPurchaseOrderInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutPurchaseOrderInput = {
    update: XOR<UserUpdateWithoutPurchaseOrderInput, UserUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<UserCreateWithoutPurchaseOrderInput, UserUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type UserUpdateWithoutPurchaseOrderInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesOrder?: SalesOrderUpdateManyWithoutUserNestedInput
    UserRoles?: UserRolesUpdateManyWithoutUserNestedInput
    UserTokens?: UserTokensUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutUserNestedInput
    UserRoles?: UserRolesUncheckedUpdateManyWithoutUserNestedInput
    UserTokens?: UserTokensUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PurchaseOrderCreateWithoutOrdersInput = {
    purchaseOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorName: VendorCreateNestedOneWithoutPurchaseOrderInput
    user: UserCreateNestedOneWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutOrdersInput = {
    id?: number
    purchaseOrderNo?: string | null
    vendorId: number
    remarks?: string | null
    total: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateOrConnectWithoutOrdersInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutOrdersInput, PurchaseOrderUncheckedCreateWithoutOrdersInput>
  }

  export type ProductCreateWithoutPurchaseItemsInput = {
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    salesItems?: SalesItemsCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseItemsInput = {
    id?: number
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    salesItems?: SalesItemsUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type PurchaseOrderUpsertWithoutOrdersInput = {
    update: XOR<PurchaseOrderUpdateWithoutOrdersInput, PurchaseOrderUncheckedUpdateWithoutOrdersInput>
    create: XOR<PurchaseOrderCreateWithoutOrdersInput, PurchaseOrderUncheckedCreateWithoutOrdersInput>
  }

  export type PurchaseOrderUpdateWithoutOrdersInput = {
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorName?: VendorUpdateOneRequiredWithoutPurchaseOrderNestedInput
    user?: UserUpdateOneRequiredWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutPurchaseItemsInput = {
    update: XOR<ProductUpdateWithoutPurchaseItemsInput, ProductUncheckedUpdateWithoutPurchaseItemsInput>
    create: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type ProductUpdateWithoutPurchaseItemsInput = {
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesItems?: SalesItemsUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesItems?: SalesItemsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SalesItemsCreateWithoutSalesOrderInput = {
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSalesItemsInput
  }

  export type SalesItemsUncheckedCreateWithoutSalesOrderInput = {
    id?: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesItemsCreateOrConnectWithoutSalesOrderInput = {
    where: SalesItemsWhereUniqueInput
    create: XOR<SalesItemsCreateWithoutSalesOrderInput, SalesItemsUncheckedCreateWithoutSalesOrderInput>
  }

  export type SalesItemsCreateManySalesOrderInputEnvelope = {
    data: Enumerable<SalesItemsCreateManySalesOrderInput>
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutSalesOrderInput = {
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUncheckedCreateWithoutSalesOrderInput = {
    id?: number
    name: string
    address?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateOrConnectWithoutSalesOrderInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesOrderInput, CustomerUncheckedCreateWithoutSalesOrderInput>
  }

  export type UserCreateWithoutSalesOrderInput = {
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutUserInput
    UserRoles?: UserRolesCreateNestedManyWithoutUserInput
    UserTokens?: UserTokensCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalesOrderInput = {
    id?: number
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutUserInput
    UserRoles?: UserRolesUncheckedCreateNestedManyWithoutUserInput
    UserTokens?: UserTokensUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalesOrderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesOrderInput, UserUncheckedCreateWithoutSalesOrderInput>
  }

  export type SalesItemsUpsertWithWhereUniqueWithoutSalesOrderInput = {
    where: SalesItemsWhereUniqueInput
    update: XOR<SalesItemsUpdateWithoutSalesOrderInput, SalesItemsUncheckedUpdateWithoutSalesOrderInput>
    create: XOR<SalesItemsCreateWithoutSalesOrderInput, SalesItemsUncheckedCreateWithoutSalesOrderInput>
  }

  export type SalesItemsUpdateWithWhereUniqueWithoutSalesOrderInput = {
    where: SalesItemsWhereUniqueInput
    data: XOR<SalesItemsUpdateWithoutSalesOrderInput, SalesItemsUncheckedUpdateWithoutSalesOrderInput>
  }

  export type SalesItemsUpdateManyWithWhereWithoutSalesOrderInput = {
    where: SalesItemsScalarWhereInput
    data: XOR<SalesItemsUpdateManyMutationInput, SalesItemsUncheckedUpdateManyWithoutOrdersInput>
  }

  export type CustomerUpsertWithoutSalesOrderInput = {
    update: XOR<CustomerUpdateWithoutSalesOrderInput, CustomerUncheckedUpdateWithoutSalesOrderInput>
    create: XOR<CustomerCreateWithoutSalesOrderInput, CustomerUncheckedCreateWithoutSalesOrderInput>
  }

  export type CustomerUpdateWithoutSalesOrderInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateWithoutSalesOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSalesOrderInput = {
    update: XOR<UserUpdateWithoutSalesOrderInput, UserUncheckedUpdateWithoutSalesOrderInput>
    create: XOR<UserCreateWithoutSalesOrderInput, UserUncheckedCreateWithoutSalesOrderInput>
  }

  export type UserUpdateWithoutSalesOrderInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutUserNestedInput
    UserRoles?: UserRolesUpdateManyWithoutUserNestedInput
    UserTokens?: UserTokensUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutUserNestedInput
    UserRoles?: UserRolesUncheckedUpdateManyWithoutUserNestedInput
    UserTokens?: UserTokensUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SalesOrderCreateWithoutOrdersInput = {
    salesOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customerName: CustomerCreateNestedOneWithoutSalesOrderInput
    User?: UserCreateNestedOneWithoutSalesOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutOrdersInput = {
    id?: number
    salesOrderNo?: string | null
    customerId: number
    userId?: number | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesOrderCreateOrConnectWithoutOrdersInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutOrdersInput, SalesOrderUncheckedCreateWithoutOrdersInput>
  }

  export type ProductCreateWithoutSalesItemsInput = {
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseItems?: PurchaseItemsCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSalesItemsInput = {
    id?: number
    productName: string
    description?: string | null
    purchasePrice: number
    sellingPrice: number
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseItems?: PurchaseItemsUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSalesItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSalesItemsInput, ProductUncheckedCreateWithoutSalesItemsInput>
  }

  export type SalesOrderUpsertWithoutOrdersInput = {
    update: XOR<SalesOrderUpdateWithoutOrdersInput, SalesOrderUncheckedUpdateWithoutOrdersInput>
    create: XOR<SalesOrderCreateWithoutOrdersInput, SalesOrderUncheckedCreateWithoutOrdersInput>
  }

  export type SalesOrderUpdateWithoutOrdersInput = {
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerName?: CustomerUpdateOneRequiredWithoutSalesOrderNestedInput
    User?: UserUpdateOneWithoutSalesOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutSalesItemsInput = {
    update: XOR<ProductUpdateWithoutSalesItemsInput, ProductUncheckedUpdateWithoutSalesItemsInput>
    create: XOR<ProductCreateWithoutSalesItemsInput, ProductUncheckedCreateWithoutSalesItemsInput>
  }

  export type ProductUpdateWithoutSalesItemsInput = {
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: PurchaseItemsUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSalesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: PurchaseItemsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PurchaseOrderCreateWithoutVendorNameInput = {
    purchaseOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: PurchaseItemsCreateNestedManyWithoutPurchaseOrderInput
    user: UserCreateNestedOneWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutVendorNameInput = {
    id?: number
    purchaseOrderNo?: string | null
    remarks?: string | null
    total: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: PurchaseItemsUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutVendorNameInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutVendorNameInput, PurchaseOrderUncheckedCreateWithoutVendorNameInput>
  }

  export type PurchaseOrderCreateManyVendorNameInputEnvelope = {
    data: Enumerable<PurchaseOrderCreateManyVendorNameInput>
    skipDuplicates?: boolean
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutVendorNameInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutVendorNameInput, PurchaseOrderUncheckedUpdateWithoutVendorNameInput>
    create: XOR<PurchaseOrderCreateWithoutVendorNameInput, PurchaseOrderUncheckedCreateWithoutVendorNameInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutVendorNameInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutVendorNameInput, PurchaseOrderUncheckedUpdateWithoutVendorNameInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutVendorNameInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type SalesOrderCreateWithoutCustomerNameInput = {
    salesOrderNo?: string | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: SalesItemsCreateNestedManyWithoutSalesOrderInput
    User?: UserCreateNestedOneWithoutSalesOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutCustomerNameInput = {
    id?: number
    salesOrderNo?: string | null
    userId?: number | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: SalesItemsUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutCustomerNameInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutCustomerNameInput, SalesOrderUncheckedCreateWithoutCustomerNameInput>
  }

  export type SalesOrderCreateManyCustomerNameInputEnvelope = {
    data: Enumerable<SalesOrderCreateManyCustomerNameInput>
    skipDuplicates?: boolean
  }

  export type SalesOrderUpsertWithWhereUniqueWithoutCustomerNameInput = {
    where: SalesOrderWhereUniqueInput
    update: XOR<SalesOrderUpdateWithoutCustomerNameInput, SalesOrderUncheckedUpdateWithoutCustomerNameInput>
    create: XOR<SalesOrderCreateWithoutCustomerNameInput, SalesOrderUncheckedCreateWithoutCustomerNameInput>
  }

  export type SalesOrderUpdateWithWhereUniqueWithoutCustomerNameInput = {
    where: SalesOrderWhereUniqueInput
    data: XOR<SalesOrderUpdateWithoutCustomerNameInput, SalesOrderUncheckedUpdateWithoutCustomerNameInput>
  }

  export type SalesOrderUpdateManyWithWhereWithoutCustomerNameInput = {
    where: SalesOrderScalarWhereInput
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyWithoutSalesOrderInput>
  }

  export type UserRolesCreateWithoutRoleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRolesUncheckedCreateWithoutRoleInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRolesCreateOrConnectWithoutRoleInput = {
    where: UserRolesWhereUniqueInput
    create: XOR<UserRolesCreateWithoutRoleInput, UserRolesUncheckedCreateWithoutRoleInput>
  }

  export type UserRolesCreateManyRoleInputEnvelope = {
    data: Enumerable<UserRolesCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type UserRolesUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRolesWhereUniqueInput
    update: XOR<UserRolesUpdateWithoutRoleInput, UserRolesUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRolesCreateWithoutRoleInput, UserRolesUncheckedCreateWithoutRoleInput>
  }

  export type UserRolesUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRolesWhereUniqueInput
    data: XOR<UserRolesUpdateWithoutRoleInput, UserRolesUncheckedUpdateWithoutRoleInput>
  }

  export type UserRolesUpdateManyWithWhereWithoutRoleInput = {
    where: UserRolesScalarWhereInput
    data: XOR<UserRolesUpdateManyMutationInput, UserRolesUncheckedUpdateManyWithoutUserRolesInput>
  }

  export type UserCreateWithoutUserRolesInput = {
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutUserInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutUserInput
    UserTokens?: UserTokensCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: number
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutUserInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutUserInput
    UserTokens?: UserTokensUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type RolesCreateWithoutUserRolesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolesUncheckedCreateWithoutUserRolesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolesCreateOrConnectWithoutUserRolesInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutUserRolesInput, RolesUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutUserNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutUserNestedInput
    UserTokens?: UserTokensUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutUserNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutUserNestedInput
    UserTokens?: UserTokensUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RolesUpsertWithoutUserRolesInput = {
    update: XOR<RolesUpdateWithoutUserRolesInput, RolesUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RolesCreateWithoutUserRolesInput, RolesUncheckedCreateWithoutUserRolesInput>
  }

  export type RolesUpdateWithoutUserRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolesUncheckedUpdateWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUserTokensInput = {
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutUserInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutUserInput
    UserRoles?: UserRolesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserTokensInput = {
    id?: number
    email: string
    firstName?: string | null
    lastName?: string | null
    address?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutUserInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutUserInput
    UserRoles?: UserRolesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserTokensInput, UserUncheckedCreateWithoutUserTokensInput>
  }

  export type UserUpsertWithoutUserTokensInput = {
    update: XOR<UserUpdateWithoutUserTokensInput, UserUncheckedUpdateWithoutUserTokensInput>
    create: XOR<UserCreateWithoutUserTokensInput, UserUncheckedCreateWithoutUserTokensInput>
  }

  export type UserUpdateWithoutUserTokensInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutUserNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutUserNestedInput
    UserRoles?: UserRolesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutUserNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutUserNestedInput
    UserRoles?: UserRolesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PurchaseOrderCreateManyUserInput = {
    id?: number
    purchaseOrderNo?: string | null
    vendorId: number
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesOrderCreateManyUserInput = {
    id?: number
    salesOrderNo?: string | null
    customerId: number
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRolesCreateManyUserInput = {
    id?: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTokensCreateManyUserInput = {
    id?: number
    expiry: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateWithoutUserInput = {
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: PurchaseItemsUpdateManyWithoutPurchaseOrderNestedInput
    vendorName?: VendorUpdateOneRequiredWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: PurchaseItemsUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderUpdateWithoutUserInput = {
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: SalesItemsUpdateManyWithoutSalesOrderNestedInput
    customerName?: CustomerUpdateOneRequiredWithoutSalesOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: SalesItemsUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateManyWithoutSalesOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRolesUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RolesUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRolesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRolesUncheckedUpdateManyWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTokensUpdateWithoutUserInput = {
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTokensUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTokensUncheckedUpdateManyWithoutUserTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemsCreateManyProductInput = {
    id?: number
    purchaseOrderId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesItemsCreateManyProductInput = {
    id?: number
    salesOrderId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemsUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type PurchaseItemsUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemsUncheckedUpdateManyWithoutPurchaseItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesItemsUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesOrder?: SalesOrderUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type SalesItemsUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesItemsUncheckedUpdateManyWithoutSalesItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemsCreateManyPurchaseOrderInput = {
    id?: number
    productId: number
    quantity: number
    purchasePrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseItemsUpdateWithoutPurchaseOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput
  }

  export type PurchaseItemsUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemsUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesItemsCreateManySalesOrderInput = {
    id?: number
    productId: number
    quantity: number
    sellingPrice: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesItemsUpdateWithoutSalesOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSalesItemsNestedInput
  }

  export type SalesItemsUncheckedUpdateWithoutSalesOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesItemsUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateManyVendorNameInput = {
    id?: number
    purchaseOrderNo?: string | null
    remarks?: string | null
    total: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateWithoutVendorNameInput = {
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: PurchaseItemsUpdateManyWithoutPurchaseOrderNestedInput
    user?: UserUpdateOneRequiredWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutVendorNameInput = {
    id?: IntFieldUpdateOperationsInput | number
    purchaseOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: PurchaseItemsUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type SalesOrderCreateManyCustomerNameInput = {
    id?: number
    salesOrderNo?: string | null
    userId?: number | null
    remarks?: string | null
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesOrderUpdateWithoutCustomerNameInput = {
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: SalesItemsUpdateManyWithoutSalesOrderNestedInput
    User?: UserUpdateOneWithoutSalesOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutCustomerNameInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOrderNo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: SalesItemsUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type UserRolesCreateManyRoleInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRolesUpdateWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRolesUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}